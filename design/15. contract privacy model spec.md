# Contract Privacy Model Specification

## 1. Executive Summary

This document specifies how Ecliptica smart contracts interact with encrypted state while maintaining privacy, determinism, and security. The model enables **confidential computing on blockchain** where contract execution occurs over encrypted data with zero-knowledge proofs of correctness.

**Key Features:**
- **Encrypted Contract State**: All storage encrypted at rest and in transit
- **Privacy-Preserving Contract Calls**: Inter-contract communication with encrypted parameters
- **Selective Disclosure via Viewing Keys**: Granular read access without compromising privacy
- **Event Logging with Privacy**: Encrypted events with opt-in decryption
- **Deterministic Gas Metering**: Fixed costs for encrypted operations

**Privacy Guarantee**: Contract execution reveals only proof of validity, not execution details or intermediate state.

---

## 2. Contract State Visibility Rules

### 2.1 State Access Model

Ecliptica uses a **three-tier visibility model** for contract state:

| Visibility Level | Who Can Access      | What's Revealed         | Use Case                  |
| ---------------- | ------------------- | ----------------------- | ------------------------- |
| **Private**      | Contract owner only | Nothing on-chain        | Sensitive business logic  |
| **Permissioned** | Viewing key holders | Encrypted data + proofs | Selective disclosure      |
| **Public**       | Anyone              | Plaintext data          | Public registries, voting |

### 2.2 State Encryption Architecture

```rust
// Contract storage structure
struct ContractState {
    // Contract metadata (public)
    contract_address: Address,
    code_hash: [u8; 32],                // WASM bytecode hash
    owner: Address,
    
    // Encrypted storage (private)
    encrypted_storage: EncryptedKVStore,
    
    // State commitment (public)
    state_root: [u8; 32],               // Merkle root of encrypted state
    
    // Access control
    viewing_keys: HashMap<Address, ViewingKeyPermissions>,
}

// Encrypted key-value store
struct EncryptedKVStore {
    // All values encrypted with contract storage key
    storage: HashMap<[u8; 32], Vec<u8>>,  // key_hash → encrypted_value
    
    // Storage key derivation
    contract_storage_key: [u8; 32],       // Derived from contract address
    
    // State commitment
    merkle_tree: SparseMerkleTree,        // For state proofs
}
```

### 2.3 Storage Key Derivation

**Deterministic Key Derivation**:

```rust
fn derive_contract_storage_key(contract_address: &Address) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_STORAGE_KEY_v1");
    hasher.update(contract_address.as_bytes());
    
    let mut key = [0u8; 32];
    hasher.finalize_xof_into(&mut key);
    key
}

fn compute_storage_key_hash(
    contract_address: &Address,
    storage_key: &[u8],
) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_STORAGE_KEY_HASH_v1");
    hasher.update(contract_address.as_bytes());
    hasher.update(storage_key);
    
    let mut hash = [0u8; 32];
    hasher.finalize_xof_into(&mut hash);
    hash
}
```

### 2.4 Encrypted Storage Operations

```rust
impl EncryptedKVStore {
    /// Write encrypted value to storage
    pub fn write(
        &mut self,
        key: &[u8],
        value: &[u8],
        contract_addr: &Address,
    ) -> Result<()> {
        // 1. Compute storage key hash
        let key_hash = compute_storage_key_hash(contract_addr, key);
        
        // 2. Encrypt value with AES-256-GCM
        let encrypted_value = self.encrypt_value(value)?;
        
        // 3. Store encrypted value
        self.storage.insert(key_hash, encrypted_value.clone());
        
        // 4. Update Merkle tree
        self.merkle_tree.insert(key_hash, shake256(&encrypted_value));
        
        // 5. Update state root
        self.update_state_root()?;
        
        Ok(())
    }
    
    /// Read encrypted value from storage
    pub fn read(
        &self,
        key: &[u8],
        contract_addr: &Address,
    ) -> Result<Vec<u8>> {
        let key_hash = compute_storage_key_hash(contract_addr, key);
        
        let encrypted_value = self.storage.get(&key_hash)
            .ok_or(Error::KeyNotFound)?;
        
        // Decrypt value
        self.decrypt_value(encrypted_value)
    }
    
    /// Encrypt value using contract storage key
    fn encrypt_value(&self, plaintext: &[u8]) -> Result<Vec<u8>> {
        // Use AES-256-GCM for authenticated encryption
        let nonce = generate_deterministic_nonce(plaintext);
        
        aes_gcm_encrypt(
            &self.contract_storage_key,
            &nonce,
            plaintext,
            &[], // No additional authenticated data
        )
    }
    
    /// Decrypt value using contract storage key
    fn decrypt_value(&self, ciphertext: &[u8]) -> Result<Vec<u8>> {
        aes_gcm_decrypt(
            &self.contract_storage_key,
            ciphertext,
        )
    }
}

// Deterministic nonce generation (for reproducibility)
fn generate_deterministic_nonce(plaintext: &[u8]) -> [u8; 12] {
    let hash = shake256(plaintext);
    let mut nonce = [0u8; 12];
    nonce.copy_from_slice(&hash[0..12]);
    nonce
}
```

### 2.5 State Visibility Rules

**Rule 1: Storage is Private by Default**
- All contract storage encrypted with contract-specific key
- Only contract code can decrypt during execution
- External observers see only encrypted blobs + commitments

**Rule 2: Viewing Keys Enable Selective Disclosure**
- Contract owner can issue viewing keys for specific storage keys
- Viewing keys grant read-only access (cannot modify state)
- Different viewing keys can have different permissions

**Rule 3: State Transitions are Proven, Not Revealed**
- zk-STARK proofs attest to valid state transitions
- Proofs reveal nothing about intermediate state
- Validators verify proofs without seeing plaintext

---

## 3. Privacy-Preserving Contract Calls

### 3.1 Inter-Contract Call Model

**Challenge**: How can contracts call each other without leaking data?

**Solution**: Encrypted message passing with zk proofs.

```rust
// Inter-contract call structure
struct PrivateContractCall {
    // Caller information (public)
    caller_contract: Address,
    caller_method: String,
    
    // Target information (public)
    target_contract: Address,
    target_method: String,
    
    // Encrypted parameters (private)
    encrypted_params: Vec<u8>,          // ML-KEM encrypted
    ephemeral_public_key: [u8; 800],    // For ML-KEM
    
    // State transition proof (public)
    state_transition_proof: zk_stark::Proof,
    
    // Gas and nonce
    gas_limit: u64,
    nonce: u64,
}
```

### 3.2 Cross-Contract Call Protocol

**Protocol Flow**:

```
1. Caller Contract
   ↓
   Encrypt call parameters with target's public key (ML-KEM-512)
   Generate zk-STARK proof of valid pre-state
   ↓
2. Submit Call Transaction
   ↓
3. Validator Executes Call
   ↓
   Decrypt parameters in execution environment
   Invoke target contract method
   ↓
4. Target Contract Execution
   ↓
   Process call with decrypted parameters
   Update state (encrypted)
   Generate return value (encrypted)
   ↓
5. Return to Caller
   ↓
   Encrypt return value with caller's public key
   Generate zk-STARK proof of valid post-state
   ↓
6. Caller Receives Result
   ↓
   Decrypt return value
   Continue execution
```

### 3.3 Implementation

```rust
// Host function for calling other contracts
pub fn call_contract(
    target_address: &Address,
    method: &str,
    params: &[u8],
    gas_limit: u64,
) -> Result<Vec<u8>> {
    // 1. Get target contract's public key
    let target_pubkey = get_contract_public_key(target_address)?;
    
    // 2. Encrypt parameters with ML-KEM-512
    let (ciphertext, ephemeral_pubkey) = ml_kem_encrypt(
        &target_pubkey,
        params,
    )?;
    
    // 3. Generate state transition proof
    let proof = generate_state_transition_proof(
        &get_current_state(),
        target_address,
        method,
        &ciphertext,
    )?;
    
    // 4. Create call message
    let call_msg = PrivateContractCall {
        caller_contract: current_contract_address(),
        caller_method: current_method(),
        target_contract: *target_address,
        target_method: method.to_string(),
        encrypted_params: ciphertext,
        ephemeral_public_key: ephemeral_pubkey,
        state_transition_proof: proof,
        gas_limit,
        nonce: get_and_increment_nonce(),
    };
    
    // 5. Submit call (executed by validator)
    let result = execute_private_call(call_msg)?;
    
    // 6. Decrypt result
    let plaintext_result = ml_kem_decrypt(
        &get_contract_secret_key(),
        &result.encrypted_return_value,
    )?;
    
    Ok(plaintext_result)
}

// Validator-side execution
fn execute_private_call(call: PrivateContractCall) -> Result<CallResult> {
    // 1. Verify state transition proof
    verify_stark_proof(&call.state_transition_proof)?;
    
    // 2. Load target contract
    let target_contract = load_contract(&call.target_contract)?;
    
    // 3. Decrypt parameters (validator has access during execution)
    let secret_key = get_contract_secret_key_for_execution(&call.target_contract);
    let plaintext_params = ml_kem_decrypt(&secret_key, &call.encrypted_params)?;
    
    // 4. Execute target method
    let execution_result = target_contract.invoke_method(
        &call.target_method,
        &plaintext_params,
        call.gas_limit,
    )?;
    
    // 5. Encrypt return value for caller
    let caller_pubkey = get_contract_public_key(&call.caller_contract)?;
    let (encrypted_return, _) = ml_kem_encrypt(&caller_pubkey, &execution_result)?;
    
    // 6. Generate post-state proof
    let post_proof = generate_state_transition_proof(
        &get_updated_state(),
        &call.caller_contract,
        &call.caller_method,
        &encrypted_return,
    )?;
    
    Ok(CallResult {
        encrypted_return_value: encrypted_return,
        post_state_proof: post_proof,
        gas_used: execution_result.gas_used,
    })
}
```

### 3.4 Privacy Guarantees

**What's Hidden**:
- ✓ Call parameters (ML-KEM encrypted)
- ✓ Return values (ML-KEM encrypted)
- ✓ Intermediate state during execution
- ✓ Computation details

**What's Revealed**:
- ✗ Caller contract address (necessary for routing)
- ✗ Target contract address (necessary for routing)
- ✗ Method name (necessary for invocation)
- ✗ Gas used (necessary for fee calculation)
- ✗ Call succeeded/failed (necessary for error handling)

### 3.5 Re-entrancy Protection

```rust
// Call stack tracking to prevent re-entrancy attacks
struct CallStack {
    stack: Vec<ContractCallFrame>,
    max_depth: usize,
}

struct ContractCallFrame {
    contract_address: Address,
    method: String,
    gas_remaining: u64,
}

impl CallStack {
    fn push(&mut self, frame: ContractCallFrame) -> Result<()> {
        // Check for re-entrancy
        if self.stack.iter().any(|f| f.contract_address == frame.contract_address) {
            return Err(Error::ReentrancyDetected);
        }
        
        // Check max depth
        if self.stack.len() >= self.max_depth {
            return Err(Error::CallDepthExceeded);
        }
        
        self.stack.push(frame);
        Ok(())
    }
    
    fn pop(&mut self) -> Option<ContractCallFrame> {
        self.stack.pop()
    }
}

const MAX_CALL_DEPTH: usize = 10;
```

---

## 4. Event Logging with Privacy

### 4.1 Encrypted Event Model

**Design Goals**:
- Events must be auditable by authorized parties
- Events must not leak information to unauthorized observers
- Event ordering and existence must be verifiable

```rust
// Encrypted event structure
struct PrivateEvent {
    // Event metadata (public)
    contract_address: Address,
    block_height: u64,
    transaction_hash: [u8; 32],
    event_index: u32,
    
    // Event identifier (public)
    topic: [u8; 32],                    // SHAKE-256 hash of event name
    
    // Encrypted event data (private)
    encrypted_data: Vec<u8>,            // ML-KEM encrypted
    ephemeral_public_key: [u8; 800],
    
    // Event commitment (public)
    event_commitment: [u8; 32],         // For verification
    
    // Access control
    authorized_viewers: Vec<Address>,   // Who can decrypt
}
```

### 4.2 Event Emission

```rust
// Contract SDK function for emitting events
pub fn emit_private_event(
    event_name: &str,
    event_data: &[u8],
    authorized_viewers: &[Address],
) -> Result<()> {
    // 1. Compute event topic
    let topic = shake256(event_name.as_bytes());
    
    // 2. Encrypt event data for each authorized viewer
    let mut encrypted_data_list = Vec::new();
    
    for viewer in authorized_viewers {
        let viewer_pubkey = get_contract_public_key(viewer)?;
        let (ciphertext, ephemeral_pk) = ml_kem_encrypt(&viewer_pubkey, event_data)?;
        
        encrypted_data_list.push((viewer, ciphertext, ephemeral_pk));
    }
    
    // 3. Create event commitment
    let commitment = compute_event_commitment(
        &current_contract_address(),
        event_name,
        event_data,
    );
    
    // 4. Emit event on-chain
    let event = PrivateEvent {
        contract_address: current_contract_address(),
        block_height: current_block_height(),
        transaction_hash: current_transaction_hash(),
        event_index: get_and_increment_event_index(),
        topic,
        encrypted_data: encrypted_data_list[0].1.clone(), // Store first encryption
        ephemeral_public_key: encrypted_data_list[0].2,
        event_commitment: commitment,
        authorized_viewers: authorized_viewers.to_vec(),
    };
    
    emit_event_on_chain(event)?;
    
    Ok(())
}

fn compute_event_commitment(
    contract_addr: &Address,
    event_name: &str,
    event_data: &[u8],
) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_EVENT_COMMITMENT_v1");
    hasher.update(contract_addr.as_bytes());
    hasher.update(event_name.as_bytes());
    hasher.update(event_data);
    
    let mut commitment = [0u8; 32];
    hasher.finalize_xof_into(&mut commitment);
    commitment
}
```

### 4.3 Event Subscription and Filtering

```rust
// Event query interface
pub struct EventFilter {
    // Filter by contract (public)
    contract_address: Option<Address>,
    
    // Filter by topic (public)
    topics: Vec<[u8; 32]>,
    
    // Block range (public)
    from_block: u64,
    to_block: u64,
    
    // Viewing key for decryption (private)
    viewing_key: Option<[u8; 32]>,
}

impl EventFilter {
    pub fn query_events(&self) -> Result<Vec<DecryptedEvent>> {
        // 1. Query encrypted events from chain
        let encrypted_events = query_events_from_chain(
            self.contract_address,
            &self.topics,
            self.from_block,
            self.to_block,
        )?;
        
        // 2. Decrypt events with viewing key (if provided)
        let mut decrypted_events = Vec::new();
        
        for event in encrypted_events {
            if let Some(ref vk) = self.viewing_key {
                // Try to decrypt
                if let Ok(plaintext) = ml_kem_decrypt(vk, &event.encrypted_data) {
                    decrypted_events.push(DecryptedEvent {
                        contract_address: event.contract_address,
                        block_height: event.block_height,
                        topic: event.topic,
                        data: plaintext,
                    });
                }
            } else {
                // Return encrypted event (no decryption)
                decrypted_events.push(DecryptedEvent {
                    contract_address: event.contract_address,
                    block_height: event.block_height,
                    topic: event.topic,
                    data: event.encrypted_data.clone(), // Still encrypted
                });
            }
        }
        
        Ok(decrypted_events)
    }
}
```

### 4.4 Event Verification

Even without decryption, events can be verified for integrity:

```rust
pub fn verify_event_commitment(event: &PrivateEvent) -> bool {
    // Verify commitment matches on-chain data
    // (This proves event was emitted by contract, even if encrypted)
    
    let reconstructed_commitment = shake256(&[
        event.contract_address.as_bytes(),
        &event.topic,
        &event.encrypted_data,
    ].concat());
    
    reconstructed_commitment == event.event_commitment
}
```

### 4.5 Event Privacy Levels

Contracts can choose different privacy levels for events:

```rust
pub enum EventPrivacyLevel {
    // Fully encrypted, only authorized viewers
    Private {
        authorized_viewers: Vec<Address>,
    },
    
    // Partially encrypted (topic public, data encrypted)
    Selective {
        public_fields: Vec<String>,
        encrypted_fields: Vec<String>,
        authorized_viewers: Vec<Address>,
    },
    
    // Fully public (no encryption)
    Public,
}

// Example: Transfer event with selective privacy
pub fn emit_transfer_event(
    from: Address,
    to: Address,
    amount: u64,
    privacy: EventPrivacyLevel,
) -> Result<()> {
    match privacy {
        EventPrivacyLevel::Private { authorized_viewers } => {
            let data = serialize_transfer_event(from, to, amount);
            emit_private_event("Transfer", &data, &authorized_viewers)
        }
        
        EventPrivacyLevel::Selective { .. } => {
            // Reveal 'from' and 'to', encrypt 'amount'
            let public_data = serialize_public_fields(&[
                ("from", from.as_bytes()),
                ("to", to.as_bytes()),
            ]);
            
            let private_data = serialize(&amount);
            let encrypted_amount = encrypt_for_viewers(&private_data, &authorized_viewers)?;
            
            emit_selective_event("Transfer", public_data, encrypted_amount)
        }
        
        EventPrivacyLevel::Public => {
            // Emit plaintext event
            let data = serialize_transfer_event(from, to, amount);
            emit_public_event("Transfer", &data)
        }
    }
}
```

---

## 5. Contract-to-Contract Interaction Model

### 5.1 Interaction Patterns

**Pattern 1: Synchronous Call (Most Common)**

```rust
// Contract A calls Contract B
#[contract_impl]
impl TokenA {
    pub fn swap_for_token_b(&mut self, amount: u64) -> Result<u64> {
        // 1. Burn tokens in this contract
        self.burn(context::caller(), amount)?;
        
        // 2. Call TokenB contract to mint equivalent
        let token_b_address = self.token_b_address;
        
        let result: u64 = contract::call(
            &token_b_address,
            "mint",
            &serialize(&MintArgs {
                recipient: context::caller(),
                amount,
            }),
            100_000, // gas limit
        )?;
        
        Ok(result)
    }
}
```

**Pattern 2: Callback Pattern**

```rust
// Contract A requests callback from Contract B
#[contract_impl]
impl Oracle {
    pub fn request_price(
        &mut self,
        token: Address,
        callback_contract: Address,
        callback_method: String,
    ) -> Result<RequestId> {
        // Store callback information
        let request_id = self.next_request_id;
        self.next_request_id += 1;
        
        self.pending_requests.insert(request_id, PendingRequest {
            token,
            callback_contract,
            callback_method,
            requester: context::caller(),
        });
        
        // Oracle will call back later with price
        Ok(request_id)
    }
    
    // Called by oracle operator
    pub fn fulfill_request(&mut self, request_id: RequestId, price: u64) -> Result<()> {
        let request = self.pending_requests.remove(&request_id)
            .ok_or(Error::RequestNotFound)?;
        
        // Call back to requester contract
        contract::call(
            &request.callback_contract,
            &request.callback_method,
            &serialize(&PriceResponse {
                token: request.token,
                price,
                timestamp: context::block_timestamp(),
            }),
            200_000,
        )?;
        
        Ok(())
    }
}
```

**Pattern 3: Event-Driven Interaction**

```rust
// Contract A emits event, Contract B reacts
#[contract_impl]
impl DEX {
    pub fn create_order(&mut self, token: Address, amount: u64, price: u64) -> Result<OrderId> {
        let order_id = self.next_order_id;
        self.next_order_id += 1;
        
        self.orders.insert(order_id, Order {
            creator: context::caller(),
            token,
            amount,
            price,
            status: OrderStatus::Open,
        });
        
        // Emit event (can be subscribed by market maker contracts)
        contract::emit_event(
            "OrderCreated",
            &serialize(&OrderCreatedEvent {
                order_id,
                token,
                amount,
                price,
            }),
            EventPrivacyLevel::Selective {
                public_fields: vec!["order_id", "token"],
                encrypted_fields: vec!["amount", "price"],
                authorized_viewers: vec![self.market_maker_address],
            },
        )?;
        
        Ok(order_id)
    }
}
```

### 5.2 Composability with Privacy

**Challenge**: How to compose contracts while maintaining privacy?

**Solution**: Interface-based composition with encrypted messages.

```rust
// Define standard interfaces
pub trait PrivateToken {
    fn transfer(&mut self, to: Address, amount: u64) -> Result<()>;
    fn balance_of(&self, account: Address) -> Result<u64>;
}

pub trait PrivateDEX {
    fn swap(&mut self, from_token: Address, to_token: Address, amount: u64) -> Result<u64>;
}

// Implement composable DEX
#[contract_impl]
impl MultiTokenDEX {
    pub fn swap_a_to_c_via_b(
        &mut self,
        token_a: Address,
        token_b: Address,
        token_c: Address,
        amount_a: u64,
    ) -> Result<u64> {
        // 1. Swap A → B
        let amount_b = self.swap_internal(token_a, token_b, amount_a)?;
        
        // 2. Swap B → C
        let amount_c = self.swap_internal(token_b, token_c, amount_b)?;
        
        Ok(amount_c)
    }
    
    fn swap_internal(
        &self,
        from_token: Address,
        to_token: Address,
        amount: u64,
    ) -> Result<u64> {
        // Encrypted call to token contract
        contract::call(
            &from_token,
            "transfer",
            &serialize(&TransferArgs {
                from: context::caller(),
                to: current_contract_address(),
                amount,
            }),
            100_000,
        )?;
        
        // Calculate swap amount (using private reserves)
        let amount_out = self.calculate_output(from_token, to_token, amount)?;
        
        // Transfer output token
        contract::call(
            &to_token,
            "transfer",
            &serialize(&TransferArgs {
                from: current_contract_address(),
                to: context::caller(),
                amount: amount_out,
            }),
            100_000,
        )?;
        
        Ok(amount_out)
    }
}
```

### 5.3 Privacy-Preserving State Queries

Contracts can query other contracts' state without revealing the query:

```rust
// Privacy-preserving balance query
pub fn query_balance_privately(
    token_contract: Address,
    account: Address,
    viewing_key: &[u8; 32],
) -> Result<u64> {
    // 1. Encrypt query parameters
    let token_pubkey = get_contract_public_key(&token_contract)?;
    let (encrypted_query, _) = ml_kem_encrypt(
        &token_pubkey,
        &serialize(&BalanceQuery { account }),
    )?;
    
    // 2. Call contract with encrypted query
    let encrypted_result = contract::call(
        &token_contract,
        "balance_of_encrypted",
        &encrypted_query,
        50_000,
    )?;
    
    // 3. Decrypt result
    let plaintext_result = ml_kem_decrypt(viewing_key, &encrypted_result)?;
    let balance: u64 = deserialize(&plaintext_result)?;
    
    Ok(balance)
}
```

---

## 6. Gas Metering for Encrypted Operations

### 6.1 Gas Cost Model

**Philosophy**: Gas costs must be deterministic and independent of encrypted data values to prevent information leakage through gas usage.

```rust
// Gas cost schedule for privacy operations
const GAS_COSTS: GasCostSchedule = GasCostSchedule {
    // Storage operations
    storage_read: 5_000,
    storage_write: 20_000,
    storage_remove: 20_000,
    
    // Cryptographic operations
    ml_kem_encrypt: 10_000,
    ml_kem_decrypt: 10_000,
    ml_dsa_sign: 15_000,
    ml_dsa_verify: 8_000,
    shake256_hash: 1_000,
    
    // Contract operations
    contract_call_base: 50_000,
    contract_call_per_byte: 10,
    event_emission_base: 1_000,
    event_emission_per_byte: 5,
    
    // Zero-knowledge proofs
    zk_stark_generate: 100_000,
    zk_stark_verify: 10_000,
    
    // WASM instructions
    wasm_instruction_base: 1,
    wasm_memory_access: 3,
    wasm_arithmetic: 4,
    wasm_division: 16,
    wasm_function_call: 10,
};
```

### 6.2 Fixed-Cost Encryption

**Critical**: Encryption gas cost must be independent of plaintext content.

```rust
fn charge_gas_for_encryption(
    gas_meter: &mut GasMeter,
    plaintext_len: usize,
) -> Result<()> {
    // Base cost for ML-KEM operation
    gas_meter.consume(GAS_COSTS.ml_kem_encrypt)?;
    
    // Per-byte cost (independent of content)
    let size_cost = (plaintext_len / 32) * 100; // Round to 32-byte blocks
    gas_meter.consume(size_cost)?;
    
    Ok(())
}

// Example: Always charge same gas for same-sized ciphertexts
fn encrypt_and_charge_gas(
    plaintext: &[u8],
    pubkey: &[u8; 800],
    gas_meter: &mut GasMeter,
) -> Result<Vec<u8>> {
    // Charge gas BEFORE encryption (prevents timing attacks)
    charge_gas_for_encryption(gas_meter, plaintext.len())?;
    
    // Perform encryption
    let (ciphertext, _) = ml_kem_encrypt(pubkey, plaintext)?;
    
    Ok(ciphertext)
}
```

### 6.3 Storage Gas Costs

```rust
// Storage costs are size-based, not content-based
fn charge_gas_for_storage_write(
    gas_meter: &mut GasMeter,
    key_len: usize,
    value_len: usize,
) -> Result<()> {
    // Base cost
    gas_meter.consume(GAS_COSTS.storage_write)?;
    
    // Size-based cost (encrypted values are always padded)
    let padded_size = round_up_to_block_size(value_len, 64);
    let size_cost = padded_size * 10;
    gas_meter.consume(size_cost)?;
    
    Ok(())
}

fn round_up_to_block_size(size: usize, block_size: usize) -> usize {
    ((size + block_size - 1) / block_size) * block_size
}
```

### 6.4 Gas Metering Implementation

```rust
pub struct GasMeter {
    gas_limit: u64,
    gas_used: u64,
}

impl GasMeter {
    pub fn new(gas_limit: u64) -> Self {
        Self {
            gas_limit,
            gas_used: 0,
        }
    }
    
    pub fn consume(&mut self, amount: u64) -> Result<()> {
        self.gas_used = self.gas_used.checked_add(amount)
            .ok_or(Error::GasOverflow)?;
        
        if self.gas_used > self.gas_limit {
            return Err(Error::OutOfGas {
                limit: self.gas_limit,
                used: self.gas_used,
            });
        }
        
        Ok(())
    }
    
    pub fn remaining(&self) -> u64 {
        self.gas_limit.saturating_sub(self.gas_used)
    }
}

// Gas metering middleware for WASM execution
fn inject_gas_metering(wasm_module: &mut Module) -> Result<()> {
    // Inject gas counter at beginning of each function
    for func in wasm_module.functions_mut() {
        inject_gas_check(func, GAS_COSTS.wasm_instruction_base)?;
    }
    
    // Inject gas checks before expensive operations
    for instr in wasm_module.instructions_mut() {
        match instr {
            Instruction::Call(_) => {
                inject_gas_check_before(instr, GAS_COSTS.wasm_function_call)?;
            }
            Instruction::I64Div(_) | Instruction::I64RemU(_) => {
                inject_gas_check_before(instr, GAS_COSTS.wasm_division)?;
            }
            _ => {}
        }
    }
    
    Ok(())
}
```

### 6.5 Gas Estimation

Contracts can estimate gas before execution:

```rust
pub fn estimate_gas(
    contract_address: &Address,
    method: &str,
    params: &[u8],
) -> Result<u64> {
    // Run in dry-run mode (no state changes)
    let mut test_state = create_test_state(contract_address)?;
    let mut gas_meter = GasMeter::new(u64::MAX);
    
    // Execute contract
    let _ = execute_contract_method(
        &mut test_state,
        contract_address,
        method,
        params,
        &mut gas_meter,
    );
    
    // Add 20% buffer for safety
    let estimated_gas = gas_meter.gas_used;
    let with_buffer = estimated_gas * 120 / 100;
    
    Ok(with_buffer)
}
```

---

## 7. Complete Examples

### 7.1 Private Token Contract

```rust
use ecliptica_contract_sdk::*;

#[contract]
pub struct PrivateToken {
    name: String,
    symbol: String,
    total_supply: u64,
    
    // Encrypted balances: Address → EncryptedBalance
    balances: storage::Map<Address, Vec<u8>>,
    
    // Balance commitments (public)
    commitments: storage::Map<Address, [u8; 32]>,
}

#[contract_impl]
impl PrivateToken {
    pub fn new(name: String, symbol: String, initial_supply: u64) -> Self {
        let mut token = Self {
            name,
            symbol,
            total_supply: initial_supply,
            balances: storage::Map::new(b"balances"),
            commitments: storage::Map::new(b"commitments"),
        };
        
        // Mint initial supply to deployer
        let deployer = context::caller();
        token.mint_internal(deployer, initial_supply);
        
        token
    }
    
    /// Transfer tokens (fully private)
    pub fn transfer(&mut self, to: Address, amount: u64) -> Result<()> {
        let from = context::caller();
        
        // 1. Read and decrypt sender balance
        let from_balance = self.get_balance_internal(from)?;
        if from_balance < amount {
            return Err(Error::InsufficientBalance);
        }
        
        // 2. Read and decrypt recipient balance
        let to_balance = self.get_balance_internal(to)?;
        
        // 3. Update balances
        self.set_balance_internal(from, from_balance - amount)?;
        self.set_balance_internal(to, to_balance + amount)?;
        
        // 4. Emit encrypted transfer event
        contract::emit_event(
            "Transfer",
            &serialize(&TransferEvent { from, to, amount }),
            EventPrivacyLevel::Private {
                authorized_viewers: vec![from, to],
            },
        )?;
        
        Ok(())
    }
    
    /// Get balance (requires viewing key)
    pub fn balance_of(&self, account: Address, viewing_key: &[u8; 32]) -> Result<u64> {
        // Verify viewing key
        self.verify_viewing_key(account, viewing_key)?;
        
        // Return decrypted balance
        self.get_balance_internal(account)
    }
    
    // Internal helpers
    
    fn get_balance_internal(&self, account: Address) -> Result<u64> {
        let encrypted = self.balances.get(&account)
            .unwrap_or_else(|| vec![0u8; 32]);
        
        if encrypted.len() == 32 && encrypted.iter().all(|&b| b == 0) {
            return Ok(0);
        }
        
        let plaintext = storage::decrypt(&encrypted)?;
        let balance = u64::from_le_bytes(plaintext.try_into().unwrap());
        
        Ok(balance)
    }
    
    fn set_balance_internal(&mut self, account: Address, balance: u64) -> Result<()> {
        let plaintext = balance.to_le_bytes();
        let encrypted = storage::encrypt(&plaintext)?;
        
        self.balances.set(&account, encrypted);
        
        // Update commitment
        let commitment = compute_balance_commitment(balance);
        self.commitments.set(&account, commitment);
        
        Ok(())
    }
    
    fn mint_internal(&mut self, account: Address, amount: u64) {
        let current_balance = self.get_balance_internal(account).unwrap_or(0);
        self.set_balance_internal(account, current_balance + amount).unwrap();
    }
    
    fn verify_viewing_key(&self, account: Address, vk: &[u8; 32]) -> Result<()> {
        let expected_vk = derive_account_viewing_key(account);
        
        if vk != &expected_vk {
            return Err(Error::InvalidViewingKey);
        }
        
        Ok(())
    }
}

fn compute_balance_commitment(balance: u64) -> [u8; 32] {
    shake256(&balance.to_le_bytes())
}
```

### 7.2 Private Voting Contract

```rust
use ecliptica_contract_sdk::*;

#[contract]
pub struct PrivateVoting {
    title: String,
    description: String,
    admin: Address,
    
    // Voting period
    start_block: u64,
    end_block: u64,
    
    // Encrypted vote tallies
    yes_votes: Vec<u8>,  // Encrypted count
    no_votes: Vec<u8>,   // Encrypted count
    
    // Vote commitments (prevent double-voting)
    vote_commitments: storage::Map<Address, [u8; 32]>,
    
    // Admin viewing key
    admin_viewing_key: [u8; 32],
}

#[contract_impl]
impl PrivateVoting {
    pub fn new(
        title: String,
        description: String,
        start_block: u64,
        duration_blocks: u64,
    ) -> Self {
        let admin = context::caller();
        let admin_vk = derive_admin_viewing_key(admin);
        
        Self {
            title,
            description,
            admin,
            start_block,
            end_block: start_block + duration_blocks,
            yes_votes: encrypt_count(0),
            no_votes: encrypt_count(0),
            vote_commitments: storage::Map::new(b"votes"),
            admin_viewing_key: admin_vk,
        }
    }
    
    /// Cast vote with zero-knowledge proof
    pub fn vote(&mut self, vote_yes: bool) -> Result<()> {
        let voter = context::caller();
        let current_block = context::block_height();
        
        // 1. Check voting period
        if current_block < self.start_block || current_block > self.end_block {
            return Err(Error::VotingClosed);
        }
        
        // 2. Check if already voted
        if self.vote_commitments.contains_key(&voter) {
            return Err(Error::AlreadyVoted);
        }
        
        // 3. Update tally (homomorphically or with re-encryption)
        if vote_yes {
            self.yes_votes = increment_encrypted_count(&self.yes_votes)?;
        } else {
            self.no_votes = increment_encrypted_count(&self.no_votes)?;
        }
        
        // 4. Record vote commitment
        let commitment = compute_vote_commitment(voter, vote_yes);
        self.vote_commitments.set(&voter, commitment);
        
        // 5. Emit event (encrypted)
        contract::emit_event(
            "VoteCast",
            &serialize(&VoteEvent { voter, commitment }),
            EventPrivacyLevel::Private {
                authorized_viewers: vec![self.admin],
            },
        )?;
        
        Ok(())
    }
    
    /// Reveal results (admin only, after voting ends)
    pub fn reveal_results(&self) -> Result<(u64, u64)> {
        if context::caller() != self.admin {
            return Err(Error::Unauthorized);
        }
        
        let current_block = context::block_height();
        if current_block <= self.end_block {
            return Err(Error::VotingNotEnded);
        }
        
        // Decrypt tallies
        let yes_count = decrypt_count(&self.yes_votes)?;
        let no_count = decrypt_count(&self.no_votes)?;
        
        Ok((yes_count, no_count))
    }
}

fn encrypt_count(count: u64) -> Vec<u8> {
    storage::encrypt(&count.to_le_bytes()).unwrap()
}

fn decrypt_count(encrypted: &[u8]) -> Result<u64> {
    let plaintext = storage::decrypt(encrypted)?;
    Ok(u64::from_le_bytes(plaintext.try_into().unwrap()))
}

fn increment_encrypted_count(encrypted: &[u8]) -> Result<Vec<u8>> {
    let current = decrypt_count(encrypted)?;
    Ok(encrypt_count(current + 1))
}

fn compute_vote_commitment(voter: Address, vote: bool) -> [u8; 32] {
    shake256(&[voter.as_bytes(), &[vote as u8]].concat())
}
```

---

## 8. Security Considerations

### 8.1 Threat Model

| Threat                     | Mitigation                                             |
| -------------------------- | ------------------------------------------------------ |
| **State leakage via gas**  | Fixed-cost operations, independent of encrypted values |
| **Timing attacks**         | Constant-time cryptographic operations                 |
| **Re-entrancy attacks**    | Call stack tracking, max depth enforcement             |
| **Storage exhaustion**     | Per-contract storage limits (10 MB)                    |
| **Viewing key compromise** | Time-bounded keys, rotation policies                   |
| **Event correlation**      | Encrypted events, selective disclosure                 |

### 8.2 Best Practices

1. **Always encrypt sensitive state**: Use `storage::encrypt()` for all non-public data
2. **Minimize public information**: Only reveal what's absolutely necessary
3. **Use viewing keys properly**: Grant minimum necessary permissions
4. **Emit encrypted events**: Use `EventPrivacyLevel::Private` for sensitive events
5. **Validate cross-contract calls**: Verify caller identity before processing

---

## 9. Future Enhancements

### 9.1 Fully Homomorphic Encryption (FHE)

```rust
// Future: Computation on encrypted data without decryption
pub fn homomorphic_add(
    encrypted_a: &FHECiphertext,
    encrypted_b: &FHECiphertext,
) -> FHECiphertext {
    // Add encrypted values directly
    fhe::add(encrypted_a, encrypted_b)
}
```

### 9.2 Multi-Party Computation (MPC)

```rust
// Future: Joint computation without revealing individual inputs
pub fn mpc_auction(
    bids: Vec<EncryptedBid>,
) -> Result<Winner> {
    // Determine winner without revealing losing bids
    mpc::compute_max(bids)
}
```

### 9.3 Zero-Knowledge Virtual Machine

```rust
// Future: Entire execution hidden with ZK proof
pub fn zkvm_execute(
    program: &[u8],
    private_inputs: &[u8],
) -> ZKProof {
    // Execute program, generate proof, hide execution
    zkvm::prove_execution(program, private_inputs)
}
```

---

## 10. Conclusion

Ecliptica's Contract Privacy Model enables **confidential smart contracts** with:

✓ **Encrypted state** - All storage encrypted by default  
✓ **Private contract calls** - ML-KEM encrypted parameters and returns  
✓ **Selective disclosure** - Viewing keys for granular access  
✓ **Encrypted events** - Privacy-preserving audit logs  
✓ **Deterministic gas metering** - No information leakage through costs  

**Privacy Guarantee**: Contract execution reveals only proof of validity, not execution details.

---

**Document ID**: `ECLIPT-CONTRACT-PRIVACY-001`  
**Version**: 1.0  
**Status**: Complete Draft  
**Last Updated**: October 2025  
**Maintainer**: Ecliptica Protocol Engineering