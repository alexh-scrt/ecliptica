# üåÖ **Ecliptica Bootstrap & Genesis Specification**

### *Network Initialization & Launch Protocol for Post-Quantum Privacy Blockchain*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-GENESIS-001`  
**Depends On:** `ECLIPT-STATE-001`, `ECLIPT-TX-001`, `ECLIPT-XSHARD-001`

---

## 1. Executive Summary

This specification defines the complete procedure for launching Ecliptica networks, from genesis block creation to mainnet migration. The protocol ensures:

- **Deterministic Genesis**: Reproducible genesis state across all validators
- **Secure Validator Selection**: Post-quantum cryptographic validator enrollment
- **Fair Token Distribution**: Transparent premine allocation with verifiable lockups
- **Network Isolation**: Chain ID-based replay protection across networks
- **Migration Path**: Testnet ‚Üí Mainnet state migration with safety guarantees

**Network Lifecycle:**
```
DevNet ‚Üí TestNet ‚Üí MainNet Beta ‚Üí MainNet
  ‚Üì         ‚Üì           ‚Üì            ‚Üì
Genesis  Genesis    Genesis      Genesis
 (local) (public)   (public)   (canonical)
```

---

## 2. Chain Identity & Network Versioning

### 2.1 Chain ID Format

**Structure:**
```rust
struct ChainId {
    network_type: u8,      // 0=DevNet, 1=TestNet, 2=MainNet
    version_major: u8,     // Breaking changes
    version_minor: u8,     // Compatible upgrades
    instance_id: u8,       // Multiple networks of same type
    genesis_hash: [u8; 4], // First 4 bytes of genesis block hash
}

impl ChainId {
    fn to_u64(&self) -> u64 {
        ((self.network_type as u64) << 56)
            | ((self.version_major as u64) << 48)
            | ((self.version_minor as u64) << 40)
            | ((self.instance_id as u64) << 32)
            | u32::from_be_bytes(self.genesis_hash) as u64
    }
    
    fn from_string(s: &str) -> Self {
        // Format: "ecliptica-mainnet-1.0-0"
        // or: "ECLIPT-0x010001000A1B2C3D"
        ...
    }
}
```

**Examples:**
```
DevNet Alpha:    0x00_01_00_00_DEADBEEF ‚Üí "ecliptica-devnet-1.0-0"
TestNet Delta:   0x01_01_00_00_CAFEBABE ‚Üí "ecliptica-testnet-1.0-0"
MainNet Genesis: 0x02_01_00_00_12345678 ‚Üí "ecliptica-mainnet-1.0-0"
```

**Properties:**
- Globally unique (collision-resistant via genesis hash)
- Human-readable string format
- Programmatically comparable
- Embedded in all transactions (replay protection)

### 2.2 Network Registry

```rust
const ECLIPTICA_NETWORKS: &[NetworkConfig] = &[
    NetworkConfig {
        chain_id: 0x02_01_00_00_00000000, // MainNet (genesis hash TBD)
        name: "Ecliptica MainNet",
        network_type: NetworkType::MainNet,
        genesis_time: 1704067200,    // 2025-01-01 00:00:00 UTC
        beacon_rpc: "https://beacon.ecliptica.network",
        shard_rpcs: [...],
    },
    NetworkConfig {
        chain_id: 0x01_01_00_00_00000000, // TestNet
        name: "Ecliptica TestNet Delta",
        network_type: NetworkType::TestNet,
        genesis_time: 1702857600,    // 2024-12-18 00:00:00 UTC
        beacon_rpc: "https://testnet-beacon.ecliptica.network",
        shard_rpcs: [...],
    },
];
```

### 2.3 Version Upgrade Protocol

**Backward Compatibility Matrix:**

| Node Version | v1.0 Genesis | v1.1 Genesis | v2.0 Genesis |
| ------------ | ------------ | ------------ | ------------ |
| v1.0         | ‚úÖ            | ‚ùå            | ‚ùå            |
| v1.1         | ‚úÖ            | ‚úÖ            | ‚ùå            |
| v2.0         | ‚ùå            | ‚ùå            | ‚úÖ            |

**Upgrade Signaling:**
```rust
struct ProtocolUpgrade {
    activation_height: u64,
    new_version: u16,              // e.g., 0x0200 for v2.0
    required_features: Vec<String>, // ["new_opcode", "increased_gas"]
    activation_threshold: f64,      // e.g., 0.80 (80% of validators)
}
```

---

## 3. Genesis Block Structure

### 3.1 Genesis Block Format

```rust
struct GenesisBlock {
    // === HEADER ===
    version: u16,                  // Protocol version (0x0001)
    chain_id: u64,                 // Network identifier
    genesis_time: u64,             // Unix timestamp (seconds)
    
    // === STATE ===
    genesis_state: GenesisState,
    
    // === VALIDATOR SET ===
    initial_validators: Vec<ValidatorEntry>,
    
    // === CONFIGURATION ===
    consensus_params: ConsensusParams,
    network_params: NetworkParams,
    economic_params: EconomicParams,
    
    // === METADATA ===
    app_hash: [u8; 32],            // Application state hash
    state_root: [u8; 32],          // Merkle root of genesis state
    
    // === COMMITMENT ===
    genesis_hash: [u8; 32],        // SHAKE-256(entire genesis block)
}

impl GenesisBlock {
    fn compute_genesis_hash(&self) -> [u8; 32] {
        let mut hasher = Shake256::default();
        hasher.update(b"ECLIPTICA_GENESIS_v1");
        hasher.update(&self.serialize_canonical());
        
        let mut output = [0u8; 32];
        hasher.finalize_xof_into(&mut output);
        output
    }
    
    fn validate(&self) -> Result<()> {
        // 1. Verify genesis hash
        let computed_hash = self.compute_genesis_hash();
        if computed_hash != self.genesis_hash {
            return Err(Error::GenesisHashMismatch);
        }
        
        // 2. Verify state root
        let computed_root = self.genesis_state.compute_state_root();
        if computed_root != self.state_root {
            return Err(Error::StateRootMismatch);
        }
        
        // 3. Validate total supply
        self.genesis_state.validate_total_supply()?;
        
        // 4. Validate validator set
        self.validate_validator_set()?;
        
        // 5. Validate configuration
        self.consensus_params.validate()?;
        self.economic_params.validate()?;
        
        Ok(())
    }
}
```

### 3.2 Genesis State

```rust
struct GenesisState {
    // === TOKEN ALLOCATIONS ===
    accounts: Vec<GenesisAccount>,
    
    // === TOTAL SUPPLY ===
    total_supply: u64,             // Must equal sum of all accounts
    
    // === SMART CONTRACTS ===
    contracts: Vec<GenesisContract>,
    
    // === SHARD STATE ===
    shard_states: Vec<ShardGenesisState>,
    
    // === BEACON STATE ===
    beacon_state: BeaconGenesisState,
}

struct GenesisAccount {
    address: Address,              // 20-byte account address
    balance: u64,                  // Initial balance (plaintext)
    nonce: u64,                    // Initial nonce (usually 0)
    
    // Lockup schedule (optional)
    lockup: Option<LockupSchedule>,
    
    // Account type
    account_type: AccountType,
}

enum AccountType {
    User,                          // Regular user account
    Treasury,                      // Protocol treasury
    Validator,                     // Validator operator
    Contract,                      // Smart contract
}

struct LockupSchedule {
    total_locked: u64,             // Total locked amount
    cliff_duration: u64,           // Blocks until first unlock
    vesting_duration: u64,         // Total vesting period
    release_intervals: u64,        // Blocks between releases
}

impl LockupSchedule {
    fn unlocked_at_height(&self, current_height: u64, genesis_height: u64) -> u64 {
        let elapsed = current_height.saturating_sub(genesis_height);
        
        if elapsed < self.cliff_duration {
            return 0;
        }
        
        let vesting_elapsed = elapsed - self.cliff_duration;
        
        if vesting_elapsed >= self.vesting_duration {
            return self.total_locked;
        }
        
        // Linear vesting after cliff
        (self.total_locked * vesting_elapsed) / self.vesting_duration
    }
}
```

### 3.3 Shard Genesis State

```rust
struct ShardGenesisState {
    shard_id: u8,
    
    // Initial state roots
    utxo_set_root: [u8; 32],       // Empty SMT root
    account_trie_root: [u8; 32],   // Contains genesis accounts
    nullifier_set_root: [u8; 32],  // Empty
    
    // Initial accounts in this shard
    accounts: Vec<GenesisAccount>,
    
    // Initial validator set for this shard
    validators: Vec<Address>,
}

impl ShardGenesisState {
    fn compute_state_root(&self) -> [u8; 32] {
        let mut hasher = Shake256::default();
        hasher.update(&self.utxo_set_root);
        hasher.update(&self.account_trie_root);
        hasher.update(&self.nullifier_set_root);
        
        let mut output = [0u8; 32];
        hasher.finalize_xof_into(&mut output);
        output
    }
}
```

### 3.4 Beacon Genesis State

```rust
struct BeaconGenesisState {
    // Validator set
    validators: Vec<BeaconValidator>,
    total_stake: u64,
    
    // Shard registry
    shard_roots: Vec<[u8; 32]>,    // Initial state root for each shard
    
    // Cross-shard state
    receipt_registry: HashMap<[u8; 32], ReceiptEntry>,  // Empty at genesis
    
    // Governance
    governance_params: GovernanceParams,
}

struct BeaconValidator {
    address: Address,
    pubkey: [u8; 1952],            // ML-DSA (Dilithium-3) public key
    stake: u64,
    commission: u16,               // Basis points (e.g., 500 = 5%)
}
```

---

## 4. Genesis Configuration Parameters

### 4.1 Consensus Parameters

```rust
struct ConsensusParams {
    // Block timing
    block_interval: Duration,      // Target: 500 ms
    epoch_length: u64,             // Blocks per epoch: 1024
    
    // BFT parameters
    byzantine_tolerance: f64,      // f/N ratio: 0.33
    finality_depth: u64,           // Confirmations: 64
    
    // Validator set
    min_validators_per_shard: u32, // Minimum: 32
    max_validators_per_shard: u32, // Maximum: 256
    min_validator_stake: u64,      // Minimum stake: 100,000 ECLIPT
    
    // Timeouts
    propose_timeout: Duration,     // 2 seconds
    prevote_timeout: Duration,     // 1 second
    precommit_timeout: Duration,   // 1 second
    commit_timeout: Duration,      // 500 ms
}

impl Default for ConsensusParams {
    fn default() -> Self {
        Self {
            block_interval: Duration::from_millis(500),
            epoch_length: 1024,
            byzantine_tolerance: 0.33,
            finality_depth: 64,
            min_validators_per_shard: 32,
            max_validators_per_shard: 256,
            min_validator_stake: 100_000 * ECLIPT_PER_COIN,
            propose_timeout: Duration::from_secs(2),
            prevote_timeout: Duration::from_secs(1),
            precommit_timeout: Duration::from_secs(1),
            commit_timeout: Duration::from_millis(500),
        }
    }
}
```

### 4.2 Network Parameters

```rust
struct NetworkParams {
    // Sharding
    num_shards: u8,                // Initial: 8
    
    // Cross-shard
    cross_shard_timeout: u64,      // Blocks: 512
    max_concurrent_xshard: u32,    // Per shard: 10,000
    
    // P2P
    max_peers: u32,                // Per node: 128
    target_peers: u32,             // Target: 64
    peer_exchange_interval: Duration, // 60 seconds
    
    // RPC
    max_rpc_connections: u32,      // 1000
    rpc_rate_limit: u32,           // Requests/sec: 100
    
    // Mempool
    mempool_size: usize,           // Max txs: 100,000
    mempool_ttl: Duration,         // TTL: 5 minutes
}
```

### 4.3 Economic Parameters

```rust
struct EconomicParams {
    // Token supply
    total_supply: u64,             // Genesis: 1,000,000,000 ECLIPT
    
    // Inflation schedule
    initial_inflation: f64,        // 3.5%
    tail_inflation: f64,           // 0.5%
    inflation_decay: f64,          // k = 0.12
    
    // Fees
    base_fee_initial: u64,         // 1000 leptons
    base_fee_max_change: f64,      // 12.5% per block
    fee_burn_ratio: f64,           // 30-70%
    
    // Gas
    block_gas_limit: u64,          // Per shard: 100M gas
    min_gas_price: u64,            // 1 lepton
    
    // Staking
    unbonding_period: u64,         // Blocks: 100,800 (~14 days)
    min_commission: u16,           // 0 basis points (0%)
    max_commission: u16,           // 1000 basis points (10%)
    
    // Slashing
    double_sign_slash: f64,        // 5%
    downtime_slash: f64,           // 0.1%
    downtime_jail: u64,            // Blocks: 1000
}
```

---

## 5. Initial Validator Selection

### 5.1 Validator Enrollment Process

**Phase 1: Pre-Genesis Registration (4 weeks before launch)**

```rust
struct ValidatorRegistration {
    // Identity
    operator_address: Address,
    
    // Cryptographic keys
    consensus_pubkey: [u8; 1952],  // ML-DSA (Dilithium-3)
    network_pubkey: [u8; 32],      // ed25519 (libp2p compatibility)
    
    // Network info
    peer_id: PeerId,
    listen_addrs: Vec<Multiaddr>,
    external_ip: IpAddr,
    
    // Hardware attestation
    cpu_cores: u32,
    memory_gb: u32,
    disk_gb: u32,
    bandwidth_mbps: u32,
    
    // Stake commitment
    self_stake: u64,               // Minimum: 100,000 ECLIPT
    
    // Metadata
    moniker: String,               // Display name
    website: String,
    contact_email: String,
    
    // Signature (over all fields)
    signature: DilithiumSignature,
}

fn validate_registration(reg: &ValidatorRegistration) -> Result<()> {
    // 1. Verify signature
    verify_dilithium_signature(
        &reg.signature,
        &reg.serialize_for_signing(),
        &reg.consensus_pubkey,
    )?;
    
    // 2. Verify minimum stake
    if reg.self_stake < MIN_VALIDATOR_STAKE {
        return Err(Error::InsufficientStake);
    }
    
    // 3. Verify hardware requirements
    if reg.cpu_cores < 16 || reg.memory_gb < 32 || reg.disk_gb < 1024 {
        return Err(Error::InsufficientHardware);
    }
    
    // 4. Verify network connectivity
    verify_network_reachability(&reg.listen_addrs)?;
    
    // 5. Verify unique keys (no duplicates)
    verify_unique_pubkey(&reg.consensus_pubkey)?;
    
    Ok(())
}
```

**Phase 2: Validator Sorting & Selection**

```rust
fn select_genesis_validators(
    registrations: Vec<ValidatorRegistration>,
    target_count: usize,
) -> Vec<ValidatorEntry> {
    // Sort by multiple criteria
    let mut scored: Vec<_> = registrations.into_iter()
        .map(|reg| {
            let score = compute_validator_score(&reg);
            (score, reg)
        })
        .collect();
    
    // Sort descending by score
    scored.sort_by(|(s1, _), (s2, _)| s2.partial_cmp(s1).unwrap());
    
    // Take top N validators
    scored.into_iter()
        .take(target_count)
        .map(|(_, reg)| validator_entry_from_registration(reg))
        .collect()
}

fn compute_validator_score(reg: &ValidatorRegistration) -> f64 {
    let mut score = 0.0;
    
    // Stake (50% weight)
    score += (reg.self_stake as f64 / 1_000_000.0) * 0.5;
    
    // Hardware (25% weight)
    let hw_score = (reg.cpu_cores as f64 / 64.0).min(1.0)
        + (reg.memory_gb as f64 / 128.0).min(1.0)
        + (reg.bandwidth_mbps as f64 / 1000.0).min(1.0);
    score += (hw_score / 3.0) * 0.25;
    
    // Geographic diversity (15% weight)
    score += geographic_diversity_bonus(&reg.external_ip) * 0.15;
    
    // Reputation (10% weight) - from testnet if available
    score += testnet_reputation_score(&reg.operator_address) * 0.10;
    
    score
}
```

**Phase 3: Shard Assignment**

```rust
fn assign_validators_to_shards(
    validators: Vec<ValidatorEntry>,
    num_shards: u8,
) -> Vec<ShardValidatorSet> {
    let validators_per_shard = validators.len() / num_shards as usize;
    
    // Use deterministic shuffling based on genesis hash
    let mut rng = ChaCha20Rng::from_seed(genesis_hash_seed());
    let mut shuffled = validators;
    shuffled.shuffle(&mut rng);
    
    // Assign to shards in round-robin
    let mut shard_sets = vec![Vec::new(); num_shards as usize];
    for (i, validator) in shuffled.into_iter().enumerate() {
        let shard_id = (i % num_shards as usize) as u8;
        shard_sets[shard_id as usize].push(validator);
    }
    
    shard_sets.into_iter()
        .enumerate()
        .map(|(shard_id, validators)| ShardValidatorSet {
            shard_id: shard_id as u8,
            validators,
        })
        .collect()
}
```

### 5.2 Validator Entry Format

```rust
struct ValidatorEntry {
    // Identity
    operator_address: Address,
    
    // Consensus key
    consensus_pubkey: [u8; 1952],  // ML-DSA public key
    
    // Stake
    self_stake: u64,
    delegated_stake: u64,          // Initially 0
    total_stake: u64,              // self_stake + delegated_stake
    
    // Commission
    commission_rate: u16,          // Basis points
    
    // Network
    peer_id: PeerId,
    listen_addrs: Vec<Multiaddr>,
    
    // Status
    is_active: bool,               // Initially true
    jailed: bool,                  // Initially false
    
    // Metadata
    moniker: String,
}
```

---

## 6. Premine Distribution Mechanism

### 6.1 Genesis Allocation

```rust
struct GenesisPremineAllocation {
    // Total supply: 1,000,000,000 ECLIPT
    total_supply: u64,
    
    // Breakdown
    allocations: Vec<Allocation>,
}

struct Allocation {
    category: AllocationCategory,
    amount: u64,
    percentage: f64,
    lockup: Option<LockupSchedule>,
    recipients: Vec<Recipient>,
}

enum AllocationCategory {
    PublicCommunity,     // Airdrop + faucet
    Ecosystem,           // Grants + developer incentives
    CoreContributors,    // Team
    StrategicPartners,   // Investors
    ValidatorBootstrap,  // Initial validator stakes
    Treasury,            // Protocol treasury
    LiquidityMining,     // DEX liquidity incentives
}

struct Recipient {
    address: Address,
    amount: u64,
    lockup: Option<LockupSchedule>,
}
```

**Example Allocation (From Tokenomics Doc):**

```rust
const GENESIS_ALLOCATIONS: GenesisPremineAllocation = GenesisPremineAllocation {
    total_supply: 1_000_000_000 * ECLIPT_PER_COIN,
    allocations: vec![
        Allocation {
            category: AllocationCategory::PublicCommunity,
            amount: 100_000_000 * ECLIPT_PER_COIN,  // 10%
            percentage: 0.10,
            lockup: None,  // Immediately liquid
            recipients: load_from_file("allocations/community.json"),
        },
        Allocation {
            category: AllocationCategory::Ecosystem,
            amount: 150_000_000 * ECLIPT_PER_COIN,  // 15%
            percentage: 0.15,
            lockup: Some(LockupSchedule {
                total_locked: 150_000_000 * ECLIPT_PER_COIN,
                cliff_duration: 30_000,      // ~6 months
                vesting_duration: 180_000,   // ~3 years
                release_intervals: 5_000,    // ~monthly
            }),
            recipients: load_from_file("allocations/ecosystem.json"),
        },
        Allocation {
            category: AllocationCategory::CoreContributors,
            amount: 150_000_000 * ECLIPT_PER_COIN,  // 15%
            percentage: 0.15,
            lockup: Some(LockupSchedule {
                total_locked: 150_000_000 * ECLIPT_PER_COIN,
                cliff_duration: 60_000,      // ~1 year
                vesting_duration: 180_000,   // ~3 years
                release_intervals: 5_000,
            }),
            recipients: load_from_file("allocations/team.json"),
        },
        Allocation {
            category: AllocationCategory::StrategicPartners,
            amount: 100_000_000 * ECLIPT_PER_COIN,  // 10%
            percentage: 0.10,
            lockup: Some(LockupSchedule {
                total_locked: 100_000_000 * ECLIPT_PER_COIN,
                cliff_duration: 30_000,
                vesting_duration: 120_000,   // ~2 years
                release_intervals: 5_000,
            }),
            recipients: load_from_file("allocations/investors.json"),
        },
        Allocation {
            category: AllocationCategory::ValidatorBootstrap,
            amount: 50_000_000 * ECLIPT_PER_COIN,   // 5%
            percentage: 0.05,
            lockup: Some(LockupSchedule {
                total_locked: 50_000_000 * ECLIPT_PER_COIN,
                cliff_duration: 0,
                vesting_duration: 60_000,    // ~1 year
                release_intervals: 5_000,
            }),
            recipients: derive_from_validators(),
        },
        Allocation {
            category: AllocationCategory::Treasury,
            amount: 150_000_000 * ECLIPT_PER_COIN,  // 15%
            percentage: 0.15,
            lockup: None,  // Controlled by governance
            recipients: vec![Recipient {
                address: TREASURY_ADDRESS,
                amount: 150_000_000 * ECLIPT_PER_COIN,
                lockup: None,
            }],
        },
        Allocation {
            category: AllocationCategory::LiquidityMining,
            amount: 50_000_000 * ECLIPT_PER_COIN,   // 5%
            percentage: 0.05,
            lockup: None,
            recipients: vec![Recipient {
                address: LIQUIDITY_PROGRAM_ADDRESS,
                amount: 50_000_000 * ECLIPT_PER_COIN,
                lockup: None,
            }],
        },
    ],
};
```

### 6.2 Vesting Smart Contract

```rust
/// On-chain vesting contract (deployed at genesis)
struct VestingContract {
    beneficiary: Address,
    total_allocation: u64,
    claimed: u64,
    lockup_schedule: LockupSchedule,
    genesis_height: u64,
}

impl VestingContract {
    fn claimable_amount(&self, current_height: u64) -> u64 {
        let unlocked = self.lockup_schedule.unlocked_at_height(
            current_height,
            self.genesis_height,
        );
        unlocked.saturating_sub(self.claimed)
    }
    
    fn claim(&mut self, current_height: u64) -> Result<u64> {
        let claimable = self.claimable_amount(current_height);
        
        if claimable == 0 {
            return Err(Error::NothingToClaim);
        }
        
        self.claimed += claimable;
        
        // Transfer to beneficiary
        transfer(VESTING_CONTRACT_ADDRESS, self.beneficiary, claimable)?;
        
        Ok(claimable)
    }
}
```

### 6.3 Allocation Verification

```rust
fn verify_genesis_allocations(state: &GenesisState) -> Result<()> {
    // 1. Verify total supply
    let total_allocated: u64 = state.accounts.iter()
        .map(|acc| acc.balance)
        .sum();
    
    if total_allocated != GENESIS_TOTAL_SUPPLY {
        return Err(Error::SupplyMismatch {
            expected: GENESIS_TOTAL_SUPPLY,
            actual: total_allocated,
        });
    }
    
    // 2. Verify no duplicates
    let mut seen_addresses = HashSet::new();
    for account in &state.accounts {
        if !seen_addresses.insert(account.address) {
            return Err(Error::DuplicateAddress(account.address));
        }
    }
    
    // 3. Verify lockup contracts deployed
    for account in &state.accounts {
        if let Some(lockup) = &account.lockup {
            verify_lockup_contract_exists(account.address, lockup)?;
        }
    }
    
    // 4. Verify allocation percentages match spec
    verify_allocation_percentages(&state.accounts)?;
    
    Ok(())
}
```

---

## 7. Genesis Generation Procedure

### 7.1 Genesis Ceremony Workflow

**Timeline: 4 weeks before mainnet launch**

```
Week -4: Validator registration opens
Week -3: Registration closes, validator selection
Week -2: Genesis file generation + verification
Week -1: Network coordination + dry runs
Day 0:  Genesis block mined, mainnet live
```

**Step-by-Step Process:**

```rust
// 1. Collect validator registrations
fn stage1_collect_registrations() -> Vec<ValidatorRegistration> {
    // Read from public registration endpoint
    let registrations = http_get("https://genesis.ecliptica.network/validators.json")?;
    
    // Validate each registration
    registrations.into_iter()
        .filter_map(|reg| validate_registration(&reg).ok().map(|_| reg))
        .collect()
}

// 2. Generate genesis state
fn stage2_generate_genesis() -> GenesisBlock {
    // Load allocations
    let allocations = load_genesis_allocations()?;
    
    // Select validators
    let validators = select_genesis_validators(
        stage1_collect_registrations(),
        TARGET_GENESIS_VALIDATORS,
    )?;
    
    // Assign to shards
    let shard_validators = assign_validators_to_shards(
        validators.clone(),
        NUM_GENESIS_SHARDS,
    )?;
    
    // Create genesis state
    let genesis_state = GenesisState {
        accounts: allocations.to_accounts(),
        total_supply: GENESIS_TOTAL_SUPPLY,
        contracts: deploy_genesis_contracts(),
        shard_states: create_shard_genesis_states(&shard_validators, &allocations),
        beacon_state: create_beacon_genesis_state(&validators),
    };
    
    // Compute state root
    let state_root = genesis_state.compute_state_root();
    
    // Create genesis block
    let mut genesis = GenesisBlock {
        version: PROTOCOL_VERSION,
        chain_id: CHAIN_ID_MAINNET,
        genesis_time: GENESIS_TIMESTAMP,
        genesis_state,
        initial_validators: validators,
        consensus_params: ConsensusParams::default(),
        network_params: NetworkParams::default(),
        economic_params: EconomicParams::default(),
        app_hash: [0u8; 32],  // Computed below
        state_root,
        genesis_hash: [0u8; 32],  // Computed last
    };
    
    genesis.app_hash = compute_app_hash(&genesis);
    genesis.genesis_hash = genesis.compute_genesis_hash();
    
    genesis
}

// 3. Distribute genesis file
fn stage3_distribute_genesis(genesis: GenesisBlock) {
    // Serialize to JSON
    let genesis_json = serde_json::to_string_pretty(&genesis).unwrap();
    
    // Publish to multiple endpoints
    publish_to_ipfs(&genesis_json);
    publish_to_github(&genesis_json);
    publish_to_https(&genesis_json);
    
    // Generate checksums
    let sha256 = sha256_hash(&genesis_json);
    let sha3_256 = sha3_256_hash(&genesis_json);
    
    println!("Genesis file published:");
    println!("  IPFS: {}", ipfs_cid);
    println!("  GitHub: https://github.com/ecliptica/genesis/mainnet.json");
    println!("  SHA-256: {}", hex::encode(sha256));
    println!("  SHA3-256: {}", hex::encode(sha3_256));
}

// 4. Validator verification
fn stage4_validator_verification() {
    // Each validator independently:
    // 1. Downloads genesis.json from multiple sources
    // 2. Verifies checksums match
    // 3. Validates genesis structure
    // 4. Signs genesis hash with their validator key
    // 5. Submits signature to coordination server
    
    let genesis = download_and_verify_genesis()?;
    genesis.validate()?;
    
    let signature = sign_genesis_hash(&genesis.genesis_hash, &validator_sk);
    
    submit_genesis_signature(validator_address, signature)?;
}

// 5. Launch coordination
fn stage5_launch_coordination() {
    // Wait for quorum of signatures (‚â•2/3 validators)
    wait_for_validator_quorum()?;
    
    // Set synchronized start time
    let launch_time = SystemTime::UNIX_EPOCH + Duration::from_secs(GENESIS_TIMESTAMP);
    
    println!("All systems ready. Launch in T-minus:");
    countdown_to(launch_time);
    
    // Start network at genesis_time
    start_node(genesis)?;
}
```

### 7.2 Genesis File Format (JSON)

```json
{
  "version": "1.0",
  "chain_id": "ecliptica-mainnet-1.0-0",
  "chain_id_numeric": "0x0201000012345678",
  "genesis_time": "2025-01-01T00:00:00Z",
  "genesis_hash": "0x1234567890abcdef...",
  "state_root": "0xabcdef1234567890...",
  "app_hash": "0x9876543210fedcba...",
  
  "initial_validators": [
    {
      "address": "ecliptica1abc...",
      "consensus_pubkey": "0x1234...",
      "self_stake": "100000000000000",
      "commission_rate": 500,
      "moniker": "Validator Alpha",
      "peer_id": "12D3KooW...",
      "listen_addrs": ["/ip4/1.2.3.4/tcp/26656"]
    },
    ...
  ],
  
  "genesis_state": {
    "accounts": [
      {
        "address": "ecliptica1xyz...",
        "balance": "10000000000000",
        "nonce": 0,
        "account_type": "User",
        "lockup": null
      },
      {
        "address": "ecliptica1treasury...",
        "balance": "150000000000000",
        "nonce": 0,
        "account_type": "Treasury",
        "lockup": null
      },
      ...
    ],
    "total_supply": "1000000000000000",
    "shard_states": [...],
    "beacon_state": {...}
  },
  
  "consensus_params": {
    "block_interval_ms": 500,
    "epoch_length": 1024,
    "finality_depth": 64,
    "min_validators_per_shard": 32,
    "max_validators_per_shard": 256
  },
  
  "network_params": {
    "num_shards": 8,
    "cross_shard_timeout": 512,
    "max_peers": 128
  },
  
  "economic_params": {
    "initial_inflation": 0.035,
    "tail_inflation": 0.005,
    "base_fee_initial": 1000,
    "block_gas_limit": 100000000
  }
}
```

---

## 8. Testnet to Mainnet Migration

### 8.1 Migration Strategy

**Option A: Clean Slate (Recommended)**
- New genesis block
- New chain ID
- No state carryover
- Airdrop to testnet participants (incentive)

**Option B: State Snapshot (Advanced)**
- Export testnet state at specific height
- Filter and transform state
- Import into mainnet genesis
- Maintain validator continuity

### 8.2 Testnet Snapshot Export

```rust
fn export_testnet_snapshot(height: u64) -> TestnetSnapshot {
    let state = load_state_at_height(height)?;
    
    TestnetSnapshot {
        export_height: height,
        export_time: SystemTime::now(),
        
        // Account balances (filtered)
        accounts: state.accounts.into_iter()
            .filter(|acc| acc.balance >= MIN_MIGRATION_BALANCE)
            .map(|acc| MigrationAccount {
                testnet_address: acc.address,
                mainnet_address: derive_mainnet_address(acc.address),
                balance: acc.balance,
                nonce: 0,  // Reset nonces
            })
            .collect(),
        
        // Validator set (from performance data)
        validators: select_mainnet_validators_from_testnet(),
        
        // Contracts (manually reviewed)
        contracts: approved_contracts_for_migration(),
    }
}

fn derive_mainnet_address(testnet_addr: Address) -> Address {
    // Deterministic derivation prevents confusion
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPT_TESTNET_TO_MAINNET_v1");
    hasher.update(&testnet_addr);
    hasher.update(&MAINNET_CHAIN_ID.to_le_bytes());
    
    let mut output = [0u8; 20];
    hasher.finalize_xof_into(&mut output);
    output
}
```

### 8.3 Migration Incentives

```rust
struct MigrationBonus {
    testnet_address: Address,
    testnet_balance: u64,
    mainnet_address: Address,
    mainnet_balance: u64,
    bonus_amount: u64,
    bonus_reason: BonusReason,
}

enum BonusReason {
    BugReporter,           // Found critical bugs
    ActiveValidator,       // >90% uptime on testnet
    TopTransactor,         // High transaction volume
    CommunityContributor,  // Documentation, support
}

fn compute_migration_bonuses(
    testnet_data: &TestnetSnapshot,
) -> Vec<MigrationBonus> {
    let mut bonuses = Vec::new();
    
    // Bug reporters: 10,000 ECLIPT each
    for reporter in get_bug_reporters() {
        bonuses.push(MigrationBonus {
            testnet_address: reporter.address,
            testnet_balance: 0,
            mainnet_address: derive_mainnet_address(reporter.address),
            mainnet_balance: 0,
            bonus_amount: 10_000 * ECLIPT_PER_COIN,
            bonus_reason: BonusReason::BugReporter,
        });
    }
    
    // Active validators: 50,000 ECLIPT
    for validator in get_active_validators(testnet_data) {
        bonuses.push(MigrationBonus {
            testnet_address: validator.address,
            testnet_balance: validator.stake,
            mainnet_address: derive_mainnet_address(validator.address),
            mainnet_balance: validator.stake,
            bonus_amount: 50_000 * ECLIPT_PER_COIN,
            bonus_reason: BonusReason::ActiveValidator,
        });
    }
    
    bonuses
}
```

---

## 9. Network Coordination

### 9.1 Bootstrap Nodes

**DNS Seed Nodes:**
```
mainnet-seed-1.ecliptica.network  ‚Üí 1.2.3.4
mainnet-seed-2.ecliptica.network  ‚Üí 5.6.7.8
mainnet-seed-3.ecliptica.network  ‚Üí 9.10.11.12
```

**Embedded Seed Peers (in node binary):**

```rust
const MAINNET_BOOTSTRAP_PEERS: &[&str] = &[
    "/dns4/mainnet-seed-1.ecliptica.network/tcp/26656/p2p/12D3KooWAbc...",
    "/dns4/mainnet-seed-2.ecliptica.network/tcp/26656/p2p/12D3KooWDef...",
    "/dns4/mainnet-seed-3.ecliptica.network/tcp/26656/p2p/12D3KooWGhi...",
    "/ip4/1.2.3.4/tcp/26656/p2p/12D3KooWJkl...",
    "/ip4/5.6.7.8/tcp/26656/p2p/12D3KooWMno...",
];

const TESTNET_BOOTSTRAP_PEERS: &[&str] = &[
    "/dns4/testnet-seed-1.ecliptica.network/tcp/26656/p2p/12D3KooWPqr...",
    ...
];
```

### 9.2 Launch Checklist

```rust
struct LaunchReadinessChecklist {
    // Pre-launch (T-1 week)
    genesis_file_published: bool,
    validator_signatures_collected: bool,  // ‚â•2/3
    bootstrap_nodes_online: bool,
    monitoring_infrastructure_ready: bool,
    
    // Launch day (T-0)
    validator_quorum_online: bool,         // ‚â•2/3
    p2p_connectivity_verified: bool,
    rpc_endpoints_accessible: bool,
    explorer_syncing: bool,
    
    // Post-launch (T+1 hour)
    first_epoch_completed: bool,
    cross_shard_transactions_working: bool,
    no_critical_errors: bool,
    block_time_stable: bool,
}

fn verify_launch_readiness() -> Result<()> {
    let checklist = LaunchReadinessChecklist {
        genesis_file_published: check_genesis_availability()?,
        validator_signatures_collected: check_validator_signatures()?,
        bootstrap_nodes_online: check_bootstrap_connectivity()?,
        monitoring_infrastructure_ready: check_monitoring()?,
        validator_quorum_online: check_validator_quorum()?,
        p2p_connectivity_verified: check_p2p_mesh()?,
        rpc_endpoints_accessible: check_rpc_health()?,
        explorer_syncing: check_explorer()?,
        first_epoch_completed: false,  // Will be checked post-launch
        cross_shard_transactions_working: false,
        no_critical_errors: false,
        block_time_stable: false,
    };
    
    if !checklist.all_pre_launch_checks_passed() {
        return Err(Error::NotReadyForLaunch(checklist));
    }
    
    Ok(())
}
```

---

## 10. Emergency Procedures

### 10.1 Pre-Launch Abort

```rust
fn abort_genesis_launch(reason: &str) -> Result<()> {
    println!("üö® GENESIS LAUNCH ABORTED: {}", reason);
    
    // 1. Broadcast abort signal to all validators
    broadcast_abort_signal(reason)?;
    
    // 2. Halt all nodes
    shutdown_all_nodes()?;
    
    // 3. Generate incident report
    generate_incident_report(reason)?;
    
    // 4. Schedule new genesis time
    let new_genesis_time = SystemTime::now() + Duration::from_secs(86400); // +24 hours
    println!("New genesis scheduled for: {:?}", new_genesis_time);
    
    Ok(())
}
```

**Abort Triggers:**
- Less than 2/3 validators online at genesis time
- Critical bug discovered in node software
- Genesis file corruption detected
- Network infrastructure failure
- Security incident

### 10.2 Post-Launch Emergency Halt

```rust
fn emergency_chain_halt() -> Result<()> {
    // Requires ‚â•2/3 validator consensus
    let halt_proposal = EmergencyHaltProposal {
        reason: "Critical vulnerability discovered",
        proposer: validator_address,
        halt_height: current_height + 10,  // 10 block grace period
    };
    
    // Validators vote on halt
    broadcast_halt_proposal(&halt_proposal)?;
    
    if collect_halt_votes(&halt_proposal) >= (2 * total_validators / 3) {
        // Halt consensus at specified height
        schedule_consensus_halt(halt_proposal.halt_height)?;
        
        // Generate state snapshot
        export_emergency_snapshot()?;
        
        // Notify community
        send_emergency_notification("Chain halted for emergency maintenance")?;
    }
    
    Ok(())
}
```

### 10.3 Chain Restart Procedure

```rust
fn restart_chain_from_snapshot(snapshot_height: u64) -> Result<()> {
    // 1. Load emergency snapshot
    let snapshot = load_snapshot(snapshot_height)?;
    
    // 2. Apply hotfix
    let patched_genesis = apply_hotfix_to_snapshot(snapshot)?;
    
    // 3. Increment chain version
    patched_genesis.version += 1;
    patched_genesis.chain_id = compute_new_chain_id(patched_genesis.version);
    
    // 4. Redistribute to validators
    stage3_distribute_genesis(patched_genesis)?;
    
    // 5. Coordinate restart
    let restart_time = SystemTime::now() + Duration::from_secs(3600); // +1 hour
    coordinate_synchronized_restart(restart_time)?;
    
    Ok(())
}
```

---

## 11. Monitoring & Telemetry

### 11.1 Genesis Metrics

```rust
struct GenesisMetrics {
    // Network health
    validators_online: u32,
    validators_offline: u32,
    p2p_connections: u32,
    network_partition_detected: bool,
    
    // Block production
    blocks_produced: u64,
    blocks_missed: u64,
    average_block_time: Duration,
    block_time_variance: f64,
    
    // Consensus
    consensus_rounds: u64,
    consensus_timeouts: u64,
    equivocation_detected: u32,
    
    // Cross-shard
    cross_shard_txs: u64,
    cross_shard_timeouts: u64,
    
    // Transactions
    total_txs: u64,
    failed_txs: u64,
    mempool_size: usize,
}

fn monitor_genesis_health() {
    let metrics = collect_genesis_metrics();
    
    // Critical alerts
    if metrics.validators_online < (2 * total_validators / 3) {
        alert!(Critical, "Validator quorum lost!");
    }
    
    if metrics.network_partition_detected {
        alert!(Critical, "Network partition detected!");
    }
    
    if metrics.average_block_time > Duration::from_secs(2) {
        alert!(Warning, "Block time significantly elevated");
    }
    
    // Success criteria
    if metrics.blocks_produced >= 1024 &&  // First epoch complete
       metrics.cross_shard_txs > 0 &&      // Cross-shard working
       metrics.equivocation_detected == 0  // No misbehavior
    {
        println!("‚úÖ Genesis successful! Network healthy.");
    }
}
```

### 11.2 Dashboard Endpoints

**Public Status Page:**
```
https://status.ecliptica.network/genesis

Metrics:
- Validators online: 98/100 (98%)
- Current block: 1,234 / ‚àû
- Average block time: 502 ms
- Cross-shard txs: 45
- Network status: HEALTHY ‚úÖ
```

**Validator Coordination:**
```
https://genesis.ecliptica.network/validators

- Validator Alpha: ‚úÖ ONLINE (signed genesis)
- Validator Beta: ‚úÖ ONLINE (signed genesis)
- Validator Gamma: ‚ö†Ô∏è OFFLINE
...
```

---

## 12. Testing & Dry Runs

### 12.1 Pre-Launch Testing Schedule

**Week -4: DevNet Genesis Dry Run**
```rust
fn devnet_genesis_test() {
    // 1. Generate test genesis with 5 validators
    let genesis = generate_test_genesis(5)?;
    
    // 2. Launch local devnet
    launch_devnet(genesis)?;
    
    // 3. Verify basic functionality
    assert!(produce_blocks(100)?);
    assert!(cross_shard_transfer_works()?);
    assert!(validator_rotation_works()?);
    
    // 4. Shutdown and export metrics
    let metrics = shutdown_devnet()?;
    assert!(metrics.success_rate > 0.95);
}
```

**Week -3: Public TestNet Genesis Rehearsal**
```rust
fn testnet_genesis_rehearsal() {
    // 1. Announce rehearsal to validator community
    announce_rehearsal_schedule()?;
    
    // 2. Collect rehearsal registrations
    let validators = collect_rehearsal_registrations()?;
    assert!(validators.len() >= 50);
    
    // 3. Generate rehearsal genesis
    let genesis = generate_rehearsal_genesis(validators)?;
    
    // 4. Execute synchronized launch
    let launch_time = SystemTime::now() + Duration::from_secs(3600);
    coordinate_rehearsal_launch(genesis, launch_time)?;
    
    // 5. Monitor for 24 hours
    monitor_rehearsal_network(Duration::from_secs(86400))?;
    
    // 6. Collect feedback and iterate
    collect_validator_feedback()?;
}
```

**Week -2: Load Testing**
```rust
fn genesis_load_test() {
    // Simulate mainnet load
    let tx_rate = 50_000;  // TPS
    let duration = Duration::from_hours(1);
    
    let results = run_load_test(tx_rate, duration)?;
    
    assert!(results.average_block_time < Duration::from_millis(600));
    assert!(results.finality_latency < Duration::from_secs(35));
    assert!(results.success_rate > 0.99);
}
```

### 12.2 Failure Scenario Testing

```rust
fn test_genesis_failure_scenarios() {
    // Scenario 1: Validator late to genesis
    test_late_validator_sync()?;
    
    // Scenario 2: Network partition at genesis
    test_partition_recovery()?;
    
    // Scenario 3: Invalid genesis file
    test_genesis_validation_rejection()?;
    
    // Scenario 4: State root mismatch
    test_state_root_consensus()?;
    
    // Scenario 5: Validator Byzantine behavior
    test_byzantine_at_genesis()?;
}
```

---

## 13. Documentation & Communication

### 13.1 Validator Runbook

**Published at:** `https://docs.ecliptica.network/genesis/validator-guide`

```markdown
# Ecliptica MainNet Genesis Validator Guide

## Timeline
- **2025-01-01 00:00:00 UTC**: Genesis time
- **2024-12-25**: Final genesis.json published
- **2024-12-20**: Validator registration closes

## Prerequisites
- [ ] Node software installed (v1.0.0)
- [ ] Hardware meets minimum requirements
- [ ] Network configured and tested
- [ ] Validator keys generated and backed up

## Steps

### 1. Download Genesis File
```bash
wget https://genesis.ecliptica.network/mainnet.json
sha256sum mainnet.json  # Verify: abc123...
```

### 2. Verify Genesis
```bash
ecliptica-cli genesis verify mainnet.json
# Expected output: ‚úÖ Genesis file valid
```

### 3. Initialize Node
```bash
ecliptica-node init --genesis=mainnet.json
ecliptica-node keys import --validator=validator.key
```

### 4. Start Node (Synchronized)
```bash
# Wait until 2025-01-01 00:00:00 UTC, then:
ecliptica-node start --genesis=mainnet.json
```

### 5. Monitor
```bash
ecliptica-cli status
# Should see: "Status: SYNCING" then "Status: VALIDATING"
```

## Troubleshooting
- **Error: Genesis time not reached**: Wait until genesis time
- **Error: Peer connection failed**: Check firewall and seeds
- **Error: State root mismatch**: Re-download genesis file
```

### 13.2 Community Communication

**Announcement Template:**

```markdown
üöÄ **Ecliptica MainNet Genesis Announcement**

We're excited to announce the launch of Ecliptica MainNet!

**Genesis Time:** January 1, 2025, 00:00:00 UTC

**Genesis File:**
- IPFS: QmAbC123...
- GitHub: https://github.com/ecliptica/genesis
- SHA-256: abc123def456...

**How to Participate:**
1. Validators: Follow the [Validator Guide](...)
2. Users: Wait for RPC endpoints to be available
3. Developers: Review [API documentation](...)

**Launch Status:**
Real-time status: https://status.ecliptica.network

**Support:**
- Discord: https://discord.gg/ecliptica
- Telegram: https://t.me/ecliptica_official
- Email: genesis@ecliptica.network

See you at genesis! üåÖ
```

---

## Appendix A: Genesis File Size Estimation

```rust
// Size breakdown for mainnet genesis

struct GenesisSizeEstimate {
    header: usize,              // ~500 bytes
    validator_set: usize,       // 100 validators √ó 3 KB = 300 KB
    account_allocations: usize, // 100,000 accounts √ó 100 bytes = 10 MB
    shard_states: usize,        // 8 shards √ó 500 KB = 4 MB
    beacon_state: usize,        // ~1 MB
    consensus_params: usize,    // ~10 KB
    total_estimated: usize,     // ~15.5 MB
}

// Actual mainnet genesis.json: ~16 MB (compressed: ~4 MB with zstd)
```

---

## Appendix B: Address Derivation Standards

```rust
// Standard address derivation for Ecliptica

fn derive_address(pubkey: &[u8; 1952]) -> Address {
    // ML-DSA (Dilithium-3) public key ‚Üí Address
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_ADDRESS_v1");
    hasher.update(pubkey);
    
    let mut output = [0u8; 20];
    hasher.finalize_xof_into(&mut output);
    output
}

// Bech32 encoding (human-readable)
fn encode_address(addr: Address) -> String {
    bech32::encode("ecliptica", addr.to_vec(), bech32::Variant::Bech32m)
        .expect("Valid address")
}

// Example: ecliptica1abc123def456...
```

---

**Document ID:** `ECLIPT-GENESIS-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review