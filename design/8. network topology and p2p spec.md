# üåê **Ecliptica Network Topology & P2P Protocol Specification**

### *Decentralized Communication Layer for Post-Quantum Privacy Blockchain*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-NETWORK-001`  
**Depends On:** `ECLIPT-GENESIS-001`, `ECLIPT-CONSENSUS-001`, `ECLIPT-LIGHT-001`

---

## 1. Executive Summary

Ecliptica's network layer is built on **libp2p** with custom protocols optimized for:

- **Sharded Architecture**: Efficient cross-shard communication
- **Privacy-Preserving Gossip**: Encrypted transaction propagation
- **Eclipse Attack Resistance**: Multi-path peer discovery
- **Sybil Resistance**: Stake-weighted peer scoring
- **Post-Quantum Security**: ML-DSA authenticated connections

**Network Statistics (Target):**
- Full nodes: 100-500
- Light clients: 10,000-1,000,000
- Average peer connections: 50-100
- Block propagation time: <200ms (99th percentile)
- Transaction propagation: <500ms (99th percentile)

---

## 2. Network Architecture Overview

### 2.1 Node Types & Roles

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Ecliptica Network Topology                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ           Beacon Chain Validators              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ         (Full connectivity mesh)               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îê          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îÇV1‚îú‚îÄ‚îÄ‚î§V2‚îú‚îÄ‚îÄ‚î§V3‚îú‚îÄ‚îÄ‚î§V4‚îú‚îÄ‚îÄ‚î§V5‚îú‚îÄ‚îÄ‚î§V6‚îÇ          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚î¨‚îÄ‚îò  ‚îî‚î¨‚îÄ‚îò  ‚îî‚î¨‚îÄ‚îò  ‚îî‚î¨‚îÄ‚îò  ‚îî‚î¨‚îÄ‚îò  ‚îî‚î¨‚îÄ‚îò          ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ      ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ              Shard Validators                   ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  Shard 0    Shard 1    Shard 2    Shard 3      ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îê    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚îÇ‚îÇ ‚îÇ    ‚îÇ ‚îÇ‚îÇ ‚îÇ    ‚îÇ ‚îÇ‚îÇ ‚îÇ    ‚îÇ ‚îÇ‚îÇ ‚îÇ    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îò    ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ       ‚îÇ            ‚îÇ            ‚îÇ            ‚îÇ         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ            Full Nodes (Archive/RPC)            ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ FN ‚îÇ  ‚îÇ FN ‚îÇ  ‚îÇ FN ‚îÇ  ‚îÇ FN ‚îÇ  ‚îÇ FN ‚îÇ      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ        ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ              Light Clients                     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  [Mobile] [Browser] [IoT] [Mobile] [Browser]  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Node Classification

```rust
enum NodeType {
    // Validators
    BeaconValidator {
        stake: u64,
        peer_count: usize,              // 100-200 peers
    },
    
    ShardValidator {
        shard_id: u8,
        stake: u64,
        peer_count: usize,              // 50-100 peers
    },
    
    // Full nodes
    FullNode {
        archival: bool,                 // Store full history?
        serves_rpc: bool,               // Public RPC endpoint?
        peer_count: usize,              // 20-50 peers
    },
    
    // Light clients
    LightClient {
        platform: Platform,
        peer_count: usize,              // 3-10 peers
    },
    
    // Infrastructure
    BootstrapNode {
        peer_count: usize,              // 500-1000 peers
    },
}

enum Platform {
    Mobile,
    Browser,
    IoT,
    Desktop,
}
```

### 2.3 Network Layers

| Layer         | Protocol              | Purpose                         | Participants               |
| ------------- | --------------------- | ------------------------------- | -------------------------- |
| **Consensus** | Custom BFT            | Block proposal & voting         | Validators only            |
| **Gossip**    | libp2p GossipSub      | Transaction & block propagation | All nodes                  |
| **Discovery** | Kademlia DHT          | Peer discovery                  | All nodes                  |
| **Direct**    | libp2p mplex/yamux    | Direct validator communication  | Validators                 |
| **RPC**       | JSON-RPC over HTTP/WS | Client-server queries           | Full nodes ‚Üî Light clients |

---

## 3. Bootstrap & Peer Discovery

### 3.1 Bootstrap Strategy

**Multi-Source Bootstrap:**

```rust
struct BootstrapConfig {
    // Embedded seed nodes (hardcoded in binary)
    embedded_seeds: Vec<Multiaddr>,
    
    // DNS seeds (domain names)
    dns_seeds: Vec<String>,
    
    // DHT bootstrap nodes
    dht_bootstrap: Vec<PeerId>,
    
    // Custom bootstrap sources
    custom_bootstrap: Option<Vec<Multiaddr>>,
}

impl Default for BootstrapConfig {
    fn default() -> Self {
        Self {
            embedded_seeds: vec![
                // Mainnet seeds (maintained by foundation)
                "/dns4/seed-1.ecliptica.network/tcp/26656/p2p/12D3KooWAbc...".parse().unwrap(),
                "/dns4/seed-2.ecliptica.network/tcp/26656/p2p/12D3KooWDef...".parse().unwrap(),
                "/dns4/seed-3.ecliptica.network/tcp/26656/p2p/12D3KooWGhi...".parse().unwrap(),
                
                // Geographic diversity
                "/dns4/seed-eu.ecliptica.network/tcp/26656/p2p/12D3KooWJkl...".parse().unwrap(),
                "/dns4/seed-asia.ecliptica.network/tcp/26656/p2p/12D3KooWMno...".parse().unwrap(),
                "/dns4/seed-us.ecliptica.network/tcp/26656/p2p/12D3KooWPqr...".parse().unwrap(),
            ],
            
            dns_seeds: vec![
                "seed.ecliptica.network".to_string(),
                "mainnet-seed.ecliptica.network".to_string(),
            ],
            
            dht_bootstrap: vec![],  // Populated from embedded_seeds
            
            custom_bootstrap: None,
        }
    }
}
```

**Bootstrap Sequence:**

```rust
async fn bootstrap(config: BootstrapConfig) -> Result<NetworkState> {
    let mut swarm = build_libp2p_swarm().await?;
    let mut discovered_peers = HashSet::new();
    
    // 1. Connect to embedded seeds
    for seed in config.embedded_seeds {
        match swarm.dial(seed.clone()) {
            Ok(_) => {
                log::info!("Dialing seed: {}", seed);
                discovered_peers.insert(seed);
            },
            Err(e) => log::warn!("Failed to dial seed {}: {}", seed, e),
        }
    }
    
    // Wait for at least 2 connections
    let connected = wait_for_connections(&mut swarm, 2, Duration::from_secs(10)).await?;
    if connected < 2 {
        return Err(Error::InsufficientBootstrapConnections);
    }
    
    // 2. Query DNS seeds
    for dns_seed in config.dns_seeds {
        match resolve_dns_seed(&dns_seed).await {
            Ok(addrs) => {
                for addr in addrs {
                    swarm.dial(addr)?;
                    discovered_peers.insert(addr);
                }
            },
            Err(e) => log::warn!("Failed to resolve DNS seed {}: {}", dns_seed, e),
        }
    }
    
    // 3. Bootstrap DHT
    for peer in config.dht_bootstrap {
        swarm.behaviour_mut().kademlia.add_address(&peer, "/ip4/0.0.0.0/tcp/0".parse()?);
    }
    swarm.behaviour_mut().kademlia.bootstrap()?;
    
    // 4. Discover peers via DHT
    let dht_peers = discover_peers_dht(&mut swarm, 50, Duration::from_secs(30)).await?;
    discovered_peers.extend(dht_peers);
    
    // 5. Peer exchange with connected peers
    let exchanged_peers = peer_exchange(&mut swarm, 20).await?;
    discovered_peers.extend(exchanged_peers);
    
    Ok(NetworkState {
        swarm,
        discovered_peers,
        connected_peers: get_connected_peers(&swarm),
    })
}
```

### 3.2 DNS Seed Protocol

**DNS TXT Record Format:**

```
_ecliptica-mainnet._tcp.seed.ecliptica.network. TXT "p2p://12D3KooWAbc...@1.2.3.4:26656"
_ecliptica-mainnet._tcp.seed.ecliptica.network. TXT "p2p://12D3KooWDef...@5.6.7.8:26656"
...
```

**DNS Resolution:**

```rust
async fn resolve_dns_seed(domain: &str) -> Result<Vec<Multiaddr>> {
    let txt_records = dns_lookup_txt(&format!("_ecliptica-mainnet._tcp.{}", domain)).await?;
    
    let mut addrs = Vec::new();
    for record in txt_records {
        // Parse: "p2p://12D3KooWAbc...@1.2.3.4:26656"
        if let Some(addr) = parse_p2p_url(&record) {
            addrs.push(addr);
        }
    }
    
    Ok(addrs)
}

fn parse_p2p_url(url: &str) -> Option<Multiaddr> {
    let parts: Vec<&str> = url.strip_prefix("p2p://")?.split('@').collect();
    if parts.len() != 2 {
        return None;
    }
    
    let peer_id = parts[0];
    let socket_addr = parts[1];
    
    let multiaddr = format!("/ip4/{}/tcp/{}/p2p/{}", 
        socket_addr.split(':').next()?,
        socket_addr.split(':').nth(1)?,
        peer_id
    );
    
    multiaddr.parse().ok()
}
```

### 3.3 Kademlia DHT

**DHT Configuration:**

```rust
use libp2p::kad::{Kademlia, KademliaConfig, KademliaEvent};

fn configure_kademlia() -> Kademlia<MemoryStore> {
    let mut config = KademliaConfig::default();
    
    // K-bucket size (20 peers per bucket)
    config.set_kbucket_size(20);
    
    // Replication factor
    config.set_replication_factor(20.try_into().unwrap());
    
    // Query timeout
    config.set_query_timeout(Duration::from_secs(30));
    
    // Record TTL
    config.set_record_ttl(Some(Duration::from_secs(36 * 3600))); // 36 hours
    
    let store = MemoryStore::new(local_peer_id);
    Kademlia::with_config(local_peer_id, store, config)
}
```

**Peer Discovery Query:**

```rust
async fn discover_peers_dht(
    swarm: &mut Swarm<NetworkBehaviour>,
    target_count: usize,
    timeout: Duration,
) -> Result<Vec<Multiaddr>> {
    let start = Instant::now();
    let mut discovered = Vec::new();
    
    // Start random walk
    swarm.behaviour_mut().kademlia.get_closest_peers(PeerId::random());
    
    while discovered.len() < target_count && start.elapsed() < timeout {
        match swarm.select_next_some().await {
            SwarmEvent::Behaviour(BehaviourEvent::Kademlia(KademliaEvent::OutboundQueryProgressed {
                result: QueryResult::GetClosestPeers(Ok(peers)),
                ..
            })) => {
                for peer in peers.peers {
                    if let Some(addrs) = swarm.behaviour().kademlia.addresses_of_peer(&peer) {
                        discovered.extend(addrs);
                    }
                }
            },
            _ => {},
        }
    }
    
    Ok(discovered)
}
```

### 3.4 Peer Exchange Protocol

**PEX Message:**

```rust
struct PeerExchangeRequest {
    max_peers: u16,                     // Max peers to return
    filters: PeerFilters,
}

struct PeerFilters {
    node_types: Vec<NodeType>,          // Which types to return
    shards: Option<Vec<u8>>,            // Shard-specific peers
    exclude: Vec<PeerId>,               // Already known
}

struct PeerExchangeResponse {
    peers: Vec<PeerInfo>,
}

struct PeerInfo {
    peer_id: PeerId,
    addrs: Vec<Multiaddr>,
    node_type: NodeType,
    reputation: f64,                    // 0.0 - 1.0
}
```

**PEX Handler:**

```rust
fn handle_peer_exchange(
    request: PeerExchangeRequest,
    peer_store: &PeerStore,
) -> PeerExchangeResponse {
    let mut candidates: Vec<PeerInfo> = peer_store.all_peers()
        .filter(|p| {
            // Filter by type
            if !request.filters.node_types.is_empty() {
                if !request.filters.node_types.contains(&p.node_type) {
                    return false;
                }
            }
            
            // Filter by shard
            if let Some(shards) = &request.filters.shards {
                if let NodeType::ShardValidator { shard_id, .. } = p.node_type {
                    if !shards.contains(&shard_id) {
                        return false;
                    }
                }
            }
            
            // Exclude already known
            if request.filters.exclude.contains(&p.peer_id) {
                return false;
            }
            
            true
        })
        .collect();
    
    // Sort by reputation
    candidates.sort_by(|a, b| b.reputation.partial_cmp(&a.reputation).unwrap());
    
    // Take top N
    candidates.truncate(request.max_peers as usize);
    
    PeerExchangeResponse {
        peers: candidates,
    }
}
```

---

## 4. Network Partition Handling

### 4.1 Partition Detection

**Health Indicators:**

```rust
struct NetworkHealth {
    // Connectivity
    connected_peers: usize,
    target_peers: usize,
    
    // Consensus participation
    blocks_received: u64,
    blocks_expected: u64,
    
    // Shard connectivity
    shard_connections: HashMap<u8, usize>,
    
    // Beacon connectivity
    beacon_validators_connected: usize,
    beacon_validators_total: usize,
    
    // Partition score (0.0 = healthy, 1.0 = partitioned)
    partition_score: f64,
}

impl NetworkHealth {
    fn compute_partition_score(&self) -> f64 {
        let mut score = 0.0;
        
        // Peer connectivity (weight: 0.3)
        let peer_ratio = self.connected_peers as f64 / self.target_peers as f64;
        score += (1.0 - peer_ratio) * 0.3;
        
        // Block reception (weight: 0.4)
        let block_ratio = self.blocks_received as f64 / self.blocks_expected as f64;
        score += (1.0 - block_ratio) * 0.4;
        
        // Beacon connectivity (weight: 0.3)
        let beacon_ratio = self.beacon_validators_connected as f64 / self.beacon_validators_total as f64;
        score += (1.0 - beacon_ratio) * 0.3;
        
        score.clamp(0.0, 1.0)
    }
    
    fn is_partitioned(&self) -> bool {
        self.partition_score > 0.5
    }
}
```

**Partition Detection Algorithm:**

```rust
async fn detect_partition(
    swarm: &Swarm<NetworkBehaviour>,
    state: &ChainState,
) -> NetworkHealth {
    let health = NetworkHealth {
        connected_peers: swarm.connected_peers().count(),
        target_peers: TARGET_PEER_COUNT,
        blocks_received: state.blocks_received_last_epoch,
        blocks_expected: BLOCKS_PER_EPOCH,
        shard_connections: count_shard_connections(swarm),
        beacon_validators_connected: count_beacon_connections(swarm),
        beacon_validators_total: state.total_beacon_validators,
        partition_score: 0.0,
    };
    
    health.compute_partition_score();
    
    if health.is_partitioned() {
        log::warn!("Network partition detected! Score: {:.2}", health.partition_score);
        trigger_partition_recovery(swarm).await?;
    }
    
    health
}
```

### 4.2 Partition Recovery

**Recovery Strategies:**

```rust
async fn recover_from_partition(swarm: &mut Swarm<NetworkBehaviour>) -> Result<()> {
    log::info!("Initiating partition recovery...");
    
    // 1. Re-bootstrap from seeds
    let seeds = BootstrapConfig::default().embedded_seeds;
    for seed in seeds {
        swarm.dial(seed)?;
    }
    
    // 2. Aggressive peer discovery
    swarm.behaviour_mut().kademlia.bootstrap()?;
    
    // 3. Peer exchange with all connected peers
    for peer in swarm.connected_peers().collect::<Vec<_>>() {
        request_peer_exchange(swarm, peer, 50).await?;
    }
    
    // 4. Diversify connections (geographic, AS, etc.)
    diversify_connections(swarm, 20).await?;
    
    // 5. Wait for recovery
    let timeout = Duration::from_secs(60);
    let recovered = wait_for_health_recovery(swarm, timeout).await?;
    
    if recovered {
        log::info!("Successfully recovered from partition");
        Ok(())
    } else {
        log::error!("Failed to recover from partition");
        Err(Error::PartitionRecoveryFailed)
    }
}
```

### 4.3 Cross-Shard Connectivity Monitoring

```rust
struct ShardConnectivityMonitor {
    // Shard ID ‚Üí Set of connected peers
    shard_peers: HashMap<u8, HashSet<PeerId>>,
    
    // Minimum required connections per shard
    min_connections_per_shard: usize,
}

impl ShardConnectivityMonitor {
    fn check_shard_connectivity(&self) -> Result<()> {
        for shard_id in 0..NUM_SHARDS {
            let connections = self.shard_peers.get(&shard_id)
                .map(|set| set.len())
                .unwrap_or(0);
            
            if connections < self.min_connections_per_shard {
                log::warn!(
                    "Insufficient connections to shard {}: {} < {}",
                    shard_id,
                    connections,
                    self.min_connections_per_shard
                );
                
                // Trigger recovery for this shard
                self.recover_shard_connectivity(shard_id)?;
            }
        }
        
        Ok(())
    }
    
    fn recover_shard_connectivity(&self, shard_id: u8) -> Result<()> {
        // Request peers specifically for this shard
        let request = PeerExchangeRequest {
            max_peers: 20,
            filters: PeerFilters {
                node_types: vec![NodeType::ShardValidator { shard_id, .. }],
                shards: Some(vec![shard_id]),
                exclude: self.shard_peers.get(&shard_id)
                    .map(|set| set.iter().copied().collect())
                    .unwrap_or_default(),
            },
        };
        
        // Broadcast to all connected peers
        broadcast_peer_exchange_request(request)?;
        
        Ok(())
    }
}
```

---

## 5. Eclipse Attack Prevention

### 5.1 Attack Model

**Eclipse Attack:** Attacker isolates victim by controlling all network connections

**Attack Vectors:**
1. Sybil nodes flood DHT/peer discovery
2. Attacker controls all seed nodes victim connects to
3. BGP hijacking (network-level)
4. DNS poisoning

### 5.2 Multi-Path Diversity

**Connection Diversity Metrics:**

```rust
struct ConnectionDiversity {
    // IP diversity
    unique_ip_prefixes: HashSet<String>,     // /24 prefixes
    unique_asns: HashSet<u32>,               // Autonomous Systems
    
    // Geographic diversity
    countries: HashSet<String>,
    regions: HashSet<String>,
    
    // Network diversity
    connection_types: HashSet<ConnectionType>,
}

enum ConnectionType {
    Inbound,
    Outbound,
    Bootstrap,
    DHT,
    PeerExchange,
}

impl ConnectionDiversity {
    fn diversity_score(&self) -> f64 {
        let mut score = 0.0;
        
        // IP prefix diversity (weight: 0.3)
        score += (self.unique_ip_prefixes.len() as f64 / 20.0).min(1.0) * 0.3;
        
        // ASN diversity (weight: 0.3)
        score += (self.unique_asns.len() as f64 / 10.0).min(1.0) * 0.3;
        
        // Geographic diversity (weight: 0.2)
        score += (self.countries.len() as f64 / 5.0).min(1.0) * 0.2;
        
        // Connection type diversity (weight: 0.2)
        score += (self.connection_types.len() as f64 / 5.0) * 0.2;
        
        score
    }
}
```

**Diversity-Based Peer Selection:**

```rust
fn select_peers_with_diversity(
    candidates: Vec<PeerInfo>,
    current_peers: &[PeerInfo],
    target_count: usize,
) -> Vec<PeerInfo> {
    let mut selected = Vec::new();
    let mut diversity = compute_diversity(current_peers);
    
    // Score each candidate
    let mut scored: Vec<_> = candidates.into_iter()
        .map(|peer| {
            let diversity_gain = compute_diversity_gain(&peer, &diversity);
            let reputation_score = peer.reputation;
            
            // Combined score (70% diversity, 30% reputation)
            let score = diversity_gain * 0.7 + reputation_score * 0.3;
            
            (score, peer)
        })
        .collect();
    
    // Sort by score (descending)
    scored.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap());
    
    // Select top N
    for (_, peer) in scored.into_iter().take(target_count) {
        selected.push(peer);
        diversity = update_diversity(&diversity, &peer);
    }
    
    selected
}

fn compute_diversity_gain(peer: &PeerInfo, current: &ConnectionDiversity) -> f64 {
    let mut gain = 0.0;
    
    // IP prefix gain
    let ip_prefix = get_ip_prefix(&peer.addrs[0]);
    if !current.unique_ip_prefixes.contains(&ip_prefix) {
        gain += 0.3;
    }
    
    // ASN gain
    let asn = get_asn(&peer.addrs[0]);
    if !current.unique_asns.contains(&asn) {
        gain += 0.3;
    }
    
    // Country gain
    let country = geolocate(&peer.addrs[0]);
    if !current.countries.contains(&country) {
        gain += 0.2;
    }
    
    gain
}
```

### 5.3 Anchor Connections

**Trusted Anchors:** Always maintain connections to diverse, trusted peers

```rust
struct AnchorConfig {
    // Foundation-operated nodes (geographic diversity)
    foundation_nodes: Vec<Multiaddr>,
    
    // Community-operated trusted nodes
    community_anchors: Vec<Multiaddr>,
    
    // Minimum anchor connections
    min_anchors: usize,
}

impl AnchorConfig {
    fn default() -> Self {
        Self {
            foundation_nodes: vec![
                "/dns4/anchor-us-east.ecliptica.network/tcp/26656/p2p/12D3...".parse().unwrap(),
                "/dns4/anchor-eu-west.ecliptica.network/tcp/26656/p2p/12D3...".parse().unwrap(),
                "/dns4/anchor-asia-east.ecliptica.network/tcp/26656/p2p/12D3...".parse().unwrap(),
            ],
            community_anchors: vec![],
            min_anchors: 3,
        }
    }
}

async fn maintain_anchor_connections(
    swarm: &mut Swarm<NetworkBehaviour>,
    config: &AnchorConfig,
) -> Result<()> {
    let connected_anchors = count_connected_anchors(swarm, config);
    
    if connected_anchors < config.min_anchors {
        log::warn!("Insufficient anchor connections: {} < {}", connected_anchors, config.min_anchors);
        
        // Reconnect to all anchors
        for anchor in &config.foundation_nodes {
            if !is_connected(swarm, anchor) {
                swarm.dial(anchor.clone())?;
            }
        }
        
        for anchor in &config.community_anchors {
            if !is_connected(swarm, anchor) {
                swarm.dial(anchor.clone())?;
            }
        }
    }
    
    Ok(())
}
```

### 5.4 Reputation-Based Filtering

**Peer Reputation System:**

```rust
struct PeerReputation {
    peer_id: PeerId,
    
    // Scores (0.0 - 1.0)
    uptime_score: f64,
    latency_score: f64,
    behavior_score: f64,
    
    // Counters
    successful_responses: u64,
    failed_responses: u64,
    malicious_behavior: u64,
    
    // Metadata
    first_seen: Instant,
    last_seen: Instant,
}

impl PeerReputation {
    fn overall_score(&self) -> f64 {
        let uptime_weight = 0.3;
        let latency_weight = 0.2;
        let behavior_weight = 0.5;
        
        self.uptime_score * uptime_weight
            + self.latency_score * latency_weight
            + self.behavior_score * behavior_weight
    }
    
    fn is_trusted(&self) -> bool {
        self.overall_score() > 0.75
            && self.malicious_behavior == 0
            && self.first_seen.elapsed() > Duration::from_secs(3600) // 1 hour
    }
    
    fn is_banned(&self) -> bool {
        self.malicious_behavior > 3
            || self.behavior_score < 0.2
            || (self.failed_responses > 100 && self.successful_responses < 10)
    }
}

fn update_reputation_on_event(
    peer_id: &PeerId,
    event: NetworkEvent,
    store: &mut PeerStore,
) {
    let reputation = store.get_reputation_mut(peer_id);
    
    match event {
        NetworkEvent::SuccessfulResponse { latency } => {
            reputation.successful_responses += 1;
            reputation.latency_score = update_latency_score(reputation.latency_score, latency);
        },
        
        NetworkEvent::FailedResponse => {
            reputation.failed_responses += 1;
        },
        
        NetworkEvent::MaliciousBehavior { reason } => {
            reputation.malicious_behavior += 1;
            reputation.behavior_score *= 0.5; // Heavy penalty
            log::warn!("Malicious behavior from {}: {:?}", peer_id, reason);
        },
        
        NetworkEvent::BlockReceived { valid } => {
            if valid {
                reputation.behavior_score = (reputation.behavior_score + 0.01).min(1.0);
            } else {
                reputation.malicious_behavior += 1;
                reputation.behavior_score *= 0.8;
            }
        },
    }
    
    // Ban if threshold exceeded
    if reputation.is_banned() {
        store.ban_peer(peer_id, Duration::from_secs(86400)); // 24 hours
    }
}
```

---

## 6. Sybil Resistance

### 6.1 Stake-Weighted Connections

**Peer Scoring with Stake:**

```rust
fn compute_peer_score(peer: &PeerInfo, my_stake: u64) -> f64 {
    let mut score = 0.0;
    
    // Base reputation (40%)
    score += peer.reputation * 0.4;
    
    // Stake weight (40%)
    let stake_score = match peer.node_type {
        NodeType::BeaconValidator { stake, .. } | 
        NodeType::ShardValidator { stake, .. } => {
            // Logarithmic stake weight (prevents whale dominance)
            ((stake as f64).ln() / (1_000_000.0f64).ln()).min(1.0)
        },
        _ => 0.3, // Non-validator nodes get moderate score
    };
    score += stake_score * 0.4;
    
    // Diversity bonus (20%)
    let diversity_bonus = if is_diverse_peer(peer) { 1.0 } else { 0.5 };
    score += diversity_bonus * 0.2;
    
    score
}
```

**Connection Limits:**

```rust
struct ConnectionLimits {
    // Per node type
    max_validators: usize,              // 50
    max_full_nodes: usize,              // 30
    max_light_clients: usize,           // 20
    
    // Per IP/ASN
    max_per_ip: usize,                  // 3
    max_per_asn: usize,                 // 10
    
    // Total
    max_total: usize,                   // 100
}

fn enforce_connection_limits(
    swarm: &mut Swarm<NetworkBehaviour>,
    limits: &ConnectionLimits,
) -> Result<()> {
    let connections = swarm.connected_peers().collect::<Vec<_>>();
    
    // Count by type
    let mut type_counts = HashMap::new();
    let mut ip_counts = HashMap::new();
    let mut asn_counts = HashMap::new();
    
    for peer_id in &connections {
        let peer_info = get_peer_info(peer_id)?;
        
        // Count by type
        *type_counts.entry(peer_info.node_type).or_insert(0) += 1;
        
        // Count by IP
        let ip = get_ip_from_addr(&peer_info.addrs[0]);
        *ip_counts.entry(ip).or_insert(0) += 1;
        
        // Count by ASN
        let asn = get_asn(&peer_info.addrs[0]);
        *asn_counts.entry(asn).or_insert(0) += 1;
    }
    
    // Disconnect excess peers
    for peer_id in connections {
        let peer_info = get_peer_info(&peer_id)?;
        let ip = get_ip_from_addr(&peer_info.addrs[0]);
        let asn = get_asn(&peer_info.addrs[0]);
        
        let should_disconnect = 
            // Type limit exceeded
            type_counts.get(&peer_info.node_type).unwrap() > &get_type_limit(&peer_info.node_type, limits)
            // IP limit exceeded
            || ip_counts.get(&ip).unwrap() > &limits.max_per_ip
            // ASN limit exceeded
            || asn_counts.get(&asn).unwrap() > &limits.max_per_asn;
        
        if should_disconnect {
            swarm.disconnect_peer_id(peer_id)?;
            log::debug!("Disconnected peer {} due to limit", peer_id);
        }
    }
    
    Ok(())
}
```

### 6.2 Proof of Stake for Network Access

**Stake-Based Admission:**

```rust
struct StakeProof {
    validator_address: Address,
    stake_amount: u64,
    
    // Proof of stake (zk-STARK)
    stake_proof: Vec<u8>,
    
    // Signature (ML-DSA)
    signature: DilithiumSignature,
    
    // Freshness
    timestamp: u64,
    block_height: u64,
}

fn verify_stake_proof(proof: &StakeProof, state_root: &[u8; 32]) -> Result<bool> {
    // 1. Verify signature
    let message = [
        &proof.validator_address[..],
        &proof.stake_amount.to_le_bytes(),
        &proof.timestamp.to_le_bytes(),
        &proof.block_height.to_le_bytes(),
    ].concat();
    
    verify_dilithium_signature(&proof.signature, &message, &get_validator_pubkey(&proof.validator_address)?)?;
    
    // 2. Verify stake proof (zk-STARK)
    let public_inputs = vec![
        proof.validator_address.to_vec(),
        proof.stake_amount.to_le_bytes().to_vec(),
        state_root.to_vec(),
    ];
    
    verify_stark_proof(&proof.stake_proof, &public_inputs)?;
    
    // 3. Check freshness (within 1 hour)
    let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
    if current_time - proof.timestamp > 3600 {
        return Ok(false);
    }
    
    Ok(true)
}
```

### 6.3 Rate Limiting

**Per-Peer Rate Limits:**

```rust
struct RateLimiter {
    limits: HashMap<PeerId, PeerRateLimit>,
}

struct PeerRateLimit {
    // Request limits
    requests_per_second: u32,
    requests_current_window: u32,
    window_start: Instant,
    
    // Bandwidth limits
    bytes_per_second: u64,
    bytes_current_window: u64,
    
    // Penalties
    violations: u32,
}

impl RateLimiter {
    fn check_rate_limit(&mut self, peer_id: &PeerId, request_size: u64) -> Result<()> {
        let limit = self.limits.entry(*peer_id).or_insert_with(|| PeerRateLimit {
            requests_per_second: 100,
            requests_current_window: 0,
            window_start: Instant::now(),
            bytes_per_second: 1_000_000, // 1 MB/s
            bytes_current_window: 0,
            violations: 0,
        });
        
        // Reset window if expired
        if limit.window_start.elapsed() > Duration::from_secs(1) {
            limit.requests_current_window = 0;
            limit.bytes_current_window = 0;
            limit.window_start = Instant::now();
        }
        
        // Check request rate
        if limit.requests_current_window >= limit.requests_per_second {
            limit.violations += 1;
            return Err(Error::RateLimitExceeded);
        }
        
        // Check bandwidth
        if limit.bytes_current_window + request_size > limit.bytes_per_second {
            limit.violations += 1;
            return Err(Error::BandwidthLimitExceeded);
        }
        
        // Update counters
        limit.requests_current_window += 1;
        limit.bytes_current_window += request_size;
        
        Ok(())
    }
}
```

---

## 7. Gossip Protocols

### 7.1 GossipSub Topics

```rust
const TOPIC_BLOCKS: &str = "/ecliptica/blocks/1.0.0";
const TOPIC_TXS: &str = "/ecliptica/txs/1.0.0";
const TOPIC_CONSENSUS: &str = "/ecliptica/consensus/1.0.0";

// Per-shard topics
fn shard_topic(shard_id: u8) -> String {
    format!("/ecliptica/shard-{}/1.0.0", shard_id)
}

// Beacon topic
const TOPIC_BEACON: &str = "/ecliptica/beacon/1.0.0";
```

### 7.2 Message Propagation

**Block Propagation:**

```rust
async fn propagate_block(
    block: &Block,
    gossipsub: &mut Gossipsub,
) -> Result<()> {
    // Serialize block
    let block_bytes = serialize_canonical(block);
    
    // Compute message ID (for deduplication)
    let message_id = compute_message_id(&block_bytes);
    
    // Publish to appropriate topic
    let topic = if block.is_beacon_block() {
        TOPIC_BEACON
    } else {
        shard_topic(block.shard_id)
    };
    
    gossipsub.publish(Topic::new(topic), block_bytes)?;
    
    log::debug!("Propagated block {} to topic {}", block.height, topic);
    
    Ok(())
}
```

**Transaction Propagation (Encrypted):**

```rust
async fn propagate_encrypted_transaction(
    encrypted_tx: &EncryptedTransaction,
    gossipsub: &mut Gossipsub,
) -> Result<()> {
    // Serialize encrypted transaction
    let tx_bytes = serialize_canonical(encrypted_tx);
    
    // Route to appropriate shard
    let topic = shard_topic(encrypted_tx.shard);
    
    // Publish
    gossipsub.publish(Topic::new(topic), tx_bytes)?;
    
    log::debug!("Propagated encrypted tx {} to shard {}", encrypted_tx.tx_id, encrypted_tx.shard);
    
    Ok(())
}
```

### 7.3 Message Validation

```rust
fn validate_gossip_message(
    message: &GossipsubMessage,
    source: &PeerId,
) -> MessageAcceptance {
    // 1. Check message size
    if message.data.len() > MAX_MESSAGE_SIZE {
        log::warn!("Oversized message from {}", source);
        return MessageAcceptance::Reject;
    }
    
    // 2. Rate limit check
    if !check_gossip_rate_limit(source) {
        return MessageAcceptance::Ignore;
    }
    
    // 3. Deserialize and validate
    match message.topic.as_str() {
        TOPIC_BLOCKS => {
            match deserialize_block(&message.data) {
                Ok(block) => {
                    if validate_block_header(&block).is_ok() {
                        MessageAcceptance::Accept
                    } else {
                        MessageAcceptance::Reject
                    }
                },
                Err(_) => MessageAcceptance::Reject,
            }
        },
        
        TOPIC_TXS => {
            match deserialize_encrypted_tx(&message.data) {
                Ok(tx) => {
                    if validate_encrypted_tx_format(&tx).is_ok() {
                        MessageAcceptance::Accept
                    } else {
                        MessageAcceptance::Reject
                    }
                },
                Err(_) => MessageAcceptance::Reject,
            }
        },
        
        _ => MessageAcceptance::Ignore,
    }
}
```

---

## 8. Transport & Security

### 8.1 Transport Layer

**Supported Transports:**

```rust
fn build_transport() -> Result<Boxed<(PeerId, StreamMuxerBox)>> {
    // TCP + Noise + Yamux/Mplex
    let tcp = tcp::tokio::Transport::new(tcp::Config::default());
    
    // QUIC (preferred)
    let quic = quic::tokio::Transport::new(quic::Config::new(&keypair));
    
    // Noise protocol (post-quantum upgrade path)
    let noise_config = noise::Config::new(&keypair)?;
    
    // Multiplexing
    let yamux_config = yamux::Config::default();
    
    // Combine transports
    let transport = tcp
        .upgrade(Version::V1)
        .authenticate(noise_config)
        .multiplex(yamux_config)
        .or_transport(quic)
        .boxed();
    
    Ok(transport)
}
```

### 8.2 Connection Security

**TLS 1.3 + Post-Quantum:**

```rust
struct ConnectionSecurity {
    // Hybrid key exchange (classical + PQ)
    classical_kem: EcdhP256,
    pq_kem: MlKem512,
    
    // Authentication
    signature_scheme: DilithiumSignature,
    
    // Session keys
    session_key: [u8; 32],
}

fn establish_secure_connection(peer_pubkey: &[u8; 1952]) -> Result<ConnectionSecurity> {
    // 1. Hybrid KEM
    let (classical_shared, classical_ct) = ecdh_p256_encapsulate(peer_pubkey)?;
    let (pq_shared, pq_ct) = mlkem512_encapsulate(peer_pubkey)?;
    
    // 2. Combine shared secrets (hash)
    let combined_secret = shake256(&[classical_shared, pq_shared].concat());
    
    // 3. Derive session key
    let session_key = hkdf_expand(&combined_secret, b"ecliptica-session-key", 32);
    
    // 4. Authenticate with ML-DSA
    let auth_message = [&classical_ct, &pq_ct].concat();
    let signature = sign_dilithium(&auth_message, &local_keypair.secret)?;
    
    Ok(ConnectionSecurity {
        classical_kem: EcdhP256 { /* ... */ },
        pq_kem: MlKem512 { /* ... */ },
        signature_scheme: signature,
        session_key,
    })
}
```

---

## 9. Network Monitoring & Metrics

### 9.1 Real-Time Metrics

```rust
struct NetworkMetrics {
    // Peers
    connected_peers: usize,
    discovered_peers: usize,
    banned_peers: usize,
    
    // Diversity
    unique_asns: usize,
    unique_countries: usize,
    diversity_score: f64,
    
    // Bandwidth
    bytes_sent: u64,
    bytes_received: u64,
    bandwidth_usage: f64,               // Mbps
    
    // Latency
    avg_latency_ms: f64,
    p99_latency_ms: f64,
    
    // Messages
    messages_sent: u64,
    messages_received: u64,
    messages_dropped: u64,
    
    // Health
    partition_score: f64,
    eclipse_risk_score: f64,
}
```

### 9.2 Alerting

```rust
fn check_network_alerts(metrics: &NetworkMetrics) {
    if metrics.connected_peers < MIN_PEER_THRESHOLD {
        alert!(Critical, "Low peer count: {}", metrics.connected_peers);
    }
    
    if metrics.diversity_score < 0.3 {
        alert!(Warning, "Low connection diversity: {:.2}", metrics.diversity_score);
    }
    
    if metrics.partition_score > 0.5 {
        alert!(Critical, "Network partition detected: {:.2}", metrics.partition_score);
    }
    
    if metrics.eclipse_risk_score > 0.7 {
        alert!(Critical, "Eclipse attack risk: {:.2}", metrics.eclipse_risk_score);
    }
}
```

---

## Appendix A: Configuration Examples

```toml
# config.toml

[network]
# Listen addresses
listen_addrs = [
    "/ip4/0.0.0.0/tcp/26656",
    "/ip6/::/tcp/26656",
    "/ip4/0.0.0.0/udp/26656/quic",
]

# Bootstrap
bootstrap_nodes = [
    "/dns4/seed-1.ecliptica.network/tcp/26656/p2p/12D3KooW...",
    "/dns4/seed-2.ecliptica.network/tcp/26656/p2p/12D3KooW...",
]

# Peer limits
max_peers = 100
target_peers = 50
min_peers = 10

# Connection limits
max_per_ip = 3
max_per_asn = 10

# Timeouts
dial_timeout_secs = 10
connection_idle_timeout_secs = 300

[gossipsub]
# Mesh parameters
mesh_n = 6
mesh_n_low = 4
mesh_n_high = 12

# Gossip parameters
gossip_factor = 0.25
heartbeat_interval_secs = 1

[kademlia]
# DHT parameters
query_timeout_secs = 30
replication_factor = 20
kbucket_size = 20
```

---

**Document ID:** `ECLIPT-NETWORK-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review