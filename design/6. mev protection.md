# üõ°Ô∏è **Ecliptica MEV Protection & Fair Ordering Specification**

### *Mitigating Maximal Extractable Value in Post-Quantum Privacy Blockchain*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-MEV-001`  
**Depends On:** `ECLIPT-STATE-001`, `ECLIPT-TX-001`, `ECLIPT-UPGRADE-001`

---

## 1. Executive Summary

Ecliptica implements a **multi-layered MEV protection strategy** combining:

- **Encrypted Mempools**: Transactions remain encrypted until block inclusion
- **Time-Locked Encryption**: Threshold decryption prevents early access
- **Fair Sequencing Service (FSS)**: Deterministic transaction ordering
- **Commit-Reveal Scheme**: Two-phase transaction submission
- **Leader Rotation VRF**: Unpredictable validator selection
- **MEV Redistribution**: Auction mechanisms return value to users

**Design Goals:**
- Eliminate front-running and sandwich attacks
- Minimize validator/searcher advantages
- Preserve privacy during transaction submission
- Maintain high throughput (minimal overhead)
- Post-quantum security for all cryptographic primitives

**Performance Targets:**
- MEV protection overhead: <5% latency increase
- Throughput degradation: <3%
- Encrypted mempool size: <2√ó plaintext equivalent

---

## 2. MEV Threat Model

### 2.1 Attack Vectors

| Attack Type             | Description                               | Attacker           | Traditional Mitigation    | Ecliptica Solution                |
| ----------------------- | ----------------------------------------- | ------------------ | ------------------------- | --------------------------------- |
| **Front-Running**       | Submit tx ahead of victim with higher fee | Searcher/Validator | Flashbots, private relays | Encrypted mempool + FSS           |
| **Back-Running**        | Submit tx immediately after victim        | Searcher           | Time-weighted ordering    | Commit-reveal + FSS               |
| **Sandwich Attack**     | Front + back run victim's trade           | Searcher           | DEX design changes        | Encrypted mempool + commit-reveal |
| **Time-Bandit Attack**  | Reorg blocks to extract MEV               | Validator          | Short finality time       | BFT finality (64 blocks)          |
| **Uncle-Bandit Attack** | Publish uncle blocks with MEV             | Validator          | N/A (PoS)                 | No uncle blocks in BFT            |
| **Validator Front-Run** | Leader sees mempool, self-front-runs      | Validator          | Leader rotation           | Encrypted mempool                 |
| **Censorship**          | Exclude high-MEV txs for later inclusion  | Validator          | Inclusion lists           | Mandatory inclusion rules         |

### 2.2 MEV Extraction Examples

**Example 1: DEX Arbitrage**
```
Mempool: User swaps 1000 ETH ‚Üí USDC on Uniswap
Searcher sees: Detects price impact
Searcher front-runs: Buys USDC before user
User executes: Gets worse price
Searcher back-runs: Sells USDC at profit

MEV extracted: ~2-5% of trade value
```

**Example 2: Liquidation**
```
Mempool: User's collateralized position becomes liquidatable
Searcher sees: Health factor < 1.0
Searcher front-runs: Submits liquidation before others
User loses: 10% liquidation penalty to searcher

MEV extracted: Liquidation penalty
```

### 2.3 Privacy Leakage as MEV Enabler

**Critical Insight:** Public mempools enable MEV because:
1. Transaction content visible before inclusion
2. Ordering known in advance
3. State changes predictable

**Ecliptica's Approach:** **Encrypt everything until inclusion**

---

## 3. Encrypted Mempool Architecture

### 3.1 Time-Locked Encryption (Threshold)

**Cryptographic Primitive:** Time-lock puzzles + threshold cryptography

```rust
struct EncryptedTransaction {
    // Identity
    tx_id: [u8; 32],                    // Hash of encrypted payload
    
    // Encrypted content
    encrypted_payload: Vec<u8>,         // ML-KEM encrypted transaction
    
    // Time-lock parameters
    time_lock_height: u64,              // Decrypt after this height
    threshold_shares: Vec<ThresholdShare>, // k-of-n decryption
    
    // Metadata (revealed)
    sender: Address,                    // Public (for nonce ordering)
    nonce: u64,                         // Public (replay protection)
    shard: u8,                          // Routing information
    gas_limit: u64,                     // Public (DOS protection)
    priority_fee: u64,                  // Public (ordering)
    
    // Commitment (prevents tampering)
    payload_commitment: [u8; 32],       // SHAKE-256(payload)
    
    // Signature
    signature: DilithiumSignature,      // Signs entire structure
}

struct ThresholdShare {
    share_index: u8,                    // 1..n
    validator_pubkey: [u8; 1952],       // ML-DSA pubkey
    encrypted_share: Vec<u8>,           // Share encrypted to validator
}
```

**Key Properties:**
- **Threshold Decryption**: Requires k-of-n validators to decrypt (e.g., 67 of 100)
- **Post-Quantum**: Uses ML-KEM for encryption, ML-DSA for signatures
- **Time-Locked**: Cannot decrypt until block height reached
- **Verifiable**: Commitment allows verification without decryption

### 3.2 Encryption Protocol

**Step 1: User Encrypts Transaction**

```rust
fn encrypt_transaction(
    tx: &Transaction,
    validator_set: &[ValidatorPubkey],
    time_lock_height: u64,
    threshold: u8,
) -> Result<EncryptedTransaction> {
    // 1. Serialize transaction
    let payload = serialize_canonical(tx);
    
    // 2. Generate ephemeral secret
    let secret = generate_secret();
    
    // 3. Split secret using Shamir's Secret Sharing
    let shares = shamirs_split(secret, threshold, validator_set.len());
    
    // 4. Encrypt payload with secret
    let encrypted_payload = aes_gcm_encrypt(&payload, &secret);
    
    // 5. Encrypt each share to corresponding validator
    let threshold_shares: Vec<ThresholdShare> = shares
        .into_iter()
        .zip(validator_set.iter())
        .map(|(share, validator_pubkey)| ThresholdShare {
            share_index: share.index,
            validator_pubkey: *validator_pubkey,
            encrypted_share: mlkem_encrypt(validator_pubkey, &share.data),
        })
        .collect();
    
    // 6. Compute commitment
    let payload_commitment = shake256(&payload);
    
    // 7. Create encrypted transaction
    let encrypted_tx = EncryptedTransaction {
        tx_id: shake256(&encrypted_payload),
        encrypted_payload,
        time_lock_height,
        threshold_shares,
        sender: tx.from(),
        nonce: tx.nonce(),
        shard: tx.shard(),
        gas_limit: tx.gas_limit(),
        priority_fee: tx.priority_fee(),
        payload_commitment,
        signature: sign_encrypted_tx(&tx_data, tx.signer_sk()),
    };
    
    Ok(encrypted_tx)
}
```

**Step 2: Validators Decrypt at Block Height**

```rust
fn decrypt_transaction(
    encrypted_tx: &EncryptedTransaction,
    current_height: u64,
    validator_sk: &MLKEMSecretKey,
    validator_index: u8,
) -> Result<Option<Vec<u8>>> {
    // 1. Check if time-lock reached
    if current_height < encrypted_tx.time_lock_height {
        return Ok(None);
    }
    
    // 2. Find this validator's share
    let share = encrypted_tx.threshold_shares
        .iter()
        .find(|s| s.share_index == validator_index)
        .ok_or(Error::ShareNotFound)?;
    
    // 3. Decrypt share
    let decrypted_share = mlkem_decrypt(validator_sk, &share.encrypted_share)?;
    
    // 4. Broadcast share to other validators
    broadcast_decryption_share(DecryptionShare {
        tx_id: encrypted_tx.tx_id,
        share_index: validator_index,
        share_data: decrypted_share,
        signature: sign_share(&decrypted_share, validator_sk),
    })?;
    
    Ok(Some(decrypted_share))
}

fn reconstruct_transaction(
    encrypted_tx: &EncryptedTransaction,
    shares: Vec<DecryptionShare>,
    threshold: u8,
) -> Result<Transaction> {
    // 1. Verify we have enough shares
    if shares.len() < threshold as usize {
        return Err(Error::InsufficientShares);
    }
    
    // 2. Reconstruct secret using Shamir's
    let secret = shamirs_reconstruct(&shares[..threshold as usize]);
    
    // 3. Decrypt payload
    let payload = aes_gcm_decrypt(&encrypted_tx.encrypted_payload, &secret)?;
    
    // 4. Verify commitment
    if shake256(&payload) != encrypted_tx.payload_commitment {
        return Err(Error::CommitmentMismatch);
    }
    
    // 5. Deserialize transaction
    let tx = deserialize_transaction(&payload)?;
    
    Ok(tx)
}
```

### 3.3 Mempool Workflow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    USER     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 1. Encrypt tx
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   ENCRYPTED MEMPOOL         ‚îÇ
‚îÇ                             ‚îÇ
‚îÇ  tx_encrypted_1 (height+2)  ‚îÇ
‚îÇ  tx_encrypted_2 (height+2)  ‚îÇ
‚îÇ  tx_encrypted_3 (height+3)  ‚îÇ
‚îÇ  ...                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 2. At height reached
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  THRESHOLD DECRYPTION       ‚îÇ
‚îÇ  (k-of-n validators)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 3. Reconstruct tx
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FAIR SEQUENCING SERVICE    ‚îÇ
‚îÇ  (deterministic ordering)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 4. Include in block
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      BLOCK N                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4. Fair Sequencing Service (FSS)

### 4.1 Ordering Algorithm

**Goal:** Deterministic, manipulation-resistant transaction ordering

**Ordering Criteria (Priority):**

1. **Time-lock height** (earlier = higher priority)
2. **Priority fee** (higher = higher priority)
3. **First-seen timestamp** (earlier = higher priority)
4. **Transaction hash** (deterministic tiebreaker)

```rust
struct OrderingMetadata {
    tx_id: [u8; 32],
    time_lock_height: u64,
    priority_fee: u64,
    first_seen: Timestamp,
    tx_hash: [u8; 32],
}

impl Ord for OrderingMetadata {
    fn cmp(&self, other: &Self) -> Ordering {
        // 1. Earlier time-lock first
        match self.time_lock_height.cmp(&other.time_lock_height) {
            Ordering::Equal => {},
            ord => return ord,
        }
        
        // 2. Higher fee first
        match other.priority_fee.cmp(&self.priority_fee) {
            Ordering::Equal => {},
            ord => return ord,
        }
        
        // 3. Earlier first-seen first
        match self.first_seen.cmp(&other.first_seen) {
            Ordering::Equal => {},
            ord => return ord,
        }
        
        // 4. Deterministic tiebreaker
        self.tx_hash.cmp(&other.tx_hash)
    }
}

fn order_transactions(txs: Vec<Transaction>) -> Vec<Transaction> {
    let mut metadata: Vec<OrderingMetadata> = txs
        .iter()
        .map(|tx| OrderingMetadata {
            tx_id: tx.id(),
            time_lock_height: tx.time_lock_height(),
            priority_fee: tx.priority_fee(),
            first_seen: tx.first_seen_timestamp(),
            tx_hash: compute_tx_hash(tx),
        })
        .collect();
    
    // Sort by ordering rules
    metadata.sort();
    
    // Return transactions in sorted order
    metadata.into_iter()
        .map(|meta| txs.iter().find(|tx| tx.id() == meta.tx_id).unwrap().clone())
        .collect()
}
```

### 4.2 First-Seen Timestamp Protocol

**Challenge:** Validators may disagree on first-seen time

**Solution:** Consensus-based timestamp using median

```rust
struct TimestampVote {
    tx_id: [u8; 32],
    timestamp: u64,                     // Microseconds since epoch
    validator: Address,
    signature: DilithiumSignature,
}

fn determine_consensus_timestamp(
    tx_id: [u8; 32],
    votes: Vec<TimestampVote>,
) -> u64 {
    // Verify signatures
    let valid_votes: Vec<_> = votes.into_iter()
        .filter(|v| verify_signature(&v.signature, &v.validator))
        .collect();
    
    // Require quorum (‚â•2/3)
    if valid_votes.len() < (2 * total_validators() / 3) {
        return 0;  // Insufficient votes
    }
    
    // Use median timestamp (resistant to outliers)
    let mut timestamps: Vec<_> = valid_votes.iter().map(|v| v.timestamp).collect();
    timestamps.sort();
    
    timestamps[timestamps.len() / 2]
}
```

### 4.3 Batch Auctions (Optional Enhancement)

**Frequent Batch Auctions (FBA):** Transactions batched every N milliseconds

```rust
struct BatchAuction {
    batch_id: u64,
    batch_window: Duration,             // e.g., 100ms
    txs: Vec<Transaction>,
    
    // Ordering within batch
    ordering_seed: [u8; 32],            // VRF output
}

fn conduct_batch_auction(
    batch_window_start: Instant,
    batch_window_end: Instant,
) -> BatchAuction {
    // 1. Collect all txs submitted in window
    let txs = collect_txs_in_window(batch_window_start, batch_window_end);
    
    // 2. Generate deterministic ordering seed
    let ordering_seed = generate_vrf_seed(batch_window_end);
    
    // 3. Shuffle deterministically within same fee tier
    let ordered_txs = shuffle_by_seed(&txs, &ordering_seed);
    
    BatchAuction {
        batch_id: (batch_window_end.elapsed().as_millis() / 100) as u64,
        batch_window: batch_window_end - batch_window_start,
        txs: ordered_txs,
        ordering_seed,
    }
}

fn shuffle_by_seed(txs: &[Transaction], seed: &[u8; 32]) -> Vec<Transaction> {
    let mut rng = ChaCha20Rng::from_seed(*seed);
    let mut shuffled = txs.to_vec();
    shuffled.shuffle(&mut rng);
    shuffled
}
```

---

## 5. Commit-Reveal Scheme

### 5.1 Two-Phase Submission

**Phase 1: Commit**

User submits commitment to transaction without revealing content.

```rust
struct TransactionCommitment {
    // Commitment
    commitment: [u8; 32],               // SHAKE-256(tx || salt)
    
    // Metadata (public)
    sender: Address,
    nonce: u64,
    max_fee: u64,
    
    // Reveal deadline
    reveal_height: u64,                 // Must reveal by this height
    
    // Signature
    signature: DilithiumSignature,
}

fn commit_transaction(
    tx: &Transaction,
    reveal_delay: u64,
) -> TransactionCommitment {
    let salt = generate_random_salt();
    
    let commitment = shake256(&[
        serialize_canonical(tx).as_slice(),
        &salt,
    ].concat());
    
    TransactionCommitment {
        commitment,
        sender: tx.from(),
        nonce: tx.nonce(),
        max_fee: tx.max_fee(),
        reveal_height: current_height() + reveal_delay,
        signature: sign_commitment(&commitment, tx.signer_sk()),
    }
}
```

**Phase 2: Reveal**

User reveals actual transaction after commit is included.

```rust
struct TransactionReveal {
    // Original commitment
    commitment: [u8; 32],
    
    // Revealed content
    tx: Transaction,
    salt: [u8; 32],
    
    // Proof
    merkle_proof: Vec<[u8; 32]>,        // Commitment was included
    inclusion_height: u64,
}

fn reveal_transaction(
    commitment: &TransactionCommitment,
    tx: Transaction,
    salt: [u8; 32],
) -> Result<TransactionReveal> {
    // 1. Verify commitment matches
    let computed_commitment = shake256(&[
        serialize_canonical(&tx).as_slice(),
        &salt,
    ].concat());
    
    if computed_commitment != commitment.commitment {
        return Err(Error::CommitmentMismatch);
    }
    
    // 2. Verify within reveal window
    let current = current_height();
    if current > commitment.reveal_height {
        return Err(Error::RevealDeadlineExpired);
    }
    
    // 3. Get Merkle proof of commitment inclusion
    let merkle_proof = get_commitment_merkle_proof(commitment.commitment)?;
    
    Ok(TransactionReveal {
        commitment: commitment.commitment,
        tx,
        salt,
        merkle_proof,
        inclusion_height: current,
    })
}
```

### 5.2 Commit-Reveal Timeline

```
Block N:     User submits commitment
             (Transaction content hidden)
             
Block N+1:   Commitment included in block
             (On-chain, immutable)
             
Block N+2:   User reveals transaction
             (Verified against commitment)
             
Block N+3:   Transaction executed
             (Ordering based on N+1 inclusion)
```

**Benefits:**
- Front-running impossible (content unknown at inclusion time)
- Ordering determined by commitment, not reveal
- User retains option to not reveal (griefing mitigation)

**Griefing Mitigation:**

```rust
fn penalize_non_reveal(commitment: &TransactionCommitment) {
    let current = current_height();
    
    // Check if reveal deadline expired
    if current > commitment.reveal_height + GRACE_PERIOD {
        // Burn a small penalty from sender's account
        burn_from_account(commitment.sender, NON_REVEAL_PENALTY)?;
        
        // Remove commitment from pending
        remove_commitment(commitment.commitment);
    }
}

const NON_REVEAL_PENALTY: u64 = 1_000 * ECLIPT_PER_COIN;  // Small penalty
const GRACE_PERIOD: u64 = 64;  // Additional blocks allowed
```

---

## 6. Leader Selection & Rotation

### 6.1 VRF-Based Leader Selection

**Goal:** Unpredictable, verifiable leader rotation

**Cryptographic Primitive:** Verifiable Random Function (VRF)

```rust
struct LeaderSelection {
    epoch: u64,
    slot: u64,
    
    // VRF proof
    vrf_proof: VRFProof,
    vrf_output: [u8; 32],
    
    // Selected leader
    leader: Address,
}

fn select_leader(
    epoch: u64,
    slot: u64,
    validators: &[ValidatorInfo],
) -> LeaderSelection {
    // 1. Get beacon randomness (from previous epoch)
    let beacon_randomness = get_beacon_randomness(epoch - 1);
    
    // 2. Each validator computes VRF
    let vrf_inputs = [
        &epoch.to_le_bytes(),
        &slot.to_le_bytes(),
        &beacon_randomness,
    ].concat();
    
    // 3. Validators with lowest VRF output wins
    let mut leader_scores: Vec<_> = validators.iter()
        .map(|v| {
            let (vrf_output, vrf_proof) = vrf_eval(&v.vrf_sk, &vrf_inputs);
            (v.address, vrf_output, vrf_proof, v.stake)
        })
        .collect();
    
    // 4. Weight by stake (higher stake = lower threshold)
    leader_scores.sort_by_key(|(addr, output, _, stake)| {
        let weighted_output = (output[0] as u64) * TOTAL_STAKE / stake;
        weighted_output
    });
    
    let (leader, vrf_output, vrf_proof, _) = leader_scores[0];
    
    LeaderSelection {
        epoch,
        slot,
        vrf_proof,
        vrf_output,
        leader,
    }
}
```

**VRF Properties:**
- **Unpredictable**: Cannot predict future leaders
- **Verifiable**: Anyone can verify VRF proof
- **Non-interactive**: No coordination needed
- **Post-Quantum**: Use hash-based VRF construction

### 6.2 Hash-Based VRF (Post-Quantum)

**Construction:** HMAC-SHA3 + Merkle proof

```rust
struct HashVRF {
    // Input
    input: Vec<u8>,
    
    // Secret key
    sk: [u8; 32],
    
    // Output
    output: [u8; 32],
    
    // Proof (Merkle path from output to public commitment)
    merkle_proof: Vec<[u8; 32]>,
}

impl HashVRF {
    fn eval(sk: &[u8; 32], input: &[u8]) -> ([u8; 32], Vec<[u8; 32]>) {
        // 1. Compute HMAC-SHA3
        let output = hmac_sha3(sk, input);
        
        // 2. Generate Merkle proof
        let merkle_tree = build_vrf_merkle_tree(sk);
        let merkle_proof = merkle_tree.get_proof(&output);
        
        (output, merkle_proof)
    }
    
    fn verify(
        pk: &[u8; 32],          // Public key (root of Merkle tree)
        input: &[u8],
        output: &[u8; 32],
        proof: &[[u8; 32]],
    ) -> bool {
        // Verify Merkle proof
        verify_merkle_path(output, proof, pk)
    }
}
```

### 6.3 Leader Rotation Schedule

```rust
fn generate_rotation_schedule(
    epoch: u64,
    slots_per_epoch: u64,
    validators: &[ValidatorInfo],
) -> Vec<LeaderSelection> {
    (0..slots_per_epoch)
        .map(|slot| select_leader(epoch, slot, validators))
        .collect()
}

fn verify_leader_eligibility(
    block: &Block,
    expected_leader: &LeaderSelection,
) -> Result<()> {
    // 1. Verify proposer matches expected leader
    if block.proposer != expected_leader.leader {
        return Err(Error::InvalidProposer);
    }
    
    // 2. Verify VRF proof
    let validator = get_validator(block.proposer)?;
    if !HashVRF::verify(
        &validator.vrf_pk,
        &vrf_input(expected_leader.epoch, expected_leader.slot),
        &expected_leader.vrf_output,
        &expected_leader.vrf_proof,
    ) {
        return Err(Error::InvalidVRFProof);
    }
    
    Ok(())
}
```

---

## 7. MEV Redistribution Mechanisms

### 7.1 MEV Auction (Optional)

**Concept:** Validators auction block construction rights; proceeds shared with users

```rust
struct MEVAuction {
    block_height: u64,
    
    // Bids
    bids: Vec<MEVBid>,
    
    // Winner
    winner: Option<Address>,
    winning_bid: u64,
}

struct MEVBid {
    searcher: Address,
    bid_amount: u64,                    // ECLIPT offered
    
    // Proposed block template
    block_template: Vec<Transaction>,
    expected_mev: u64,
    
    // Payment split
    user_share: f64,                    // % to affected users
    validator_share: f64,               // % to validators
    protocol_share: f64,                // % burned
    
    signature: DilithiumSignature,
}

fn conduct_mev_auction(block_height: u64) -> MEVAuction {
    let bids = collect_mev_bids(block_height);
    
    // Select highest bid
    let winner = bids.iter()
        .max_by_key(|bid| bid.bid_amount)
        .cloned();
    
    if let Some(winning_bid) = &winner {
        // Distribute proceeds
        distribute_mev_proceeds(winning_bid)?;
    }
    
    MEVAuction {
        block_height,
        bids,
        winner: winner.as_ref().map(|b| b.searcher),
        winning_bid: winner.map(|b| b.bid_amount).unwrap_or(0),
    }
}

fn distribute_mev_proceeds(bid: &MEVBid) -> Result<()> {
    let user_amount = (bid.bid_amount as f64 * bid.user_share) as u64;
    let validator_amount = (bid.bid_amount as f64 * bid.validator_share) as u64;
    let protocol_amount = bid.bid_amount - user_amount - validator_amount;
    
    // Pay affected users
    for (user, impact) in compute_mev_impact(&bid.block_template) {
        let user_payout = (user_amount as f64 * impact) as u64;
        transfer(bid.searcher, user, user_payout)?;
    }
    
    // Pay validators
    distribute_to_validators(bid.searcher, validator_amount)?;
    
    // Burn protocol share
    burn(bid.searcher, protocol_amount)?;
    
    Ok(())
}
```

### 7.2 MEV Smoothing (User Protection)

**Concept:** Aggregate MEV across many blocks, distribute to users

```rust
struct MEVSmoothingPool {
    // Accumulated MEV
    total_mev_collected: u64,
    collection_period: u64,             // Epochs
    
    // Beneficiaries (users affected by MEV)
    beneficiaries: HashMap<Address, MEVImpact>,
}

struct MEVImpact {
    user: Address,
    txs_affected: u64,
    estimated_loss: u64,                // How much MEV extracted from user
}

fn distribute_smoothed_mev(pool: &mut MEVSmoothingPool) -> Result<()> {
    let total_impact: u64 = pool.beneficiaries.values()
        .map(|impact| impact.estimated_loss)
        .sum();
    
    // Proportional distribution
    for (user, impact) in pool.beneficiaries.iter() {
        let share = (pool.total_mev_collected as f64 
            * impact.estimated_loss as f64 
            / total_impact as f64) as u64;
        
        transfer(MEV_POOL_ADDRESS, user, share)?;
    }
    
    // Reset pool
    pool.total_mev_collected = 0;
    pool.beneficiaries.clear();
    
    Ok(())
}
```

---

## 8. Implementation Phases

### 8.1 Phase 1: Encrypted Mempool (Mainnet v1.0)

**Features:**
- Basic threshold encryption
- Time-locked decryption
- Commit-reveal for sensitive transactions

**Performance Target:**
- Overhead: <5%
- Decryption latency: <200ms

### 8.2 Phase 2: Fair Sequencing (Mainnet v1.1)

**Features:**
- FSS with consensus timestamps
- Deterministic ordering algorithm
- First-seen protocol

**Performance Target:**
- Ordering determinism: 100%
- Timestamp consensus: <500ms

### 8.3 Phase 3: MEV Redistribution (Mainnet v1.2)

**Features:**
- MEV auction marketplace
- User rebates for MEV impact
- Smoothing pool

**Performance Target:**
- Auction participation: >50% of blocks
- User rebate rate: >80% of MEV

---

## 9. Privacy-MEV Tradeoffs

### 9.1 Unavoidable MEV

**Even with encrypted mempools, some MEV remains:**

| MEV Type                  | Preventable? | Reasoning                                |
| ------------------------- | ------------ | ---------------------------------------- |
| Arbitrage (across chains) | ‚ùå            | Price information public on other chains |
| Liquidations              | ‚ùå            | Health factors visible on-chain          |
| Sandwich attacks          | ‚úÖ            | Prevented by encrypted mempool           |
| Front-running             | ‚úÖ            | Prevented by encrypted mempool           |
| Back-running              | ‚ö†Ô∏è            | Reduced but not eliminated               |

### 9.2 Privacy Budget

**Revealed Information:**

```rust
struct TransactionPrivacyBudget {
    // Always revealed
    sender: Address,                    // Required for nonce
    nonce: u64,                         // Replay protection
    gas_limit: u64,                     // DOS protection
    priority_fee: u64,                  // Ordering
    
    // Never revealed (until execution)
    recipient: Option<Address>,         // Hidden
    amount: Option<u64>,                // Hidden
    contract_call_data: Option<Vec<u8>>, // Hidden
    
    // Privacy level
    privacy_level: PrivacyLevel,
}

enum PrivacyLevel {
    Maximum,        // All data encrypted
    Balanced,       // Recipient visible, amount hidden
    Minimal,        // Only call data hidden
    Public,         // Traditional transparent transaction
}
```

### 9.3 User Choice

**Users select privacy-MEV tradeoff:**

```rust
fn create_transaction_with_privacy(
    tx: Transaction,
    privacy_level: PrivacyLevel,
) -> EncryptedTransaction {
    match privacy_level {
        PrivacyLevel::Maximum => {
            // Full encryption + commit-reveal
            // Highest protection, +2 block latency
            encrypt_full(tx)
        },
        
        PrivacyLevel::Balanced => {
            // Encrypt amount only
            // Medium protection, +1 block latency
            encrypt_amount(tx)
        },
        
        PrivacyLevel::Minimal => {
            // Encrypt call data only
            // Basic protection, minimal latency
            encrypt_calldata(tx)
        },
        
        PrivacyLevel::Public => {
            // No encryption
            // No protection, zero latency
            tx.into()
        },
    }
}
```

---

## 10. Attack Mitigation Summary

| Attack                         | Mitigation                      | Effectiveness | Overhead     |
| ------------------------------ | ------------------------------- | ------------- | ------------ |
| **Front-running**              | Encrypted mempool + time-lock   | 99%           | <5% latency  |
| **Sandwich**                   | Encrypted mempool + FSS         | 99%           | <5% latency  |
| **Back-running**               | Commit-reveal + batch auctions  | 90%           | <10% latency |
| **Validator self-dealing**     | VRF leader selection + slashing | 95%           | <2% latency  |
| **Censorship**                 | Inclusion lists + timeouts      | 80%           | <3% latency  |
| **Time-bandit**                | BFT finality (64 blocks)        | 99%           | Built-in     |
| **Flashbots-style private tx** | Native encrypted mempool        | 100%          | <5% latency  |

---

## 11. Monitoring & Analytics

### 11.1 MEV Detection Metrics

```rust
struct MEVMetrics {
    // Detected MEV
    arbitrage_detected: u64,            // # of arb transactions
    liquidations_detected: u64,         // # of liquidations
    sandwich_attempts: u64,             // # detected (should be 0)
    
    // Protection effectiveness
    encrypted_tx_ratio: f64,            // % of txs using encryption
    commit_reveal_ratio: f64,           // % using commit-reveal
    
    // Redistribution
    mev_redistributed: u64,             // ECLIPT returned to users
    users_compensated: u64,             // # of users receiving rebates
    
    // Validator behavior
    leader_rotation_fairness: f64,      // Entropy of leader selection
    censorship_incidents: u64,          // # of txs delayed >10 blocks
}
```

### 11.2 Public Dashboard

```json
{
  "mev_protection": {
    "encrypted_mempool_active": true,
    "encryption_rate": 0.87,
    "average_decryption_time_ms": 180,
    
    "detected_attacks": {
      "front_run_attempts": 0,
      "sandwich_attempts": 0,
      "back_run_attempts": 3,
      "censorship_incidents": 1
    },
    
    "redistribution": {
      "total_mev_extracted": "1250000",
      "user_rebates_paid": "1000000",
      "protocol_burned": "250000",
      "users_compensated": 847
    },
    
    "leader_selection": {
      "vrf_fairness_score": 0.98,
      "rotation_predictability": 0.02,
      "validator_participation": 0.94
    }
  }
}
```

---

## 12. Research Directions

### 12.1 Open Problems

1. **Optimal Decryption Timing**: Balance between privacy and latency
2. **Cross-Shard MEV**: MEV spanning multiple shards
3. **Post-Quantum VRF**: Efficient PQ-secure VRF construction
4. **MEV Quantification**: Accurate measurement of extracted MEV
5. **Incentive Compatibility**: Game-theoretic analysis of MEV mechanisms

### 12.2 Future Enhancements

**Threshold ECDSA ‚Üí Threshold ML-DSA**
- Current: Shamir Secret Sharing
- Future: Threshold ML-DSA signature (more efficient)

**Programmable Privacy**
- Smart contract-level privacy controls
- Per-function encryption policies

**Verifiable Delay Functions (VDF)**
- Replace time-locks with VDFs
- Provably sequential computation

**TEE-Assisted Decryption**
- Hardware enclaves for faster decryption
- SGX or TrustZone integration (with remote attestation)

---

## Appendix A: Threat Scenarios & Responses

### Scenario 1: Nation-State Validator Compromise

**Attack:** Adversary controls 30% of validators

**Response:**
- Threshold = 67% (still safe)
- Rotate validator set every epoch
- Geographic distribution requirements
- Multi-jurisdiction validation

### Scenario 2: Timing Analysis

**Attack:** Observe network traffic patterns to infer transaction content

**Response:**
- Dummy transactions (padding)
- Fixed-size encrypted payloads
- Random delays in submission
- Tor/mixnet integration

### Scenario 3: Validator Collusion

**Attack:** k validators collude to decrypt early

**Response:**
- Slashing for early decryption attempts
- Proof of time-lock respect (zero-knowledge)
- Economic disincentives (loss of future MEV revenue)
- Whistleblower rewards

---

## Appendix B: Performance Benchmarks

```rust
#[cfg(test)]
mod benchmarks {
    #[bench]
    fn bench_encrypt_transaction(b: &mut Bencher) {
        let tx = create_test_transaction();
        let validators = generate_validator_set(100);
        
        b.iter(|| {
            encrypt_transaction(&tx, &validators, 67)
        });
    }
    // Result: ~2.5ms (threshold=67, n=100)
    
    #[bench]
    fn bench_decrypt_share(b: &mut Bencher) {
        let encrypted_tx = create_encrypted_transaction();
        let validator_sk = generate_validator_key();
        
        b.iter(|| {
            decrypt_transaction(&encrypted_tx, &validator_sk, 0)
        });
    }
    // Result: ~0.8ms (ML-KEM decryption)
    
    #[bench]
    fn bench_vrf_eval(b: &mut Bencher) {
        let vrf_sk = generate_vrf_key();
        let input = b"test_input";
        
        b.iter(|| {
            HashVRF::eval(&vrf_sk, input)
        });
    }
    // Result: ~0.15ms (hash-based VRF)
}
```

---

**Document ID:** `ECLIPT-MEV-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review