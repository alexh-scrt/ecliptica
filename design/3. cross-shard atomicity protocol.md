# ðŸŒ‰ **Ecliptica Cross-Shard Atomicity Protocol**

### *Post-Quantum Secure Two-Phase Commit for Sharded Privacy-Preserving Blockchain*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-XSHARD-001`  
**Depends On:** `ECLIPT-STATE-001`, `ECLIPT-TX-001`

---

## 1. Executive Summary

Ecliptica's cross-shard protocol enables **atomic transfers** between shards while maintaining:

- **Atomicity**: Either all shards commit or all abort (no partial states)
- **Privacy**: Amounts remain encrypted throughout the protocol
- **Post-Quantum Security**: All proofs and signatures use ML-DSA and ML-KEM
- **Deadlock Freedom**: Deterministic timeout-based resolution
- **Byzantine Tolerance**: Resilient to f < N/3 malicious validators per shard

The protocol uses a **distributed two-phase commit (2PC)** coordinated by the **Beacon Chain**, with cryptographic receipts enabling asynchronous verification across shards.

**Performance Targets:**
- Cross-shard latency: 1-2 seconds (2-4 block epochs)
- Throughput degradation: <15% vs single-shard
- Maximum simultaneous cross-shard transactions: 10,000

---

## 2. Architecture Overview

### 2.1 Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Beacon Chain                          â”‚
â”‚  - Global State Root Aggregator                          â”‚
â”‚  - Cross-Shard Receipt Registry                          â”‚
â”‚  - Timeout Coordinator                                   â”‚
â”‚  - Finality Proof Aggregator (zk-STARK)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚                      â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Shard A       â”‚    â”‚   Shard B      â”‚
    â”‚  (Source)       â”‚    â”‚ (Destination)  â”‚
    â”‚                 â”‚    â”‚                â”‚
    â”‚  - Lock funds   â”‚    â”‚  - Verify      â”‚
    â”‚  - Emit receipt â”‚    â”‚    receipt     â”‚
    â”‚  - Timeout mgmt â”‚    â”‚  - Credit fundsâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Protocol Phases

| Phase           | Shard A (Source)         | Shard B (Dest)         | Beacon Chain         |
| --------------- | ------------------------ | ---------------------- | -------------------- |
| **0: Initiate** | User submits XShardTx    | -                      | -                    |
| **1: Prepare**  | Lock funds, emit receipt | -                      | Register receipt     |
| **2: Verify**   | -                        | Verify receipt proof   | Provide Merkle proof |
| **3: Commit**   | -                        | Credit funds, emit ack | Record ack           |
| **4: Finalize** | Release lock             | -                      | Aggregate finality   |
| **Timeout**     | Refund locked funds      | -                      | Mark receipt expired |

---

## 3. Detailed Two-Phase Commit Protocol

### 3.1 Data Structures

```rust
/// Cross-shard transaction envelope
struct CrossShardTransaction {
    // Unique identifier
    xshard_id: XShardId,              // 32-byte unique ID
    
    // Routing
    source_shard: u8,
    dest_shard: u8,
    
    // Phases
    phase1_tx: Phase1Transaction,      // PREPARE on source
    phase2_tx: Option<Phase2Transaction>, // COMMIT on dest
    
    // Timeouts
    phase1_timeout: u64,               // Block height deadline
    phase2_timeout: u64,               // Block height deadline
    
    // Coordination
    beacon_checkpoint: u64,            // Beacon height at initiation
}

/// Phase 1: Lock funds on source shard
struct Phase1Transaction {
    // Standard account tx fields
    from: Address,                     // Sender on source shard
    nonce: u64,
    
    // Cross-shard specific
    to_shard: u8,                      // Destination shard ID
    to_address: Address,               // Recipient on dest shard
    
    // Encrypted amount
    encrypted_amount: Ciphertext,      // ML-KEM encrypted
    amount_commitment: [u8; 32],       // Hiding commitment
    
    // Proof of valid balance
    balance_proof: STARKProof,
    
    // Authorization
    signature: DilithiumSignature,     // Sender's signature
    
    // Lock parameters
    lock_duration: u64,                // Blocks to hold lock
}

/// Receipt emitted by source shard
struct CrossShardReceipt {
    // Identity
    receipt_id: [u8; 32],              // Unique receipt ID
    xshard_id: XShardId,               // Parent transaction ID
    
    // Routing
    source_shard: u8,
    source_height: u64,                // Block height at emission
    dest_shard: u8,
    
    // Locked funds
    locked_amount_commitment: [u8; 32], // Commitment to amount
    encrypted_amount: Ciphertext,       // For recipient decryption
    recipient: Address,
    
    // Proof of lock
    lock_proof: LockProof,             // Proves funds escrowed
    
    // Timeout
    expiry_height: u64,                // Absolute deadline
    
    // Commitment (prevents tampering)
    receipt_commitment: [u8; 32],      // SHAKE-256(all fields)
}

/// Proof that funds are locked in escrow
struct LockProof {
    // Account state before
    pre_balance_commitment: [u8; 32],
    pre_locked_balance: u64,           // Plaintext for verification
    
    // Account state after
    post_balance_commitment: [u8; 32],
    post_locked_balance: u64,
    
    // zk-STARK proving:
    // 1. pre_balance >= amount + fee
    // 2. post_balance = pre_balance - amount
    // 3. post_locked = pre_locked + amount
    proof: STARKProof,
}

/// Phase 2: Credit funds on destination shard
struct Phase2Transaction {
    // Receipt reference
    receipt_id: [u8; 32],
    receipt_commitment: [u8; 32],
    
    // Merkle proof from source shard
    receipt_merkle_proof: ReceiptMerkleProof,
    
    // Beacon attestation
    beacon_signature: DilithiumSignature, // Beacon validates receipt
    beacon_height: u64,
    
    // Destination account
    to_address: Address,
    
    // Re-encrypted amount (for recipient)
    reencrypted_amount: Ciphertext,     // Encrypted under dest pubkey
    
    // Proof of consistent re-encryption
    reencryption_proof: STARKProof,
}

/// Merkle proof of receipt inclusion
struct ReceiptMerkleProof {
    // Receipt Merkle tree from source shard
    receipt_root: [u8; 32],            // Root at source_height
    receipt_index: u32,
    merkle_path: Vec<[u8; 32]>,        // Siblings from leaf to root
    
    // State root attestation
    source_state_root: [u8; 32],       // Full shard state root
    state_proof: SMTProof,             // Receipt tree âŠ† state root
}

/// Acknowledgment from destination shard
struct CrossShardAck {
    receipt_id: [u8; 32],
    dest_shard: u8,
    dest_height: u64,
    status: AckStatus,
}

enum AckStatus {
    Committed,    // Funds credited successfully
    Rejected,     // Invalid receipt or proof
}
```

### 3.2 Phase 1: PREPARE (Source Shard)

**Step 1.1: User Initiates Cross-Shard Transfer**

```rust
fn initiate_cross_shard_transfer(
    sender: Address,
    sender_sk: SecretKey,
    from_shard: u8,
    to_shard: u8,
    recipient: Address,
    amount: u64,
    state: &State,
) -> Result<CrossShardTransaction> {
    // Generate unique ID
    let xshard_id = generate_xshard_id(&sender, state.nonce(sender));
    
    // Encrypt amount for recipient
    let recipient_pk = get_public_key(recipient, to_shard)?;
    let encrypted_amount = mlkem_encrypt(recipient_pk, &amount.to_le_bytes());
    
    // Create hiding commitment
    let amount_commitment = commit_amount(amount, random_scalar());
    
    // Generate balance proof (zk-STARK)
    let balance_proof = prove_sufficient_balance(
        sender,
        amount,
        state.get_account(sender),
    )?;
    
    // Construct Phase 1 transaction
    let phase1_tx = Phase1Transaction {
        from: sender,
        nonce: state.nonce(sender) + 1,
        to_shard,
        to_address: recipient,
        encrypted_amount,
        amount_commitment,
        balance_proof,
        signature: sign_phase1_tx(&phase1_tx, sender_sk),
        lock_duration: DEFAULT_LOCK_DURATION, // 512 blocks
    };
    
    // Calculate timeouts
    let current_height = state.current_height();
    let phase1_timeout = current_height + 512;  // ~4 minutes
    let phase2_timeout = phase1_timeout + 512;  // +4 minutes
    
    Ok(CrossShardTransaction {
        xshard_id,
        source_shard: from_shard,
        dest_shard: to_shard,
        phase1_tx,
        phase2_tx: None,
        phase1_timeout,
        phase2_timeout,
        beacon_checkpoint: state.beacon_height(),
    })
}
```

**Step 1.2: Source Shard Validates and Locks Funds**

```rust
fn execute_phase1(
    tx: &Phase1Transaction,
    state: &mut State,
) -> Result<CrossShardReceipt> {
    // Validate signature
    verify_signature(&tx.signature, tx.from)?;
    
    // Verify balance proof
    verify_stark_proof(&tx.balance_proof)?;
    
    // Check nonce
    let account = state.get_account_mut(tx.from);
    if tx.nonce != account.nonce + 1 {
        return Err(Error::InvalidNonce);
    }
    
    // Decrypt amount locally (validator has viewing key)
    let amount = decrypt_amount_for_validation(&tx.encrypted_amount)?;
    
    // Lock funds in escrow
    account.balance -= amount;
    account.locked_balance += amount;
    account.nonce += 1;
    
    // Generate lock proof
    let lock_proof = generate_lock_proof(account, amount)?;
    
    // Create receipt
    let receipt = CrossShardReceipt {
        receipt_id: generate_receipt_id(tx),
        xshard_id: tx.xshard_id,
        source_shard: state.shard_id,
        source_height: state.current_height(),
        dest_shard: tx.to_shard,
        locked_amount_commitment: tx.amount_commitment,
        encrypted_amount: tx.encrypted_amount.clone(),
        recipient: tx.to_address,
        lock_proof,
        expiry_height: state.current_height() + tx.lock_duration,
        receipt_commitment: compute_receipt_commitment(/* all fields */),
    };
    
    // Add receipt to shard's receipt tree
    state.receipt_tree.insert(receipt.receipt_id, receipt.clone());
    
    // Emit event for beacon chain
    emit_event(ReceiptEmitted { receipt });
    
    Ok(receipt)
}
```

**Step 1.3: Beacon Chain Registers Receipt**

```rust
fn beacon_register_receipt(
    receipt: CrossShardReceipt,
    source_shard_proof: SMTProof,
) -> Result<()> {
    // Verify source shard finality
    if !is_shard_finalized(receipt.source_shard, receipt.source_height) {
        return Err(Error::ShardNotFinalized);
    }
    
    // Verify receipt is in source shard state
    verify_smt_inclusion(
        &source_shard_proof,
        receipt.receipt_id,
        receipt.receipt_commitment,
        get_shard_state_root(receipt.source_shard, receipt.source_height),
    )?;
    
    // Register in beacon receipt registry
    beacon_state.receipt_registry.insert(
        receipt.receipt_id,
        BeaconReceiptEntry {
            receipt,
            registered_height: beacon_state.current_height(),
            status: ReceiptStatus::Pending,
        },
    );
    
    Ok(())
}
```

### 3.3 Phase 2: COMMIT (Destination Shard)

**Step 2.1: User (or Relayer) Submits Phase 2 Transaction**

```rust
fn create_phase2_transaction(
    receipt: &CrossShardReceipt,
    receipt_proof: ReceiptMerkleProof,
    beacon_attestation: BeaconAttestation,
    recipient_sk: SecretKey,
) -> Result<Phase2Transaction> {
    // Re-encrypt amount for recipient's account
    let recipient_pk = derive_pubkey(recipient_sk);
    let reencrypted_amount = mlkem_encrypt(
        recipient_pk,
        &decrypt_amount(receipt.encrypted_amount, recipient_sk),
    );
    
    // Generate re-encryption proof (proves consistency)
    let reencryption_proof = prove_reencryption_consistency(
        &receipt.encrypted_amount,
        &reencrypted_amount,
        &receipt.locked_amount_commitment,
    )?;
    
    Ok(Phase2Transaction {
        receipt_id: receipt.receipt_id,
        receipt_commitment: receipt.receipt_commitment,
        receipt_merkle_proof: receipt_proof,
        beacon_signature: beacon_attestation.signature,
        beacon_height: beacon_attestation.height,
        to_address: receipt.recipient,
        reencrypted_amount,
        reencryption_proof,
    })
}
```

**Step 2.2: Destination Shard Validates and Credits Funds**

```rust
fn execute_phase2(
    tx: &Phase2Transaction,
    state: &mut State,
) -> Result<CrossShardAck> {
    // 1. Verify receipt hasn't been consumed (nullifier check)
    if state.receipt_nullifiers.contains(&tx.receipt_id) {
        return Err(Error::ReceiptAlreadyConsumed);
    }
    
    // 2. Verify Merkle proof from source shard
    verify_receipt_merkle_proof(&tx.receipt_merkle_proof)?;
    
    // 3. Verify beacon attestation
    verify_beacon_signature(
        &tx.beacon_signature,
        tx.beacon_height,
        &tx.receipt_commitment,
    )?;
    
    // 4. Verify re-encryption proof
    verify_stark_proof(&tx.reencryption_proof)?;
    
    // 5. Check expiry
    let receipt = reconstruct_receipt_from_proof(&tx)?;
    if state.current_height() >= receipt.expiry_height {
        return Err(Error::ReceiptExpired);
    }
    
    // 6. Credit recipient account
    let amount = decrypt_amount_for_validation(&tx.reencrypted_amount)?;
    let account = state.get_account_mut(tx.to_address);
    account.balance += amount;
    
    // 7. Add receipt nullifier (prevents double-spend)
    let nullifier = compute_receipt_nullifier(&tx.receipt_id);
    state.receipt_nullifiers.insert(nullifier);
    
    // 8. Create acknowledgment
    let ack = CrossShardAck {
        receipt_id: tx.receipt_id,
        dest_shard: state.shard_id,
        dest_height: state.current_height(),
        status: AckStatus::Committed,
    };
    
    // Emit event for beacon
    emit_event(AckEmitted { ack });
    
    Ok(ack)
}
```

**Step 2.3: Beacon Chain Records Acknowledgment**

```rust
fn beacon_record_ack(
    ack: CrossShardAck,
    dest_shard_proof: SMTProof,
) -> Result<()> {
    // Verify dest shard finality
    if !is_shard_finalized(ack.dest_shard, ack.dest_height) {
        return Err(Error::ShardNotFinalized);
    }
    
    // Update receipt status
    if let Some(entry) = beacon_state.receipt_registry.get_mut(&ack.receipt_id) {
        entry.status = match ack.status {
            AckStatus::Committed => ReceiptStatus::Committed,
            AckStatus::Rejected => ReceiptStatus::Rejected,
        };
        entry.ack_height = Some(beacon_state.current_height());
    }
    
    Ok(())
}
```

### 3.4 Phase 3: FINALIZE (Source Shard Cleanup)

**Step 3.1: Source Shard Releases Lock**

```rust
fn finalize_cross_shard_transfer(
    receipt_id: [u8; 32],
    ack: CrossShardAck,
    state: &mut State,
) -> Result<()> {
    // Verify ack is finalized on beacon
    verify_ack_finalized(&ack)?;
    
    // Find original lock
    let lock = state.get_lock(receipt_id)?;
    
    match ack.status {
        AckStatus::Committed => {
            // Success: permanently remove locked funds
            let account = state.get_account_mut(lock.from_address);
            account.locked_balance -= lock.amount;
            // Funds already debited in Phase 1, so just release lock
        },
        AckStatus::Rejected => {
            // Failure: refund locked funds
            let account = state.get_account_mut(lock.from_address);
            account.balance += lock.amount;
            account.locked_balance -= lock.amount;
        },
    }
    
    // Remove lock record
    state.locks.remove(&receipt_id);
    
    Ok(())
}
```

---

## 4. Timeout Handling & Rollback

### 4.1 Timeout Scenarios

| Scenario              | When                                 | Action                            |
| --------------------- | ------------------------------------ | --------------------------------- |
| **Phase 1 Timeout**   | Phase 2 not initiated within timeout | Source shard refunds locked funds |
| **Phase 2 Timeout**   | Ack not received within timeout      | Beacon marks receipt as expired   |
| **Network Partition** | Shards unable to communicate         | Beacon coordinates rollback       |
| **Byzantine Source**  | Source never locks funds             | Phase 2 fails verification        |
| **Byzantine Dest**    | Dest never credits                   | Timeout triggers refund           |

### 4.2 Timeout Constants

```rust
// Configuration
const PHASE1_TIMEOUT_BLOCKS: u64 = 512;      // ~4 minutes (500ms blocks)
const PHASE2_TIMEOUT_BLOCKS: u64 = 512;      // ~4 minutes
const TOTAL_TIMEOUT_BLOCKS: u64 = 1024;      // ~8.5 minutes total
const GRACE_PERIOD_BLOCKS: u64 = 64;         // ~32 seconds safety margin

// Finality requirements
const MIN_FINALITY_CONFIRMATIONS: u64 = 64;  // BFT finality depth
```

### 4.3 Automatic Refund Protocol

```rust
fn check_and_execute_timeouts(state: &mut State) {
    let current_height = state.current_height();
    
    // Scan all active locks
    for (receipt_id, lock) in state.locks.iter() {
        // Check if Phase 2 deadline exceeded
        if current_height >= lock.expiry_height + GRACE_PERIOD_BLOCKS {
            // Check beacon for ack
            match beacon_get_receipt_status(receipt_id) {
                ReceiptStatus::Pending | ReceiptStatus::Expired => {
                    // No ack received - execute refund
                    execute_refund(receipt_id, lock, state)?;
                },
                ReceiptStatus::Committed => {
                    // Ack received - finalize normally
                    finalize_cross_shard_transfer(receipt_id, /* ack */, state)?;
                },
                ReceiptStatus::Rejected => {
                    // Rejected - refund immediately
                    execute_refund(receipt_id, lock, state)?;
                },
            }
        }
    }
}

fn execute_refund(
    receipt_id: [u8; 32],
    lock: &Lock,
    state: &mut State,
) -> Result<()> {
    let account = state.get_account_mut(lock.from_address);
    
    // Return locked funds to balance
    account.balance += lock.amount;
    account.locked_balance -= lock.amount;
    
    // Remove lock
    state.locks.remove(&receipt_id);
    
    // Emit refund event
    emit_event(CrossShardRefund {
        receipt_id,
        from_address: lock.from_address,
        amount: lock.amount,
        reason: RefundReason::Timeout,
    });
    
    Ok(())
}
```

### 4.4 Chain Reorganization Handling

**Problem:** What if source shard reorgs after Phase 1 but before Phase 2?

**Solution:** Receipt proofs must reference finalized blocks only.

```rust
fn verify_receipt_merkle_proof(proof: &ReceiptMerkleProof) -> Result<()> {
    let source_height = proof.source_height;
    
    // Ensure source block is finalized
    let finality_depth = beacon_state.current_height() 
        - beacon_state.shard_finalized_height(proof.source_shard);
    
    if finality_depth < MIN_FINALITY_CONFIRMATIONS {
        return Err(Error::ReceiptNotFinalized);
    }
    
    // Verify Merkle path
    verify_merkle_path(
        proof.receipt_root,
        proof.merkle_path,
        proof.receipt_index,
    )?;
    
    // Verify receipt root is in source shard state
    verify_smt_inclusion(
        &proof.state_proof,
        proof.receipt_root,
        proof.source_state_root,
    )?;
    
    Ok(())
}
```

---

## 5. Deadlock Prevention

### 5.1 Deadlock Scenarios

**Scenario A: Circular Dependencies**
```
Shard 0: Lock A â†’ waiting for Shard 1 receipt
Shard 1: Lock B â†’ waiting for Shard 0 receipt
```

**Solution:** Deterministic ordering + timeouts

```rust
fn validate_no_circular_dependency(
    tx: &CrossShardTransaction,
    state: &State,
) -> Result<()> {
    // Rule: Can only have one pending cross-shard tx per account
    let from_account = state.get_account(tx.phase1_tx.from);
    
    if from_account.pending_xshard_count > 0 {
        return Err(Error::PendingCrossShardExists);
    }
    
    Ok(())
}
```

**Scenario B: Resource Exhaustion**
```
Account has 1000 ECLIPT
Submits 10 cross-shard txs of 100 ECLIPT each
All get locked, none can complete
```

**Solution:** Nonce-based ordering + balance checks

```rust
fn validate_sufficient_unlocked_balance(
    tx: &Phase1Transaction,
    state: &State,
) -> Result<()> {
    let account = state.get_account(tx.from);
    let available = account.balance - account.locked_balance;
    
    let amount = decrypt_amount_for_validation(&tx.encrypted_amount)?;
    
    if available < amount + tx.fee {
        return Err(Error::InsufficientUnlockedBalance);
    }
    
    Ok(())
}
```

### 5.2 Deterministic Deadlock Resolution

**Priority-Based Ordering:**

```rust
fn compute_xshard_priority(tx: &CrossShardTransaction) -> u128 {
    // Higher priority = processed first
    let mut priority = 0u128;
    
    // 1. Older transactions first (by nonce)
    priority += (u64::MAX - tx.phase1_tx.nonce) as u128 * 1_000_000;
    
    // 2. Higher fees first
    priority += tx.phase1_tx.fee as u128 * 1_000;
    
    // 3. Deterministic tiebreaker (by xshard_id hash)
    priority += (tx.xshard_id[0] as u128);
    
    priority
}

fn order_cross_shard_transactions(
    txs: Vec<CrossShardTransaction>
) -> Vec<CrossShardTransaction> {
    let mut sorted = txs;
    sorted.sort_by_key(|tx| Reverse(compute_xshard_priority(tx)));
    sorted
}
```

### 5.3 Livelock Prevention

**Problem:** Two transactions keep timing out and retrying forever.

**Solution:** Exponential backoff + maximum retry limit

```rust
struct CrossShardRetryState {
    attempt_count: u32,
    last_attempt_height: u64,
    base_timeout: u64,
}

impl CrossShardRetryState {
    fn compute_next_timeout(&self) -> u64 {
        // Exponential backoff: 512, 1024, 2048, 4096, ...
        let backoff_multiplier = 2u64.pow(self.attempt_count);
        PHASE1_TIMEOUT_BLOCKS * backoff_multiplier.min(16) // Cap at 16x
    }
    
    fn can_retry(&self, max_retries: u32) -> bool {
        self.attempt_count < max_retries
    }
}

const MAX_CROSS_SHARD_RETRIES: u32 = 5;
```

---

## 6. Receipt Verification & Proofs

### 6.1 Receipt Merkle Tree Structure

Each shard maintains a **Receipt Merkle Tree** separate from the main state tree:

```rust
struct ReceiptTree {
    // Sparse Merkle Tree (height 32)
    tree: SparseMerkleTree<ReceiptId, ReceiptCommitment>,
    
    // Epoch-based roots (for historical proofs)
    historical_roots: BTreeMap<u64, [u8; 32]>,
}

impl ReceiptTree {
    fn insert_receipt(&mut self, receipt: &CrossShardReceipt) {
        let index = compute_receipt_index(receipt.receipt_id);
        self.tree.insert(index, receipt.receipt_commitment);
    }
    
    fn get_merkle_proof(
        &self,
        receipt_id: ReceiptId,
        height: u64,
    ) -> ReceiptMerkleProof {
        let index = compute_receipt_index(receipt_id);
        let path = self.tree.get_proof(index);
        let root = self.historical_roots.get(&height).unwrap();
        
        ReceiptMerkleProof {
            receipt_root: *root,
            receipt_index: index,
            merkle_path: path,
            source_state_root: self.get_state_root_at(height),
            state_proof: self.prove_receipt_tree_inclusion(height),
        }
    }
}
```

### 6.2 Cross-Shard Proof Verification

**Verification Flow:**

```rust
fn verify_cross_shard_proof(
    proof: &ReceiptMerkleProof,
    receipt_commitment: [u8; 32],
    beacon_state: &BeaconState,
) -> Result<()> {
    // 1. Verify Merkle path to receipt root
    if !verify_merkle_path(
        receipt_commitment,
        &proof.merkle_path,
        proof.receipt_index,
        proof.receipt_root,
    ) {
        return Err(Error::InvalidReceiptMerkleProof);
    }
    
    // 2. Verify receipt tree is part of shard state
    if !verify_smt_inclusion(
        &proof.state_proof,
        proof.receipt_root,
        proof.source_state_root,
    ) {
        return Err(Error::ReceiptTreeNotInState);
    }
    
    // 3. Verify shard state root is finalized on beacon
    let finalized_root = beacon_state.get_shard_state_root(
        proof.source_shard,
        proof.source_height,
    )?;
    
    if finalized_root != proof.source_state_root {
        return Err(Error::StateRootMismatch);
    }
    
    // 4. Verify beacon finality
    if !beacon_state.is_finalized(proof.source_height) {
        return Err(Error::NotFinalized);
    }
    
    Ok(())
}
```

### 6.3 Beacon Attestation Format

```rust
struct BeaconAttestation {
    // What is being attested
    receipt_id: [u8; 32],
    receipt_commitment: [u8; 32],
    source_shard: u8,
    source_height: u64,
    
    // Beacon state
    beacon_height: u64,
    beacon_state_root: [u8; 32],
    
    // Aggregate signature from beacon validators
    signature: DilithiumSignature,
    validator_bitmap: BitVec,  // Which validators signed (for â‰¥2/3)
}

fn verify_beacon_attestation(
    attestation: &BeaconAttestation,
    beacon_state: &BeaconState,
) -> Result<()> {
    // Verify validator quorum (â‰¥2/3)
    let num_signers = attestation.validator_bitmap.count_ones();
    let validator_set_size = beacon_state.validator_set_size();
    
    if num_signers < (validator_set_size * 2 / 3) {
        return Err(Error::InsufficientBeaconSignatures);
    }
    
    // Verify aggregate signature
    let message = prepare_attestation_message(attestation);
    let pubkeys = beacon_state.get_validator_pubkeys(&attestation.validator_bitmap);
    
    verify_aggregate_dilithium_signature(
        &attestation.signature,
        &message,
        &pubkeys,
    )?;
    
    Ok(())
}
```

---

## 7. Lock Management

### 7.1 Lock Data Structure

```rust
struct Lock {
    // Identity
    lock_id: [u8; 32],           // Same as receipt_id
    
    // Owner
    from_address: Address,
    from_shard: u8,
    
    // Locked funds
    amount: u64,                 // Plaintext for validators
    amount_commitment: [u8; 32], // Public commitment
    
    // Expiry
    locked_at_height: u64,
    expiry_height: u64,
    
    // Destination
    dest_shard: u8,
    dest_address: Address,
}

struct LockTable {
    // Active locks by receipt_id
    locks: HashMap<[u8; 32], Lock>,
    
    // Index by account (for balance queries)
    by_account: HashMap<Address, HashSet<[u8; 32]>>,
    
    // Index by expiry (for timeout scanning)
    by_expiry: BTreeMap<u64, HashSet<[u8; 32]>>,
}

impl LockTable {
    fn add_lock(&mut self, lock: Lock) {
        let lock_id = lock.lock_id;
        let account = lock.from_address;
        let expiry = lock.expiry_height;
        
        self.locks.insert(lock_id, lock);
        self.by_account.entry(account).or_default().insert(lock_id);
        self.by_expiry.entry(expiry).or_default().insert(lock_id);
    }
    
    fn remove_lock(&mut self, lock_id: [u8; 32]) {
        if let Some(lock) = self.locks.remove(&lock_id) {
            self.by_account.get_mut(&lock.from_address)
                .map(|set| set.remove(&lock_id));
            self.by_expiry.get_mut(&lock.expiry_height)
                .map(|set| set.remove(&lock_id));
        }
    }
    
    fn get_locked_balance(&self, account: Address) -> u64 {
        self.by_account.get(&account)
            .map(|lock_ids| {
                lock_ids.iter()
                    .filter_map(|id| self.locks.get(id))
                    .map(|lock| lock.amount)
                    .sum()
            })
            .unwrap_or(0)
    }
    
    fn get_expired_locks(&self, current_height: u64) -> Vec<[u8; 32]> {
        self.by_expiry.range(..=current_height)
            .flat_map(|(_, lock_ids)| lock_ids.iter().copied())
            .collect()
    }
}
```

### 7.2 Lock Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CREATED   â”‚ â† Phase 1 successful
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â†’ [RELEASED] â† Phase 2 successful (ack received)
       â”‚
       â”œâ”€â”€â†’ [REFUNDED] â† Timeout expired
       â”‚
       â””â”€â”€â†’ [REJECTED] â† Phase 2 rejected
```

### 7.3 Balance Calculation with Locks

```rust
fn get_available_balance(account: &Account, locks: &LockTable) -> u64 {
    let total_balance = account.balance;
    let locked_balance = locks.get_locked_balance(account.address);
    
    total_balance.saturating_sub(locked_balance)
}

fn validate_transaction_against_locks(
    tx: &Transaction,
    state: &State,
) -> Result<()> {
    let account = state.get_account(tx.from());
    let available = get_available_balance(account, &state.locks);
    
    let required = tx.amount() + tx.fee();
    
    if available < required {
        return Err(Error::InsufficientUnlockedBalance);
    }
    
    Ok(())
}
```

---

## 8. Performance Analysis

### 8.1 Latency Breakdown

**Best Case (No Congestion):**

| Step                | Time             | Cumulative      |
| ------------------- | ---------------- | --------------- |
| Phase 1 submission  | 1 block (500 ms) | 500 ms          |
| Phase 1 finality    | 64 blocks (32 s) | 32.5 s          |
| Beacon registration | 1 block (500 ms) | 33 s            |
| Phase 2 submission  | 1 block (500 ms) | 33.5 s          |
| Phase 2 finality    | 64 blocks (32 s) | 65.5 s          |
| **Total**           | **130 blocks**   | **~65 seconds** |

**Worst Case (Congestion + Retries):**

| Step                           | Time             | Cumulative      |
| ------------------------------ | ---------------- | --------------- |
| Phase 1 submission (3 retries) | 9 blocks (4.5 s) | 4.5 s           |
| Phase 1 finality               | 64 blocks (32 s) | 36.5 s          |
| Beacon registration delay      | 10 blocks (5 s)  | 41.5 s          |
| Phase 2 submission (2 retries) | 6 blocks (3 s)   | 44.5 s          |
| Phase 2 finality               | 64 blocks (32 s) | 76.5 s          |
| **Total**                      | **153 blocks**   | **~77 seconds** |

### 8.2 Throughput Impact

**Single-Shard Baseline:**
- 50,000 TPS per shard
- 0 cross-shard overhead

**With Cross-Shard Transfers (10% of transactions):**

```rust
// Performance model
let single_shard_tps = 50_000;
let cross_shard_ratio = 0.10;  // 10% of transactions
let cross_shard_overhead = 1.15;  // 15% overhead per cross-shard tx

let effective_tps = single_shard_tps / 
    (1.0 + cross_shard_ratio * (cross_shard_overhead - 1.0));

// Result: ~48,700 TPS (2.6% degradation)
```

**Overhead Sources:**
1. Receipt Merkle tree updates: +3%
2. Beacon attestation verification: +5%
3. Lock management: +2%
4. Proof generation/verification: +5%
5. **Total: ~15% per cross-shard transaction**

### 8.3 Scalability Limits

**Maximum Concurrent Cross-Shard Transactions:**

```rust
// Per shard
const MAX_LOCKS_PER_SHARD: usize = 100_000;
const MAX_RECEIPTS_PER_EPOCH: usize = 10_000;

// Beacon chain
const MAX_RECEIPT_REGISTRATIONS_PER_BLOCK: usize = 1_000;
const MAX_BEACON_ATTESTATIONS_PER_BLOCK: usize = 1_000;
```

**Network-Wide:**
- 8 shards Ã— 10,000 receipts/epoch = 80,000 cross-shard tx/epoch
- Epoch = 1 second â†’ **80,000 cross-shard TPS theoretical max**
- Practical sustained: **~10,000 cross-shard TPS** (12.5% of traffic)

### 8.4 Storage Requirements

**Per Shard:**

| Component         | Size per Item | Max Items | Total       |
| ----------------- | ------------- | --------- | ----------- |
| Active locks      | 256 bytes     | 100,000   | 25 MB       |
| Receipt tree      | 64 bytes/leaf | 1,000,000 | 64 MB       |
| Nullifier set     | 32 bytes      | 1,000,000 | 32 MB       |
| Historical proofs | 10 KB         | 10,000    | 100 MB      |
| **Total**         | -             | -         | **~220 MB** |

**Beacon Chain:**
- Receipt registry: 100,000 active Ã— 512 bytes = 51 MB
- Attestation cache: 10,000 Ã— 2.5 KB = 25 MB
- **Total: ~76 MB**

---

## 9. Security Analysis

### 9.1 Threat Model

| Attack                   | Attacker             | Defense                           |
| ------------------------ | -------------------- | --------------------------------- |
| **Double-spend receipt** | Malicious user       | Receipt nullifiers on dest shard  |
| **Fake receipt**         | Malicious user       | Merkle proof + beacon attestation |
| **Receipt replay**       | Malicious user       | Receipt nullifiers + expiry       |
| **Lock griefing**        | Malicious user       | Timeouts + refund mechanism       |
| **Shard censorship**     | Malicious validators | Beacon timeout monitoring         |
| **Byzantine beacon**     | f < N/3 validators   | BFT consensus + slashing          |
| **Network partition**    | Network-level        | Timeout-based rollback            |

### 9.2 Byzantine Resistance

**Assumption:** f < N/3 malicious validators per shard

**Phase 1 Byzantine Source Shard:**
```
Attack: Source claims to lock funds but doesn't
Defense: Lock proof (zk-STARK) verified by beacon
Result: Phase 2 fails verification, no funds lost
```

**Phase 2 Byzantine Destination Shard:**
```
Attack: Dest credits funds without valid receipt
Defense: Beacon attestation required
Result: Invalid state rejected by honest validators
```

**Byzantine Beacon:**
```
Attack: Beacon signs invalid attestation
Defense: â‰¥2/3 honest validators required (BFT)
Result: Attack requires compromising >1/3 of beacon validators
```

### 9.3 Privacy Guarantees

**Information Leakage:**

| Observer                | Can See                                 | Cannot See                         |
| ----------------------- | --------------------------------------- | ---------------------------------- |
| Source shard validators | Lock exists, timeout, destination shard | Amount, recipient identity         |
| Dest shard validators   | Receipt exists, sender shard            | Amount (encrypted), link to sender |
| Beacon validators       | Receipt commitment, routing             | Amount, identities                 |
| Network observer        | Cross-shard traffic exists              | Amount, sender, recipient          |

**Timing Attacks:**
- Mitigation: Random delays in Phase 2 submission
- Dummy cross-shard transactions (padding)
- Mixed with intra-shard traffic

**Amount Hiding:**
```rust
// All amounts encrypted end-to-end
Phase1: encrypted_amount = ML-KEM.Enc(recipient_pk, amount)
Phase2: reencrypted_amount = ML-KEM.Enc(dest_account_pk, amount)

// Commitments hide amount from everyone
amount_commitment = SHAKE-256(amount || random_scalar)
```

---

## 10. Implementation Roadmap

### 10.1 Phase 1: Single Cross-Shard Pair (v0.1)

**Deliverables:**
- [ ] Phase 1 transaction format + validation
- [ ] Lock management data structures
- [ ] Receipt generation + Merkle tree
- [ ] Basic timeout handling
- [ ] Unit tests (100+ test cases)

**Timeline:** 8 weeks

### 10.2 Phase 2: Multi-Shard + Beacon (v0.2)

**Deliverables:**
- [ ] Beacon receipt registry
- [ ] Cross-shard proof verification
- [ ] Phase 2 transaction format
- [ ] Receipt nullifiers
- [ ] Integration tests (shard-to-shard)

**Timeline:** 6 weeks

### 10.3 Phase 3: Production Hardening (v0.3)

**Deliverables:**
- [ ] Concurrent cross-shard transaction handling
- [ ] Deadlock prevention algorithms
- [ ] Performance optimizations (proof caching)
- [ ] Chaos engineering tests
- [ ] Security audit

**Timeline:** 8 weeks

### 10.4 Phase 4: Advanced Features (v1.0)

**Deliverables:**
- [ ] Batch cross-shard transfers
- [ ] Cross-shard contract calls
- [ ] Optimistic receipt verification
- [ ] Receipt relayer incentives
- [ ] Formal verification (TLA+)

**Timeline:** 12 weeks

---

## 11. Monitoring & Observability

### 11.1 Key Metrics

```rust
struct CrossShardMetrics {
    // Throughput
    phase1_tx_per_second: f64,
    phase2_tx_per_second: f64,
    cross_shard_ratio: f64,  // % of total traffic
    
    // Latency
    avg_phase1_to_phase2_latency: Duration,
    avg_total_latency: Duration,
    p99_latency: Duration,
    
    // Success rate
    successful_transfers: u64,
    timed_out_transfers: u64,
    rejected_transfers: u64,
    
    // Resource usage
    active_locks: usize,
    locked_balance_total: u64,
    receipt_tree_size: usize,
    
    // Beacon metrics
    receipts_registered_per_block: f64,
    attestations_per_block: f64,
    
    // Error rates
    invalid_receipt_proofs: u64,
    expired_receipts: u64,
    double_spend_attempts: u64,
}
```

### 11.2 Alerting Rules

```rust
// Critical alerts
if cross_shard_metrics.timed_out_transfers > 0.05 * total_transfers {
    alert!(Critical, "High cross-shard timeout rate: {}", ...);
}

if cross_shard_metrics.active_locks > MAX_LOCKS_PER_SHARD * 0.9 {
    alert!(Warning, "Lock table approaching capacity");
}

if cross_shard_metrics.p99_latency > Duration::from_secs(120) {
    alert!(Warning, "High cross-shard latency");
}
```

---

## 12. Open Research Questions

1. **Optimistic Cross-Shard Execution**: Can we credit funds optimistically before full finality with fraud proofs?

2. **Receipt Compression**: Can we aggregate multiple receipts into a single proof (zk-STARK recursion)?

3. **Sharded Beacon**: Can the beacon itself be sharded for higher cross-shard throughput?

4. **Privacy-Preserving Receipt Routing**: Can we hide which shard pairs are communicating?

5. **Adaptive Timeouts**: Machine learning-based timeout prediction based on network conditions?

---

## Appendix A: Complete Example Flow

```rust
// 1. Alice on Shard 0 wants to send 1000 ECLIPT to Bob on Shard 1

let xshard_tx = initiate_cross_shard_transfer(
    sender: alice_address,
    from_shard: 0,
    to_shard: 1,
    recipient: bob_address,
    amount: 1000,
);

// 2. Shard 0 processes Phase 1
let receipt = shard0.execute_phase1(&xshard_tx.phase1_tx)?;
// Alice's account: balance -= 1000, locked_balance += 1000

// 3. Beacon registers receipt
beacon.register_receipt(receipt)?;

// 4. Bob (or relayer) submits Phase 2 to Shard 1
let phase2_tx = create_phase2_transaction(
    &receipt,
    receipt_proof,
    beacon_attestation,
    bob_sk,
);

// 5. Shard 1 processes Phase 2
let ack = shard1.execute_phase2(&phase2_tx)?;
// Bob's account: balance += 1000

// 6. Beacon records ack
beacon.record_ack(ack)?;

// 7. Shard 0 finalizes (releases lock)
shard0.finalize_cross_shard_transfer(receipt.receipt_id, ack)?;
// Alice's account: locked_balance -= 1000 (permanent transfer complete)
```

---

## Appendix B: Formal Verification Properties

**Safety Properties (Must Always Hold):**

1. **No Double-Spend**: $\forall r \in \text{Receipts}: \text{Count}(\text{Redeem}(r)) \leq 1$

2. **Balance Conservation**: 
   $$\sum_{\text{shards}} \text{Balance}_{\text{shard}} = \text{TotalSupply} - \sum \text{LockedBalance}$$

3. **Lock-Release Correspondence**: 
   $$\forall l \in \text{Locks}: \exists! e \in \{\text{Released}, \text{Refunded}\}$$

**Liveness Properties (Eventually Holds):**

4. **Timeout Guarantee**: 
   $$\forall \text{tx}: \text{Locked}(\text{tx}) \implies \Diamond_{t < T} \text{Resolved}(\text{tx})$$

5. **Progress**: 
   $$\forall \text{valid-tx}: \Diamond \text{Finalized}(\text{tx})$$

---

**Document ID:** `ECLIPT-XSHARD-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review