# Testing & Simulation Strategy Specification

## 1. Executive Summary

This document specifies Ecliptica's comprehensive quality assurance framework, encompassing unit testing, integration testing, network simulation, chaos engineering, adversarial testing, performance benchmarking, and regression testing.

**Quality Objectives:**
- **99.99% uptime** in production
- **Zero critical bugs** in consensus layer
- **<1% performance regression** between releases
- **100% adversarial scenario coverage** before mainnet
- **Comprehensive test coverage** (>90% for consensus-critical code)

**Testing Philosophy:**
- **Fail fast, fail often** in development
- **Test at every layer** (unit â†’ integration â†’ system â†’ chaos)
- **Automate everything** that can be automated
- **Simulate reality** as closely as possible
- **Measure continuously** (metrics-driven development)

---

## 2. Test Pyramid Architecture

```
                      â–²
                     / \
                    /   \
                   / E2E \          Manual Exploratory Tests
                  /-------\         (Rare, high-level scenarios)
                 / Chaos  \
                /-----------\        Chaos Engineering
               / Integration\        (Network-level, adversarial)
              /---------------\      
             / Component Tests \     Integration Tests
            /-------------------\    (Cross-module, multi-shard)
           /    Unit Tests       \   
          /_______________________\  Unit Tests (70% of tests)
```

**Test Distribution Target:**
- Unit tests: **70%** (fast, deterministic, isolated)
- Integration tests: **20%** (cross-component, slower)
- Chaos/E2E tests: **10%** (expensive, comprehensive)

---

## 3. Network Simulation Parameters

### 3.1 Simulation Environment

```rust
struct NetworkSimulation {
    // Network topology
    num_shards: u8,
    validators_per_shard: u32,
    beacon_validators: u32,
    full_nodes: u32,
    light_clients: u32,
    
    // Network conditions
    latency: LatencyModel,
    bandwidth: BandwidthModel,
    packet_loss: f64,
    
    // Adversarial parameters
    byzantine_validators_percent: f64,
    network_partition_probability: f64,
    
    // Load parameters
    transaction_rate_tps: u64,
    contract_execution_rate_tps: u64,
    cross_shard_tx_ratio: f64,
    
    // Duration
    simulation_duration: Duration,
}
```

### 3.2 Network Topologies

**Topology 1: Small Network (Development)**
```rust
const SMALL_NETWORK: NetworkSimulation = NetworkSimulation {
    num_shards: 2,
    validators_per_shard: 10,
    beacon_validators: 20,
    full_nodes: 5,
    light_clients: 10,
    
    latency: LatencyModel::Fixed(10), // 10ms
    bandwidth: BandwidthModel::Unlimited,
    packet_loss: 0.0,
    
    byzantine_validators_percent: 0.0,
    network_partition_probability: 0.0,
    
    transaction_rate_tps: 100,
    contract_execution_rate_tps: 50,
    cross_shard_tx_ratio: 0.2,
    
    simulation_duration: Duration::from_secs(300), // 5 minutes
};
```

**Topology 2: Medium Network (Testnet-like)**
```rust
const MEDIUM_NETWORK: NetworkSimulation = NetworkSimulation {
    num_shards: 4,
    validators_per_shard: 32,
    beacon_validators: 64,
    full_nodes: 20,
    light_clients: 100,
    
    latency: LatencyModel::Gaussian { mean: 50, stddev: 20 },
    bandwidth: BandwidthModel::PerNode { mbps: 100 },
    packet_loss: 0.001, // 0.1%
    
    byzantine_validators_percent: 0.1, // 10%
    network_partition_probability: 0.001,
    
    transaction_rate_tps: 5000,
    contract_execution_rate_tps: 1000,
    cross_shard_tx_ratio: 0.3,
    
    simulation_duration: Duration::from_secs(3600), // 1 hour
};
```

**Topology 3: Large Network (Mainnet Stress Test)**
```rust
const LARGE_NETWORK: NetworkSimulation = NetworkSimulation {
    num_shards: 8,
    validators_per_shard: 96,
    beacon_validators: 128,
    full_nodes: 100,
    light_clients: 1000,
    
    latency: LatencyModel::Geographic {
        // Simulate global distribution
        same_region: Gaussian { mean: 10, stddev: 5 },
        cross_region: Gaussian { mean: 100, stddev: 30 },
        cross_continent: Gaussian { mean: 200, stddev: 50 },
    },
    bandwidth: BandwidthModel::Heterogeneous {
        validator: 1000, // 1 Gbps
        full_node: 100,  // 100 Mbps
        light_client: 10, // 10 Mbps
    },
    packet_loss: 0.005, // 0.5%
    
    byzantine_validators_percent: 0.33, // 33% (maximum)
    network_partition_probability: 0.01,
    
    transaction_rate_tps: 50_000,
    contract_execution_rate_tps: 10_000,
    cross_shard_tx_ratio: 0.4,
    
    simulation_duration: Duration::from_secs(86400), // 24 hours
};
```

### 3.3 Latency Models

```rust
enum LatencyModel {
    // Fixed latency (ideal case)
    Fixed(u64), // milliseconds
    
    // Normal distribution
    Gaussian { mean: u64, stddev: u64 },
    
    // Geographic-aware
    Geographic {
        same_region: Gaussian,
        cross_region: Gaussian,
        cross_continent: Gaussian,
    },
    
    // Real-world trace replay
    TraceFile { path: String },
}

fn apply_latency(latency_model: &LatencyModel, src: NodeId, dst: NodeId) -> Duration {
    match latency_model {
        LatencyModel::Fixed(ms) => Duration::from_millis(*ms),
        
        LatencyModel::Gaussian { mean, stddev } => {
            let sample = sample_gaussian(*mean as f64, *stddev as f64);
            Duration::from_millis(sample.max(0.0) as u64)
        }
        
        LatencyModel::Geographic { same_region, cross_region, cross_continent } => {
            let distance = compute_geographic_distance(src, dst);
            
            if distance < 1000.0 {
                // Same region
                apply_latency(&LatencyModel::Gaussian { 
                    mean: same_region.mean, 
                    stddev: same_region.stddev 
                }, src, dst)
            } else if distance < 5000.0 {
                // Cross region
                apply_latency(&LatencyModel::Gaussian { 
                    mean: cross_region.mean, 
                    stddev: cross_region.stddev 
                }, src, dst)
            } else {
                // Cross continent
                apply_latency(&LatencyModel::Gaussian { 
                    mean: cross_continent.mean, 
                    stddev: cross_continent.stddev 
                }, src, dst)
            }
        }
        
        LatencyModel::TraceFile { path } => {
            // Load pre-recorded latency trace
            load_latency_from_trace(path, src, dst)
        }
    }
}
```

### 3.4 Bandwidth Models

```rust
enum BandwidthModel {
    // Unlimited (ideal)
    Unlimited,
    
    // Fixed per node
    PerNode { mbps: u64 },
    
    // Heterogeneous (different node types)
    Heterogeneous {
        validator: u64,
        full_node: u64,
        light_client: u64,
    },
    
    // Congestion-aware (shared links)
    Congestion {
        base_mbps: u64,
        congestion_factor: f64, // 0.0 - 1.0
    },
}

fn apply_bandwidth_limit(
    bandwidth_model: &BandwidthModel,
    node: NodeId,
    message_size: usize,
) -> Duration {
    let mbps = match bandwidth_model {
        BandwidthModel::Unlimited => return Duration::ZERO,
        
        BandwidthModel::PerNode { mbps } => *mbps,
        
        BandwidthModel::Heterogeneous { validator, full_node, light_client } => {
            match get_node_type(node) {
                NodeType::Validator => *validator,
                NodeType::FullNode => *full_node,
                NodeType::LightClient => *light_client,
            }
        }
        
        BandwidthModel::Congestion { base_mbps, congestion_factor } => {
            let congestion = get_current_congestion(node);
            (base_mbps as f64 * (1.0 - congestion * congestion_factor)) as u64
        }
    };
    
    // Calculate transmission time
    let bits = message_size * 8;
    let seconds = bits as f64 / (mbps as f64 * 1_000_000.0);
    
    Duration::from_secs_f64(seconds)
}
```

### 3.5 Simulation Framework

```rust
struct Simulator {
    // Virtual time (for determinism)
    current_time: VirtualTime,
    
    // Event queue
    event_queue: BinaryHeap<SimulationEvent>,
    
    // Nodes
    nodes: HashMap<NodeId, SimulatedNode>,
    
    // Network
    network: NetworkSimulation,
    
    // Metrics
    metrics: SimulationMetrics,
}

impl Simulator {
    fn run(&mut self) -> SimulationResults {
        while let Some(event) = self.event_queue.pop() {
            // Advance virtual time
            self.current_time = event.scheduled_time;
            
            // Process event
            match event.event_type {
                EventType::MessageDelivery { from, to, message } => {
                    self.deliver_message(from, to, message);
                }
                
                EventType::BlockProposal { proposer, block } => {
                    self.propose_block(proposer, block);
                }
                
                EventType::NetworkPartition { affected_nodes } => {
                    self.partition_network(affected_nodes);
                }
                
                EventType::ValidatorCrash { validator } => {
                    self.crash_validator(validator);
                }
                
                EventType::TransactionSubmission { tx } => {
                    self.submit_transaction(tx);
                }
            }
            
            // Record metrics
            self.metrics.record_event(&event);
            
            // Check termination condition
            if self.current_time >= self.network.simulation_duration {
                break;
            }
        }
        
        // Analyze results
        self.analyze_results()
    }
    
    fn deliver_message(&mut self, from: NodeId, to: NodeId, message: Message) {
        // Apply network conditions
        let latency = apply_latency(&self.network.latency, from, to);
        let transmission_delay = apply_bandwidth_limit(
            &self.network.bandwidth,
            from,
            message.size(),
        );
        
        // Packet loss
        if random::<f64>() < self.network.packet_loss {
            self.metrics.packets_dropped += 1;
            return; // Drop message
        }
        
        // Schedule delivery
        let delivery_time = self.current_time + latency + transmission_delay;
        
        self.event_queue.push(SimulationEvent {
            scheduled_time: delivery_time,
            event_type: EventType::MessageReceived { to, message },
        });
    }
}
```

---

## 4. Chaos Engineering Approach

### 4.1 Chaos Principles

**Principles:**
1. **Build hypothesis** about steady-state behavior
2. **Introduce controlled chaos** (faults, delays, failures)
3. **Observe deviation** from expected behavior
4. **Minimize blast radius** (gradual rollout)
5. **Automate experiments** (continuous chaos)

### 4.2 Chaos Scenarios

```rust
enum ChaosScenario {
    // Network chaos
    NetworkPartition {
        affected_shards: Vec<u8>,
        duration: Duration,
    },
    
    LatencySpike {
        target_nodes: Vec<NodeId>,
        latency_multiplier: f64,
        duration: Duration,
    },
    
    PacketLoss {
        loss_rate: f64,
        duration: Duration,
    },
    
    // Node chaos
    ValidatorCrash {
        num_validators: usize,
        crash_pattern: CrashPattern,
    },
    
    MemoryExhaustion {
        target_node: NodeId,
        memory_limit: u64,
    },
    
    DiskFull {
        target_node: NodeId,
        fill_percentage: f64,
    },
    
    // Byzantine behavior
    ByzantineValidator {
        validators: Vec<NodeId>,
        behavior: ByzantineBehavior,
    },
    
    // Thundering herd
    TransactionFlood {
        rate_multiplier: f64,
        duration: Duration,
    },
    
    // State corruption
    StateCorruption {
        target_node: NodeId,
        corruption_type: CorruptionType,
    },
}

enum CrashPattern {
    Simultaneous,   // All crash at once
    Cascade,        // One by one
    Random,         // Random timing
}

enum ByzantineBehavior {
    Equivocation,       // Double-sign blocks
    InvalidBlocks,      // Propose invalid blocks
    Censorship,         // Refuse to include certain transactions
    SlowResponses,      // Delay responses
    RandomVotes,        // Vote randomly
}

enum CorruptionType {
    BitFlip { offset: u64 },
    BlockRewrite { block_height: u64 },
    StateRootMismatch,
}
```

### 4.3 Chaos Injection

```rust
struct ChaosController {
    active_scenarios: Vec<ActiveChaos>,
    chaos_schedule: Vec<ScheduledChaos>,
}

struct ActiveChaos {
    scenario: ChaosScenario,
    start_time: Instant,
    end_time: Instant,
    metrics: ChaosMetrics,
}

impl ChaosController {
    fn inject_chaos(&mut self, scenario: ChaosScenario) -> Result<()> {
        log::warn!("ðŸ”¥ INJECTING CHAOS: {:?}", scenario);
        
        match scenario {
            ChaosScenario::NetworkPartition { affected_shards, duration } => {
                self.partition_shards(affected_shards, duration)?;
            }
            
            ChaosScenario::ValidatorCrash { num_validators, crash_pattern } => {
                self.crash_validators(num_validators, crash_pattern)?;
            }
            
            ChaosScenario::ByzantineValidator { validators, behavior } => {
                self.enable_byzantine_behavior(validators, behavior)?;
            }
            
            _ => { /* ... other scenarios ... */ }
        }
        
        Ok(())
    }
    
    fn partition_shards(&mut self, affected_shards: Vec<u8>, duration: Duration) -> Result<()> {
        // Isolate affected shards from rest of network
        for shard_id in affected_shards {
            let shard_validators = get_shard_validators(shard_id);
            
            for validator in shard_validators {
                // Block all incoming messages
                install_network_filter(validator, NetworkFilter::DropAll)?;
            }
        }
        
        // Schedule healing
        schedule_chaos_recovery(duration, move || {
            // Remove network filters
            for shard_id in affected_shards {
                let shard_validators = get_shard_validators(shard_id);
                for validator in shard_validators {
                    remove_network_filter(validator)?;
                }
            }
        });
        
        Ok(())
    }
    
    fn crash_validators(&mut self, num_validators: usize, pattern: CrashPattern) -> Result<()> {
        let validators = select_random_validators(num_validators);
        
        match pattern {
            CrashPattern::Simultaneous => {
                for validator in validators {
                    kill_node(validator)?;
                }
            }
            
            CrashPattern::Cascade => {
                for (i, validator) in validators.iter().enumerate() {
                    tokio::spawn({
                        let v = *validator;
                        async move {
                            tokio::time::sleep(Duration::from_secs(i as u64 * 10)).await;
                            kill_node(v).unwrap();
                        }
                    });
                }
            }
            
            CrashPattern::Random => {
                for validator in validators {
                    let delay = random_duration(Duration::ZERO, Duration::from_secs(60));
                    tokio::spawn({
                        let v = validator;
                        async move {
                            tokio::time::sleep(delay).await;
                            kill_node(v).unwrap();
                        }
                    });
                }
            }
        }
        
        Ok(())
    }
}
```

### 4.4 Chaos Testing Schedule

| Chaos Scenario                     | Frequency | Environment | Expected Outcome                  |
| ---------------------------------- | --------- | ----------- | --------------------------------- |
| **Network partition (1 shard)**    | Weekly    | Testnet     | Shard recovers within timeout     |
| **Network partition (50% nodes)**  | Monthly   | Testnet     | Network maintains liveness        |
| **Validator crash (10%)**          | Daily     | Testnet     | Consensus continues normally      |
| **Validator crash (30%)**          | Weekly    | Testnet     | Consensus continues (>67% online) |
| **Byzantine validators (10%)**     | Weekly    | Testnet     | Malicious blocks rejected         |
| **Byzantine validators (33%)**     | Monthly   | Testnet     | Network detects and slashes       |
| **Transaction flood (10Ã— normal)** | Weekly    | Testnet     | Mempool handles backpressure      |
| **State corruption**               | Monthly   | Testnet     | Node detects and halts            |
| **Disk full**                      | Monthly   | Testnet     | Graceful degradation              |
| **Memory exhaustion**              | Monthly   | Testnet     | OOM handler triggers              |

---

## 5. Adversarial Testing Scenarios

### 5.1 Attack Scenarios

```rust
enum AdversarialScenario {
    // Double-spend attempts
    DoubleSpend {
        attacker: Address,
        amount: u64,
        num_attempts: u32,
    },
    
    // Long-range attack
    LongRangeAttack {
        attacker_stake: f64, // % of total stake
        fork_point: u64,     // Block height to fork from
    },
    
    // Nothing-at-stake
    NothingAtStake {
        validators: Vec<NodeId>,
        num_forks: u32,
    },
    
    // Selfish mining
    SelfishMining {
        attacker_hashpower: f64,
        withholding_strategy: WithholdingStrategy,
    },
    
    // Eclipse attack
    EclipseAttack {
        target: NodeId,
        attacker_nodes: Vec<NodeId>,
    },
    
    // Sybil attack
    SybilAttack {
        num_sybil_nodes: u32,
        target_connections: u32,
    },
    
    // MEV extraction
    MEVExtraction {
        attacker_validator: NodeId,
        mev_strategy: MEVStrategy,
    },
    
    // DDoS
    DDoSAttack {
        target: NodeId,
        attack_rate_mbps: u64,
        duration: Duration,
    },
}

enum MEVStrategy {
    Frontrunning,
    Backrunning,
    Sandwich,
    TimeBank,
}
```

### 5.2 Adversarial Test Suite

```rust
#[cfg(test)]
mod adversarial_tests {
    use super::*;
    
    #[test]
    fn test_double_spend_prevention() {
        let mut network = setup_test_network(10);
        let attacker = network.create_account_with_balance(1000);
        
        // Attempt 1: Submit transaction to Shard 0
        let tx1 = create_transfer_tx(attacker, recipient_1, 1000);
        network.submit_to_shard(0, tx1.clone());
        
        // Attempt 2: Submit same funds to Shard 1
        let tx2 = create_transfer_tx(attacker, recipient_2, 1000);
        network.submit_to_shard(1, tx2.clone());
        
        // Wait for finalization
        network.advance_until_finalized();
        
        // Verify: Only one transaction succeeded
        let balance1 = network.get_balance(recipient_1);
        let balance2 = network.get_balance(recipient_2);
        
        assert!(balance1 == 1000 || balance2 == 1000);
        assert!(balance1 + balance2 == 1000);
    }
    
    #[test]
    fn test_long_range_attack_prevention() {
        let mut network = setup_test_network(100);
        
        // Simulate attacker with 40% stake
        let attacker_stake = 0.40;
        let attacker_validators = network.corrupt_validators(attacker_stake);
        
        // Fork from block 100
        let fork_point = 100;
        network.advance_to_height(1000);
        
        // Attacker creates alternative chain from block 100
        let malicious_chain = network.fork_from_height(
            fork_point,
            attacker_validators,
        );
        
        // Honest nodes should reject malicious chain
        for honest_node in network.honest_nodes() {
            let result = honest_node.process_chain(&malicious_chain);
            
            assert!(matches!(result, Err(Error::WeakSubjectivityViolation)));
        }
    }
    
    #[test]
    fn test_byzantine_validator_detection() {
        let mut network = setup_test_network(96);
        
        // Corrupt 31 validators (32% - just below threshold)
        let byzantine_validators = network.corrupt_validators_count(31);
        
        // Byzantine validators equivocate
        for validator in &byzantine_validators {
            network.enable_equivocation(*validator);
        }
        
        // Advance network
        network.advance_for_duration(Duration::from_secs(300));
        
        // Verify: All byzantine validators detected and slashed
        for validator in &byzantine_validators {
            let validator_info = network.get_validator_info(*validator);
            
            assert!(validator_info.slashed);
            assert!(validator_info.slash_reason == SlashReason::Equivocation);
        }
    }
    
    #[test]
    fn test_eclipse_attack_resistance() {
        let mut network = setup_test_network(100);
        let victim = network.nodes[0];
        
        // Attacker controls 50 sybil nodes
        let attacker_nodes: Vec<NodeId> = (0..50)
            .map(|_| network.create_sybil_node())
            .collect();
        
        // Attempt to eclipse victim
        for attacker_node in &attacker_nodes {
            network.connect_nodes(victim, *attacker_node);
        }
        
        // Victim should maintain connections to honest nodes
        let victim_peers = network.get_peers(victim);
        let honest_peers = victim_peers.iter()
            .filter(|p| !attacker_nodes.contains(p))
            .count();
        
        // Diversity requirements prevent full eclipse
        assert!(honest_peers >= 3); // At least 3 honest connections maintained
    }
    
    #[test]
    fn test_mev_protection() {
        let mut network = setup_test_network(10);
        let attacker_validator = network.validators[0];
        
        // User submits high-value DEX swap
        let user_tx = create_dex_swap_tx(user, 10000);
        network.submit_transaction(user_tx.clone());
        
        // Attacker validator sees transaction in mempool
        network.enable_mev_extraction(attacker_validator);
        
        // Attacker attempts frontrunning
        let frontrun_tx = create_frontrun_tx(attacker_validator, user_tx);
        network.submit_transaction(frontrun_tx);
        
        // Wait for block inclusion
        network.advance_one_block();
        
        // Verify: Frontrunning prevented (encrypted mempool)
        let block_txs = network.get_last_block_transactions();
        
        // User transaction should execute at expected price
        assert!(verify_no_mev_extraction(&block_txs, &user_tx));
    }
}
```

---

## 6. Performance Benchmarking Methodology

### 6.1 Benchmark Categories

```rust
enum BenchmarkCategory {
    // Cryptography
    Crypto {
        operation: CryptoOperation,
        batch_size: usize,
    },
    
    // Consensus
    Consensus {
        num_validators: usize,
        transaction_rate: u64,
    },
    
    // Smart contracts
    Contracts {
        contract_type: ContractType,
        concurrent_instances: usize,
    },
    
    // Storage
    Storage {
        operation: StorageOperation,
        dataset_size: u64,
    },
    
    // Network
    Network {
        num_nodes: usize,
        message_rate: u64,
    },
    
    // End-to-end
    E2E {
        workload: Workload,
        duration: Duration,
    },
}

enum CryptoOperation {
    MLKEMEncrypt,
    MLKEMDecrypt,
    MLDSASign,
    MLDSAVerify,
    SHAKE256Hash,
    ZKSTARKProve,
    ZKSTARKVerify,
}

enum StorageOperation {
    RandomRead,
    RandomWrite,
    SequentialRead,
    SequentialWrite,
    MerkleProofGeneration,
    StateSyncription,
}
```

### 6.2 Performance Targets

| Component           | Metric              | Target      | Stretch Goal     |
| ------------------- | ------------------- | ----------- | ---------------- |
| **Consensus**       | Block time          | 250-500ms   | 200ms            |
|                     | Finality latency    | <400ms      | <150ms           |
|                     | TPS per shard       | 4,000-8,000 | 10,000           |
| **Cryptography**    | ML-KEM encrypt      | <1.5ms      | <0.8ms (AVX-512) |
|                     | ML-KEM decrypt      | <1.5ms      | <0.8ms (AVX-512) |
|                     | ML-DSA sign         | <2ms        | <1ms             |
|                     | ML-DSA verify       | <1ms        | <0.5ms           |
|                     | SHAKE-256 (1KB)     | <0.01ms     | <0.005ms         |
| **Smart Contracts** | Empty call          | <0.1ms      | <0.05ms          |
|                     | Token transfer      | <10ms       | <5ms             |
|                     | Complex contract    | <50ms       | <25ms            |
| **Storage**         | Random read         | <0.5ms      | <0.1ms           |
|                     | Random write        | <2ms        | <1ms             |
|                     | Merkle proof        | <0.2ms      | <0.1ms           |
| **Network**         | Message propagation | <100ms      | <50ms            |
|                     | Block propagation   | <200ms      | <100ms           |

### 6.3 Benchmark Harness

```rust
struct BenchmarkHarness {
    name: String,
    category: BenchmarkCategory,
    warmup_iterations: u32,
    benchmark_iterations: u32,
    
    // Statistical analysis
    confidence_level: f64,      // 0.95 = 95%
    acceptable_variance: f64,   // Max coefficient of variation
}

impl BenchmarkHarness {
    fn run(&self) -> BenchmarkResults {
        // Warmup phase
        for _ in 0..self.warmup_iterations {
            self.run_once()?;
        }
        
        // Benchmark phase
        let mut measurements = Vec::new();
        
        for iteration in 0..self.benchmark_iterations {
            let start = Instant::now();
            
            self.run_once()?;
            
            let duration = start.elapsed();
            measurements.push(duration);
            
            // Progress reporting
            if iteration % 100 == 0 {
                log::info!("Benchmark progress: {}/{}", iteration, self.benchmark_iterations);
            }
        }
        
        // Statistical analysis
        self.analyze_results(measurements)
    }
    
    fn analyze_results(&self, measurements: Vec<Duration>) -> BenchmarkResults {
        let durations_ns: Vec<f64> = measurements.iter()
            .map(|d| d.as_nanos() as f64)
            .collect();
        
        // Compute statistics
        let mean = durations_ns.iter().sum::<f64>() / durations_ns.len() as f64;
        let variance = durations_ns.iter()
            .map(|x| (x - mean).powi(2))
            .sum::<f64>() / durations_ns.len() as f64;
        let stddev = variance.sqrt();
        
        // Sort for percentiles
        let mut sorted = durations_ns.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
        
        let p50 = percentile(&sorted, 0.50);
        let p95 = percentile(&sorted, 0.95);
        let p99 = percentile(&sorted, 0.99);
        let p999 = percentile(&sorted, 0.999);
        
        BenchmarkResults {
            name: self.name.clone(),
            iterations: self.benchmark_iterations,
            mean: Duration::from_nanos(mean as u64),
            stddev: Duration::from_nanos(stddev as u64),
            min: sorted.first().copied().map(|n| Duration::from_nanos(n as u64)).unwrap(),
            max: sorted.last().copied().map(|n| Duration::from_nanos(n as u64)).unwrap(),
            p50: Duration::from_nanos(p50 as u64),
            p95: Duration::from_nanos(p95 as u64),
            p99: Duration::from_nanos(p99 as u64),
            p999: Duration::from_nanos(p999 as u64),
        }
    }
}

fn percentile(sorted_data: &[f64], p: f64) -> f64 {
    let index = (p * (sorted_data.len() - 1) as f64).round() as usize;
    sorted_data[index]
}
```

### 6.4 Continuous Benchmarking

```rust
// Run benchmarks on every commit
#[cfg(benchmark)]
mod continuous_benchmarks {
    use criterion::{black_box, criterion_group, criterion_main, Criterion};
    
    fn bench_ml_kem_encrypt(c: &mut Criterion) {
        let pubkey = generate_test_pubkey();
        let plaintext = vec![0u8; 32];
        
        c.bench_function("ml_kem_encrypt", |b| {
            b.iter(|| {
                ml_kem_encrypt(black_box(&pubkey), black_box(&plaintext))
            })
        });
    }
    
    fn bench_consensus_vote(c: &mut Criterion) {
        let validator = setup_test_validator();
        let block = generate_test_block();
        
        c.bench_function("consensus_vote", |b| {
            b.iter(|| {
                validator.vote_on_block(black_box(&block))
            })
        });
    }
    
    fn bench_contract_execution(c: &mut Criterion) {
        let mut env = setup_contract_env();
        let contract = deploy_test_contract(&mut env);
        
        c.bench_function("contract_call", |b| {
            b.iter(|| {
                env.call_contract(black_box(&contract), "increment", &[])
            })
        });
    }
    
    criterion_group!(benches, 
        bench_ml_kem_encrypt,
        bench_consensus_vote,
        bench_contract_execution
    );
    criterion_main!(benches);
}
```

---

## 7. Regression Test Suite

### 7.1 Test Categories

```rust
enum TestCategory {
    // Core functionality
    Unit,           // Individual function/module tests
    Integration,    // Cross-module tests
    E2E,            // Full system tests
    
    // Quality attributes
    Performance,    // Performance regression tests
    Security,       // Security regression tests
    Compatibility,  // Backward compatibility tests
    
    // Specialized
    Fuzz,          // Fuzzing tests
    Property,      // Property-based tests
    Snapshot,      // Snapshot tests (golden files)
}
```

### 7.2 Test Organization

```
/ecliptica/tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ crypto/
â”‚   â”‚   â”œâ”€â”€ ml_kem_test.rs
â”‚   â”‚   â”œâ”€â”€ ml_dsa_test.rs
â”‚   â”‚   â””â”€â”€ shake256_test.rs
â”‚   â”œâ”€â”€ consensus/
â”‚   â”‚   â”œâ”€â”€ hotstuff_test.rs
â”‚   â”‚   â”œâ”€â”€ dag_mempool_test.rs
â”‚   â”‚   â””â”€â”€ beacon_test.rs
â”‚   â”œâ”€â”€ state/
â”‚   â”‚   â”œâ”€â”€ smt_test.rs
â”‚   â”‚   â”œâ”€â”€ account_test.rs
â”‚   â”‚   â””â”€â”€ utxo_test.rs
â”‚   â””â”€â”€ vm/
â”‚       â”œâ”€â”€ wasmtime_test.rs
â”‚       â”œâ”€â”€ gas_metering_test.rs
â”‚       â””â”€â”€ host_functions_test.rs
â”‚
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ cross_shard_test.rs
â”‚   â”œâ”€â”€ contract_interaction_test.rs
â”‚   â”œâ”€â”€ validator_rotation_test.rs
â”‚   â””â”€â”€ upgrade_test.rs
â”‚
â”œâ”€â”€ e2e/
â”‚   â”œâ”€â”€ transfer_test.rs
â”‚   â”œâ”€â”€ staking_test.rs
â”‚   â”œâ”€â”€ governance_test.rs
â”‚   â””â”€â”€ full_network_test.rs
â”‚
â”œâ”€â”€ performance/
â”‚   â”œâ”€â”€ throughput_regression_test.rs
â”‚   â”œâ”€â”€ latency_regression_test.rs
â”‚   â””â”€â”€ memory_regression_test.rs
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ double_spend_test.rs
â”‚   â”œâ”€â”€ byzantine_test.rs
â”‚   â””â”€â”€ dos_test.rs
â”‚
â”œâ”€â”€ fuzz/
â”‚   â”œâ”€â”€ transaction_fuzz.rs
â”‚   â”œâ”€â”€ block_fuzz.rs
â”‚   â””â”€â”€ state_transition_fuzz.rs
â”‚
â””â”€â”€ golden/
    â”œâ”€â”€ transaction_serialization/
    â”œâ”€â”€ block_format/
    â””â”€â”€ state_root/
```

### 7.3 Regression Detection

```rust
struct RegressionTest {
    name: String,
    baseline: BenchmarkResults,
    threshold_percent: f64,     // Max acceptable regression
}

impl RegressionTest {
    fn check_regression(&self, current: &BenchmarkResults) -> Result<(), Regression> {
        // Check mean performance
        let mean_regression = self.compute_regression(
            self.baseline.mean,
            current.mean,
        );
        
        if mean_regression > self.threshold_percent {
            return Err(Regression {
                test_name: self.name.clone(),
                metric: "mean",
                baseline: self.baseline.mean,
                current: current.mean,
                regression_percent: mean_regression,
            });
        }
        
        // Check p99 performance
        let p99_regression = self.compute_regression(
            self.baseline.p99,
            current.p99,
        );
        
        if p99_regression > self.threshold_percent {
            return Err(Regression {
                test_name: self.name.clone(),
                metric: "p99",
                baseline: self.baseline.p99,
                current: current.p99,
                regression_percent: p99_regression,
            });
        }
        
        Ok(())
    }
    
    fn compute_regression(&self, baseline: Duration, current: Duration) -> f64 {
        let baseline_ns = baseline.as_nanos() as f64;
        let current_ns = current.as_nanos() as f64;
        
        ((current_ns - baseline_ns) / baseline_ns) * 100.0
    }
}
```

### 7.4 CI/CD Integration

```yaml
# .github/workflows/test.yml
name: Test Suite

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run unit tests
        run: cargo test --lib
        
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run integration tests
        run: cargo test --test '*'
        
  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run benchmarks
        run: cargo bench --no-fail-fast
      - name: Check for regressions
        run: python scripts/check_regression.py
        
  fuzz-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run fuzzing (5 min)
        run: cargo fuzz run --fuzz-target all -- -max_total_time=300
        
  chaos-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - name: Deploy testnet
        run: ./scripts/deploy_testnet.sh
      - name: Run chaos experiments
        run: ./scripts/run_chaos.sh
      - name: Collect results
        run: ./scripts/analyze_chaos_results.sh
```

---

## 8. Quality Metrics Dashboard

### 8.1 Tracked Metrics

```rust
struct QualityMetrics {
    // Test coverage
    line_coverage_percent: f64,
    branch_coverage_percent: f64,
    
    // Test execution
    total_tests: u32,
    passing_tests: u32,
    failing_tests: u32,
    skipped_tests: u32,
    
    // Performance
    avg_test_duration: Duration,
    slowest_tests: Vec<(String, Duration)>,
    
    // Regression
    performance_regressions: u32,
    compatibility_breaks: u32,
    
    // Chaos results
    chaos_experiments_passed: u32,
    chaos_experiments_failed: u32,
    
    // Security
    vulnerabilities_found: u32,
    vulnerabilities_fixed: u32,
}
```

### 8.2 Quality Gates

```rust
struct QualityGate {
    name: String,
    requirement: Requirement,
}

enum Requirement {
    MinCoverage { percent: f64 },
    MaxRegressions { count: u32 },
    AllTestsPass,
    NoCriticalVulnerabilities,
    PerformanceWithinThreshold { threshold_percent: f64 },
}

fn check_quality_gates(metrics: &QualityMetrics) -> Vec<QualityGateFailure> {
    let gates = vec![
        QualityGate {
            name: "Consensus Coverage".to_string(),
            requirement: Requirement::MinCoverage { percent: 95.0 },
        },
        QualityGate {
            name: "Performance Regression".to_string(),
            requirement: Requirement::MaxRegressions { count: 0 },
        },
        QualityGate {
            name: "All Tests Pass".to_string(),
            requirement: Requirement::AllTestsPass,
        },
        QualityGate {
            name: "No Critical Vulnerabilities".to_string(),
            requirement: Requirement::NoCriticalVulnerabilities,
        },
    ];
    
    let mut failures = Vec::new();
    
    for gate in gates {
        if let Err(failure) = gate.check(metrics) {
            failures.push(failure);
        }
    }
    
    failures
}
```

---

## 9. Test Data Generation

### 9.1 Synthetic Workloads

```rust
enum Workload {
    // Realistic user behavior
    UserActivity {
        num_users: u32,
        activity_pattern: ActivityPattern,
    },
    
    // Stress testing
    MaxThroughput {
        target_tps: u64,
        duration: Duration,
    },
    
    // Specific scenarios
    DEXTrading {
        num_traders: u32,
        trade_frequency: f64,
    },
    
    NFTMinting {
        num_collections: u32,
        mints_per_second: f64,
    },
}

enum ActivityPattern {
    Constant,                   // Steady rate
    Poisson { lambda: f64 },   // Random arrivals
    Burst { interval: Duration, burst_size: u32 },
    DailyPattern { peak_hours: Vec<u8> },
}
```

### 9.2 Test Data Generators

```rust
fn generate_realistic_transactions(
    num_transactions: u32,
    distribution: TransactionDistribution,
) -> Vec<Transaction> {
    let mut transactions = Vec::new();
    
    for _ in 0..num_transactions {
        let tx_type = sample_transaction_type(&distribution);
        
        let tx = match tx_type {
            TransactionType::Transfer => generate_transfer_tx(),
            TransactionType::ContractCall => generate_contract_call_tx(),
            TransactionType::Stake => generate_stake_tx(),
            TransactionType::CrossShard => generate_cross_shard_tx(),
        };
        
        transactions.push(tx);
    }
    
    transactions
}

struct TransactionDistribution {
    transfer_percent: f64,
    contract_call_percent: f64,
    stake_percent: f64,
    cross_shard_percent: f64,
}

// Realistic distribution based on typical blockchain usage
const REALISTIC_DISTRIBUTION: TransactionDistribution = TransactionDistribution {
    transfer_percent: 0.60,      // 60% simple transfers
    contract_call_percent: 0.30, // 30% contract interactions
    stake_percent: 0.05,         // 5% staking operations
    cross_shard_percent: 0.05,   // 5% cross-shard transactions
};
```

---

## 10. Conclusion

Ecliptica's testing and simulation strategy provides comprehensive quality assurance across all layers:

âœ“ **Network simulation** with realistic parameters (latency, bandwidth, topology)  
âœ“ **Chaos engineering** for fault injection and resilience testing  
âœ“ **Adversarial scenarios** covering all major attack vectors  
âœ“ **Performance benchmarking** with regression detection  
âœ“ **Comprehensive test suite** (unit, integration, E2E, fuzz)  

**Key Success Metrics:**
- 99.99% uptime in production
- Zero critical consensus bugs
- <1% performance regression between releases
- 100% adversarial scenario coverage
- >90% test coverage for consensus-critical code

---

**Document ID**: `ECLIPT-TESTING-001`  
**Version**: 1.0  
**Status**: Complete Draft  
**Last Updated**: October 2025  
**Maintainer**: Ecliptica Quality Assurance Team