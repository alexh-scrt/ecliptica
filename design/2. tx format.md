# ğŸ“¦ **Ecliptica Transaction Format & Lifecycle Specification**

### *Post-Quantum Privacy-Preserving Transaction Protocol*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-TX-001`  
**Depends On:** `ECLIPT-STATE-001` (State Transition Model)

---

## 1. Executive Summary

This specification defines the canonical binary format, versioning, lifecycle, and fee model for all Ecliptica transactions. Every transaction type (UTXO, Account, Cross-Shard, Contract) follows a unified serialization framework that ensures:

- **Deterministic Encoding**: Identical semantic transaction â†’ identical bytes
- **Post-Quantum Security**: ML-DSA (Dilithium-3) signatures with 2420-byte signatures
- **Privacy Preservation**: Encrypted amounts with zk-STARK validity proofs
- **Forward Compatibility**: Version negotiation and extensibility
- **Efficient Verification**: Batch-verifiable signatures and proof aggregation

---

## 2. Transaction Type Taxonomy

| Type ID | Name                 | Description                           | Privacy Level                     |
| ------- | -------------------- | ------------------------------------- | --------------------------------- |
| `0x01`  | **UTXO Transfer**    | Note-based private transfer           | Maximum (fully shielded)          |
| `0x02`  | **Account Transfer** | Account-to-account encrypted transfer | High (amount hidden)              |
| `0x03`  | **Shield**           | UTXO â†’ Account conversion             | Medium (conversion visible)       |
| `0x04`  | **Unshield**         | Account â†’ UTXO conversion             | Medium (conversion visible)       |
| `0x05`  | **Contract Call**    | Smart contract invocation             | Configurable (contract-dependent) |
| `0x06`  | **Stake**            | Validator staking operation           | Low (amount visible for slashing) |
| `0x07`  | **Unstake**          | Validator unstaking                   | Low (governance requirement)      |
| `0x08`  | **Cross-Shard**      | Atomic cross-shard transfer           | High (encrypted + 2PC)            |
| `0x09`  | **Governance**       | On-chain governance vote              | Public (transparency required)    |

---

## 3. Universal Transaction Envelope

All transactions share a common outer structure:

```rust
struct TransactionEnvelope {
    // Header (32 bytes)
    version: u16,              // Protocol version (current: 1)
    tx_type: u8,               // Type ID from taxonomy
    shard_id: u8,              // Originating shard (0-255)
    expiry_height: u64,        // Block height expiration
    reserved: [u8; 16],        // Future use (must be zero)
    
    // Body (variable)
    payload: TransactionPayload,
    
    // Proof & Authentication (variable)
    proof: Option<STARKProof>,
    signature: SignatureData,
    
    // Metadata (variable)
    aux_data: AuxiliaryData,
}
```

### 3.1 Version Negotiation

**Current Version: `0x0001`**

Version format: `MAJOR.MINOR` encoded as `u16`
- **MAJOR**: Breaking changes (bits 8-15)
- **MINOR**: Backward-compatible additions (bits 0-7)

**Compatibility Rules:**
```rust
fn is_compatible(tx_version: u16, node_version: u16) -> bool {
    let tx_major = tx_version >> 8;
    let node_major = node_version >> 8;
    
    // Same major version required
    tx_major == node_major && tx_version <= node_version
}
```

**Future Versions:**
- `0x0002`: Add signature aggregation
- `0x0100`: Major upgrade (e.g., new proof system)
- `0x0101`: Add new transaction types

---

## 4. UTXO Transaction Format (Type 0x01)

### 4.1 Binary Structure

```rust
struct UTXOTransaction {
    // === HEADER (envelope fields) ===
    
    // === BODY ===
    inputs: Vec<UTXOInput>,
    outputs: Vec<UTXOOutput>,
    fee: u64,                           // Plaintext fee in leptons
    binding_value_balance: i64,         // Transparent value balance
    
    // === PROOF ===
    spend_proof: STARKProof,            // Proves input validity
    output_proof: STARKProof,           // Proves output well-formedness
    
    // === SIGNATURE ===
    binding_signature: DilithiumSignature,  // 2420 bytes
    
    // === AUXILIARY ===
    memo: Option<Vec<u8>>,              // Optional encrypted memo
    anchor: MerkleRoot,                 // UTXO set root at tx creation
}

struct UTXOInput {
    nullifier: [u8; 32],                // Derived nullifier (prevents double-spend)
    merkle_path: Vec<[u8; 32]>,         // Merkle proof (height 256)
    anchor_index: u32,                  // Historical anchor for async verification
}

struct UTXOOutput {
    commitment: [u8; 32],               // Note commitment
    ephemeral_pk: [u8; 800],            // ML-KEM-512 public key
    ciphertext: Vec<u8>,                // Encrypted (value || addr || memo)
    enc_randomness: [u8; 32],           // For recipient decryption
}
```

### 4.2 Canonical Serialization

**Wire Format (little-endian):**

```
[version: 2 bytes]
[tx_type: 1 byte = 0x01]
[shard_id: 1 byte]
[expiry_height: 8 bytes]
[reserved: 16 bytes]
[num_inputs: varint]
  [input_0]
    [nullifier: 32 bytes]
    [merkle_path_len: varint]
      [sibling_0: 32 bytes]
      ...
    [anchor_index: 4 bytes]
  ...
[num_outputs: varint]
  [output_0]
    [commitment: 32 bytes]
    [ephemeral_pk: 800 bytes]
    [ciphertext_len: varint]
      [ciphertext: variable]
    [enc_randomness: 32 bytes]
  ...
[fee: 8 bytes]
[binding_value_balance: 8 bytes (signed)]
[spend_proof]
  [proof_len: varint]
    [proof_bytes: variable]
[output_proof]
  [proof_len: varint]
    [proof_bytes: variable]
[binding_signature: 2420 bytes]
[memo_present: 1 byte (0 or 1)]
  [memo_len: varint if present]
    [memo: variable]
[anchor: 32 bytes]
```

**Varint Encoding:**
- Uses LEB128 (Little Endian Base 128)
- 1-10 bytes depending on value
- Most significant bit = continuation flag

```rust
fn encode_varint(mut value: u64) -> Vec<u8> {
    let mut bytes = Vec::new();
    loop {
        let mut byte = (value & 0x7F) as u8;
        value >>= 7;
        if value != 0 {
            byte |= 0x80;  // Continuation bit
        }
        bytes.push(byte);
        if value == 0 { break; }
    }
    bytes
}
```

### 4.3 Transaction Hash Calculation

```rust
fn compute_tx_hash(tx: &UTXOTransaction) -> [u8; 32] {
    let mut hasher = Shake256::default();
    
    // Domain separation
    hasher.update(b"ECLIPT_UTXO_TX_v1");
    
    // Serialize and hash (excluding signature and proofs)
    hasher.update(&tx.version.to_le_bytes());
    hasher.update(&[tx.tx_type]);
    hasher.update(&[tx.shard_id]);
    hasher.update(&tx.expiry_height.to_le_bytes());
    
    // Inputs (nullifiers only - proofs excluded)
    for input in &tx.inputs {
        hasher.update(&input.nullifier);
    }
    
    // Outputs (commitments only)
    for output in &tx.outputs {
        hasher.update(&output.commitment);
    }
    
    hasher.update(&tx.fee.to_le_bytes());
    hasher.update(&tx.binding_value_balance.to_le_bytes());
    hasher.update(&tx.anchor);
    
    let mut output = [0u8; 32];
    hasher.finalize_xof_into(&mut output);
    output
}
```

**Properties:**
- Excludes proofs and signatures (allows batch verification)
- Deterministic (same tx â†’ same hash)
- Collision-resistant (SHAKE-256 security)

### 4.4 Multi-Input/Multi-Output Privacy

**Unlinkability:**
- Each input uses unique nullifier (no common identifier)
- Each output uses fresh ephemeral key (ML-KEM-512)
- No amount linkage (all encrypted)
- Merkle path can reference different anchor heights

**Balance Proof (Zero-Knowledge):**

```
STARK Constraint System:

Public Inputs:
  - nullifiers: [nf_1, ..., nf_n]
  - output_commitments: [cm_1, ..., cm_m]
  - fee: u64
  - anchor: MerkleRoot

Private Witness:
  - input_values: [v_1, ..., v_n]
  - output_values: [v'_1, ..., v'_m]
  - randomness: [(r_1, addr_1), ..., (r_n, addr_n)]
  - nullifier_keys: [nk_1, ..., nk_n]

Constraints:
  1. âˆ€i: cm_i âˆˆ MerkleTree(anchor)      // Input membership
  2. âˆ€i: nf_i = PRF_nk_i(cm_i || Ï_i)   // Nullifier correctness
  3. âˆ€j: cm'_j = Commit(v'_j, addr_j, r_j)  // Output well-formed
  4. Î£v_i = Î£v'_j + fee                 // Balance conservation
  5. âˆ€v: 0 â‰¤ v < 2^64                   // Range constraints
```

**Proof Size Optimization:**
- Recursive STARK: aggregate all inputs/outputs into single proof
- Target: < 100 KB for 16 inputs + 16 outputs
- Verification: < 500 ms

---

## 5. Account Transaction Format (Type 0x02)

### 5.1 Binary Structure

```rust
struct AccountTransaction {
    // === HEADER (envelope fields) ===
    
    // === BODY ===
    from: Address,                      // 20 bytes (SHAKE-256 of pubkey)
    to: Address,                        // 20 bytes
    nonce: u64,                         // Replay protection
    encrypted_amount: Ciphertext,       // ML-KEM-512 encrypted
    gas_limit: u64,
    gas_price: u64,
    data: Vec<u8>,                      // Optional payload (contract calls)
    
    // === PROOF ===
    balance_proof: STARKProof,          // Proves sufficient balance
    
    // === SIGNATURE ===
    signature: DilithiumSignature,      // 2420 bytes (signs tx_hash)
}

type Address = [u8; 20];  // First 20 bytes of SHAKE-256(pubkey)
type Ciphertext = [u8; 768];  // ML-KEM-512 ciphertext
```

### 5.2 Canonical Serialization

```
[version: 2 bytes]
[tx_type: 1 byte = 0x02]
[shard_id: 1 byte]
[expiry_height: 8 bytes]
[reserved: 16 bytes]
[from: 20 bytes]
[to: 20 bytes]
[nonce: 8 bytes]
[encrypted_amount: 768 bytes]
[gas_limit: 8 bytes]
[gas_price: 8 bytes]
[data_len: varint]
  [data: variable]
[balance_proof]
  [proof_len: varint]
    [proof_bytes: variable]
[signature: 2420 bytes]
```

### 5.3 Nonce Management

**Mempool Ordering:**

```rust
struct MempoolEntry {
    tx: AccountTransaction,
    insertion_time: u64,
    priority: u128,  // gas_price * (MAX_NONCE - nonce_gap)
}

fn compute_nonce_gap(tx: &AccountTransaction, state: &State) -> u64 {
    let current_nonce = state.get_account(tx.from).nonce;
    tx.nonce.saturating_sub(current_nonce + 1)
}

// Mempool sorts by priority (higher = included first)
fn compute_priority(tx: &AccountTransaction, state: &State) -> u128 {
    let gap = compute_nonce_gap(tx, state);
    let gap_penalty = if gap > 0 { 1000u128.pow(gap as u32) } else { 1 };
    (tx.gas_price as u128) / gap_penalty
}
```

**Nonce Gap Handling:**
- Transactions with future nonces held in mempool
- Maximum gap allowed: 16 nonces
- Timeout: 256 blocks (â‰ˆ2 minutes at 500ms blocks)
- After timeout: evicted from mempool

**Nonce Recovery (Chain Reorganization):**

```rust
fn handle_reorg(reverted_txs: Vec<AccountTransaction>, new_state: &State) {
    for tx in reverted_txs {
        let current_nonce = new_state.get_account(tx.from).nonce;
        
        if tx.nonce > current_nonce {
            // Valid nonce in new chain - return to mempool
            mempool.insert(tx);
        } else {
            // Already included or invalidated - discard
            discard(tx);
        }
    }
}
```

---

## 6. Cross-Shard Transaction Format (Type 0x08)

### 6.1 Two-Phase Commit Structure

```rust
struct CrossShardTransaction {
    // === HEADER ===
    version: u16,
    tx_type: u8,                        // 0x08
    source_shard: u8,
    dest_shard: u8,
    expiry_height: u64,
    
    // === PHASE 1: PREPARE ===
    phase1_tx: AccountTransaction,      // Transaction on source shard
    
    // === PHASE 2: COMMIT ===
    phase2_receipt: Receipt,            // Receipt from source shard
    phase2_proof: ReceiptProof,         // Merkle proof of receipt
    
    // === METADATA ===
    coordinator_sig: DilithiumSignature, // Signed by cross-shard coordinator
}

struct Receipt {
    tx_hash: [u8; 32],
    source_shard: u8,
    source_height: u64,
    locked_amount: u64,                 // Escrowed amount
    recipient: Address,
    commitment: [u8; 32],               // Receipt commitment
}

struct ReceiptProof {
    receipt_root: [u8; 32],             // Shard receipt Merkle root
    merkle_path: Vec<[u8; 32]>,
    receipt_index: u32,
}
```

### 6.2 Cross-Shard Lifecycle

**Phase 1 (Source Shard - PREPARE):**

```
1. User submits CrossShardTransaction to Source Shard
2. Source Shard validates:
   - Signature verification
   - Balance check
   - Nonce check
3. Source Shard locks amount in escrow:
   Account(from).locked_balance += amount
   Account(from).balance -= amount
4. Source Shard emits Receipt:
   receipt = Receipt {
       tx_hash: compute_tx_hash(phase1_tx),
       source_shard: shard_id,
       source_height: current_height,
       locked_amount: amount,
       recipient: to_address,
       commitment: SHAKE-256(tx_hash || amount || recipient)
   }
5. Receipt added to shard receipt Merkle tree
```

**Phase 2 (Destination Shard - COMMIT):**

```
1. User (or relayer) submits Phase 2 to Destination Shard
2. Destination Shard verifies:
   - Receipt Merkle proof (via cross-shard verification)
   - Receipt not already consumed (check nullifier)
   - Expiry not exceeded
3. Destination Shard credits recipient:
   Account(recipient).balance += locked_amount
4. Destination Shard emits Commit event
5. Beacon chain observes both Phase 1 + Phase 2 finality
```

**Timeout & Rollback:**

```
If Phase 2 not completed within timeout (e.g., 512 blocks):
1. Source Shard unlocks escrowed funds:
   Account(from).locked_balance -= amount
   Account(from).balance += amount
2. Receipt marked as expired (cannot be redeemed)
```

### 6.3 Receipt Nullifier

To prevent double-redemption:

```rust
receipt_nullifier = SHAKE-256(
    receipt.commitment || 
    receipt.source_shard || 
    receipt.source_height ||
    b"ECLIPT_RECEIPT_NF_v1"
)
```

Destination shard maintains nullifier set: $\mathcal{N}_{\text{receipts}}$

---

## 7. Signature Scheme

### 7.1 ML-DSA (Dilithium-3) Parameters

**NIST PQ Standard:** FIPS 204

| Parameter         | Value                        |
| ----------------- | ---------------------------- |
| Security Level    | 3 (192-bit quantum security) |
| Public Key Size   | 1952 bytes                   |
| Secret Key Size   | 4000 bytes                   |
| Signature Size    | 2420 bytes                   |
| Signing Time      | ~1.2 ms (AVX2)               |
| Verification Time | ~0.5 ms (AVX2)               |

### 7.2 Signature Format

```rust
struct DilithiumSignature {
    z: [u8; 1024],      // Signature component 1
    h: [u8; 896],       // Hint bits (compressed)
    c: [u8; 500],       // Challenge hash
}

impl DilithiumSignature {
    fn serialize(&self) -> [u8; 2420] {
        let mut bytes = [0u8; 2420];
        bytes[0..1024].copy_from_slice(&self.z);
        bytes[1024..1920].copy_from_slice(&self.h);
        bytes[1920..2420].copy_from_slice(&self.c);
        bytes
    }
    
    fn deserialize(bytes: &[u8; 2420]) -> Self {
        Self {
            z: bytes[0..1024].try_into().unwrap(),
            h: bytes[1024..1920].try_into().unwrap(),
            c: bytes[1920..2420].try_into().unwrap(),
        }
    }
}
```

### 7.3 Signature Domain Separation

**Message to Sign:**

```rust
fn prepare_signing_message(tx: &Transaction) -> Vec<u8> {
    let mut message = Vec::new();
    
    // Domain separator
    message.extend_from_slice(b"ECLIPT_TX_SIG_v1");
    
    // Chain ID (prevents cross-chain replay)
    message.extend_from_slice(&CHAIN_ID.to_le_bytes());
    
    // Transaction hash
    message.extend_from_slice(&compute_tx_hash(tx));
    
    message
}

fn sign_transaction(tx: &Transaction, secret_key: &DilithiumSecretKey) -> DilithiumSignature {
    let message = prepare_signing_message(tx);
    dilithium3_sign(&message, secret_key)
}
```

### 7.4 Batch Signature Verification (Future)

**Motivation:** Verify multiple signatures in parallel

**Approach (Version 0x0002):**
```rust
struct BatchSignatureProof {
    aggregate_commitment: [u8; 32],
    individual_responses: Vec<[u8; 1024]>,
    batch_proof: Vec<u8>,
}

// Verify N signatures in O(âˆšN) time using:
// - Multi-exponentiation techniques
// - Fiat-Shamir batching
// - SIMD parallelization
```

**Performance Target:**
- 1000 signatures verified in ~300 ms (vs. 500 ms sequential)
- Included in protocol version 0x0002

---

## 8. Transaction Expiration & Time-To-Live

### 8.1 Expiry Height Mechanism

**Purpose:**
- Prevent indefinite mempool storage
- Enable nonce reuse after expiry
- Reduce replay attack surface

**Implementation:**

```rust
struct Transaction {
    expiry_height: u64,  // Block height after which tx is invalid
    // ... other fields
}

fn validate_expiry(tx: &Transaction, current_height: u64) -> bool {
    if tx.expiry_height == 0 {
        // No expiry (legacy support)
        return true;
    }
    
    current_height < tx.expiry_height
}
```

**Default Expiry:**
- User-specified: any value
- Recommended: `current_height + 256` (â‰ˆ2 minutes)
- Maximum: `current_height + 4096` (â‰ˆ34 minutes)

**Mempool Behavior:**

```rust
fn prune_expired_transactions(mempool: &mut Mempool, current_height: u64) {
    mempool.retain(|tx| {
        if tx.expiry_height > 0 && current_height >= tx.expiry_height {
            emit_event(TxExpired { tx_hash: compute_tx_hash(tx) });
            false
        } else {
            true
        }
    });
}
```

### 8.2 Nonce Recovery After Expiry

```rust
fn can_reuse_nonce(account: &Account, nonce: u64, current_height: u64, mempool: &Mempool) -> bool {
    // Check if there's an expired tx with this nonce
    if let Some(expired_tx) = mempool.get_expired_tx(account.address, nonce) {
        current_height >= expired_tx.expiry_height
    } else {
        nonce == account.nonce + 1
    }
}
```

---

## 9. Fee Model & Estimation

### 9.1 Fee Components

**Total Fee:**

$$
\text{fee}_{\text{total}} = \text{fee}_{\text{base}} + \text{fee}_{\text{exec}} + \text{fee}_{\text{proof}} + \text{fee}_{\text{storage}}
$$

**Component Breakdown:**

| Component         | Formula                                      | Description                    |
| ----------------- | -------------------------------------------- | ------------------------------ |
| **Base Fee**      | $\alpha \times \text{size}_{\text{bytes}}$   | Per-byte cost (EIP-1559 style) |
| **Execution Fee** | $\beta \times \text{gas}_{\text{used}}$      | Computational cost             |
| **Proof Fee**     | $\gamma \times \text{proof}_{\text{size}}$   | zk-STARK verification cost     |
| **Storage Fee**   | $\delta \times \text{state}_{\text{growth}}$ | Long-term storage cost         |

### 9.2 Dynamic Base Fee (EIP-1559 Adaptation)

**Target Block Utilization:** 50% of max capacity

```rust
fn update_base_fee(
    prev_base_fee: u64,
    prev_block_gas: u64,
    target_gas: u64,
    max_gas: u64,
) -> u64 {
    let gas_used_delta = prev_block_gas as i128 - target_gas as i128;
    let base_fee_delta = (prev_base_fee as i128 * gas_used_delta) / (target_gas as i128 * 8);
    
    // Clamp to prevent extreme changes
    let new_base_fee = (prev_base_fee as i128 + base_fee_delta).clamp(
        MIN_BASE_FEE as i128,
        MAX_BASE_FEE as i128,
    );
    
    new_base_fee as u64
}
```

**Fee Burn:**
- 30-70% of base fee burned (deflationary pressure)
- Remaining distributed to validators

### 9.3 Gas Model

**Operation Costs:**

| Operation                   | Gas Cost | Rationale                 |
| --------------------------- | -------- | ------------------------- |
| Transaction base            | 21,000   | Fixed overhead            |
| UTXO input                  | 16,000   | Merkle proof verification |
| UTXO output                 | 8,000    | Commitment creation       |
| Account transfer            | 21,000   | Balance update + proof    |
| STARK proof verify (per KB) | 50,000   | Expensive computation     |
| Storage write (per word)    | 20,000   | Persistent state          |
| Storage read (per word)     | 800      | Cache-friendly            |
| ML-KEM decapsulation        | 5,000    | Post-quantum operation    |
| ML-DSA signature verify     | 3,000    | Post-quantum operation    |

**Example Gas Calculation (Account Transfer):**

```rust
fn estimate_gas_account_transfer(tx: &AccountTransaction) -> u64 {
    let mut gas = 21_000;  // Base
    
    // Proof verification
    gas += (tx.balance_proof.size() / 1024) * 50_000;
    
    // Signature verification
    gas += 3_000;
    
    // Data payload (if any)
    gas += (tx.data.len() as u64) * 16;
    
    gas
}
```

### 9.4 Fee Estimation Algorithm

**Client-Side Estimator:**

```rust
struct FeeEstimate {
    base_fee: u64,           // Current base fee
    priority_fee: u64,       // Suggested tip for fast inclusion
    max_fee: u64,            // Maximum willing to pay
    estimated_gas: u64,      // Expected gas consumption
    total_cost: u64,         // base_fee + priority_fee + gas
}

fn estimate_fee(
    tx: &Transaction,
    network_state: &NetworkState,
    urgency: Urgency,
) -> FeeEstimate {
    let estimated_gas = simulate_gas(tx, network_state);
    
    let base_fee = network_state.current_base_fee;
    
    let priority_fee = match urgency {
        Urgency::Low => percentile(&network_state.mempool_fees, 25),
        Urgency::Medium => percentile(&network_state.mempool_fees, 50),
        Urgency::High => percentile(&network_state.mempool_fees, 75),
        Urgency::Urgent => percentile(&network_state.mempool_fees, 95),
    };
    
    let max_fee = base_fee * 2 + priority_fee;  // Allow 2x base fee increase
    
    let total_cost = (base_fee + priority_fee) * estimated_gas;
    
    FeeEstimate {
        base_fee,
        priority_fee,
        max_fee,
        estimated_gas,
        total_cost,
    }
}

enum Urgency {
    Low,      // Included within 10 blocks (~5 seconds)
    Medium,   // Included within 4 blocks (~2 seconds)
    High,     // Included within 2 blocks (~1 second)
    Urgent,   // Included in next block
}
```

---

## 10. Transaction Lifecycle

### 10.1 State Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CREATED    â”‚ â† User constructs transaction
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ sign()
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SIGNED    â”‚ â† Valid signature attached
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ broadcast()
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IN_MEMPOOL â”‚ â† Gossiped to network, pending inclusion
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â†’ [EXPIRED] â† expiry_height reached
       â”‚
       â”œâ”€â”€â†’ [REPLACED] â† Higher-fee tx with same nonce
       â”‚
       â”‚ included_in_block()
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IN_BLOCK   â”‚ â† Included in proposed block
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â†’ [REVERTED] â† Block reorganization
       â”‚
       â”‚ finalized()
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FINALIZED  â”‚ â† Irreversible (after BFT finality)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10.2 Mempool Management

**Priority Queue Structure:**

```rust
struct Mempool {
    // Primary index: sorted by priority
    priority_queue: BTreeMap<Priority, TxHash>,
    
    // Secondary index: by sender address + nonce
    by_account: HashMap<Address, BTreeMap<u64, TxHash>>,
    
    // Transaction store
    transactions: HashMap<TxHash, MempoolEntry>,
    
    // Expiry tracking
    expiry_heap: BinaryHeap<(u64, TxHash)>,  // (expiry_height, tx_hash)
}

struct MempoolEntry {
    tx: Transaction,
    arrival_time: u64,
    gas_price: u64,
    estimated_gas: u64,
}

impl Mempool {
    fn insert(&mut self, tx: Transaction) -> Result<()> {
        // Validate
        validate_transaction(&tx)?;
        
        // Check for replacement
        if let Some(existing) = self.get_by_nonce(tx.from(), tx.nonce()) {
            if tx.gas_price <= existing.gas_price * 110 / 100 {
                return Err(Error::InsufficientFeeReplacement);
            }
            self.remove(existing.hash());
        }
        
        // Insert
        let tx_hash = compute_tx_hash(&tx);
        let priority = self.compute_priority(&tx);
        
        self.priority_queue.insert(priority, tx_hash);
        self.by_account.entry(tx.from()).or_default().insert(tx.nonce(), tx_hash);
        self.transactions.insert(tx_hash, MempoolEntry::new(tx));
        
        Ok(())
    }
    
    fn get_top_transactions(&self, limit: usize) -> Vec<Transaction> {
        self.priority_queue
            .iter()
            .rev()  // Highest priority first
            .take(limit)
            .filter_map(|(_, hash)| self.transactions.get(hash))
            .map(|entry| entry.tx.clone())
            .collect()
    }
}
```

### 10.3 Transaction Propagation

**Gossip Protocol:**

```rust
// libp2p GossipSub topics
const TX_GOSSIP_TOPIC: &str = "/ecliptica/tx/1.0.0";

fn propagate_transaction(tx: &Transaction) {
    // Serialize
    let tx_bytes = serialize_transaction(tx);
    
    // Compute hash for deduplication
    let tx_hash = compute_tx_hash(tx);
    
    // Gossip message
    let message = GossipMessage {
        tx_hash,
        tx_bytes,
        seen_by: vec![],  // Populated by relayers
    };
    
    // Publish to topic
    gossipsub.publish(TX_GOSSIP_TOPIC, message);
}

fn handle_gossip_transaction(message: GossipMessage) {
    let tx_hash = message.tx_hash;
    
    // Deduplication
    if seen_transactions.contains(&tx_hash) {
        return;
    }
    seen_transactions.insert(tx_hash);
    
    // Deserialize
    let tx = deserialize_transaction(&message.tx_bytes)?;
    
    // Validate
    if !validate_transaction(&tx) {
        blacklist_peer();
        return;
    }
    
    // Add to mempool
    mempool.insert(tx)?;
    
    // Re-broadcast (with updated seen_by)
    forward_gossip(message);
}
```

**Anti-Spam Protection:**

```rust
struct RateLimiter {
    limits: HashMap<PeerId, (u32, Instant)>,  // (count, window_start)
}

impl RateLimiter {
    fn check_rate_limit(&mut self, peer: PeerId) -> bool {
        let (count, window_start) = self.limits.entry(peer).or_insert((0, Instant::now()));
        
        // Reset window if expired (e.g., 10 seconds)
        if window_start.elapsed() > Duration::from_secs(10) {
            *count = 0;
            *window_start = Instant::now();
        }
        
        *count += 1;
        
        // Allow 100 tx/second per peer
        *count <= 1000
    }
}
```

### 10.4 Transaction Inclusion

**Block Proposer Selection:**

```rust
fn select_transactions_for_block(
    mempool: &Mempool,
    state: &State,
    gas_limit: u64,
) -> Vec<Transaction> {
    let mut selected = Vec::new();
    let mut gas_used = 0u64;
    
    // Get candidates (sorted by priority)
    let candidates = mempool.get_top_transactions(10_000);
    
    for tx in candidates {
        // Check state validity
        if !can_apply_transaction(&tx, state) {
            continue;
        }
        
        // Check gas limit
        let tx_gas = estimate_gas(&tx);
        if gas_used + tx_gas > gas_limit {
            continue;
        }
        
        // Add to block
        selected.push(tx.clone());
        gas_used += tx_gas;
        
        // Update temporary state (for nonce checking)
        apply_transaction_to_state(&tx, &mut state.clone());
    }
    
    selected
}
```

---

## 11. Transaction Validation Rules

### 11.1 Validation Checklist

```rust
fn validate_transaction(tx: &Transaction, state: &State) -> Result<()> {
    // 1. Format validation
    validate_format(tx)?;
    
    // 2. Version compatibility
    if !is_compatible(tx.version, PROTOCOL_VERSION) {
        return Err(Error::IncompatibleVersion);
    }
    
    // 3. Signature verification
    verify_signature(tx)?;
    
    // 4. Nonce check (Account transactions)
    if let Transaction::Account(acc_tx) = tx {
        let current_nonce = state.get_account(acc_tx.from).nonce;
        if acc_tx.nonce != current_nonce + 1 {
            return Err(Error::InvalidNonce);
        }
    }
    
    // 5. Balance check
    check_sufficient_balance(tx, state)?;
    
    // 6. Proof verification
    verify_zk_proof(tx)?;
    
    // 7. Fee sufficiency
    let estimated_gas = estimate_gas(tx);
    if tx.fee() < estimated_gas * state.base_fee {
        return Err(Error::InsufficientFee);
    }
    
    // 8. Expiry check
    if tx.expiry_height > 0 && state.current_height >= tx.expiry_height {
        return Err(Error::Expired);
    }
    
    // 9. Replay protection
    check_replay_protection(tx, state)?;
    
    Ok(())
}
```

### 11.2 Nullifier Uniqueness (UTXO)

```rust
fn check_nullifier_uniqueness(tx: &UTXOTransaction, state: &State) -> Result<()> {
    for input in &tx.inputs {
        if state.nullifier_set.contains(&input.nullifier) {
            return Err(Error::DoubleSpend);
        }
    }
    Ok(())
}
```

### 11.3 Merkle Proof Verification (UTXO)

```rust
fn verify_merkle_proof(
    commitment: &[u8; 32],
    path: &[[u8; 32]],
    anchor: &[u8; 32],
    index: u32,
) -> bool {
    let mut current = *commitment;
    let mut idx = index;
    
    for sibling in path {
        let (left, right) = if idx & 1 == 0 {
            (current, *sibling)
        } else {
            (*sibling, current)
        };
        
        current = shake256_hash(&[left, right].concat());
        idx >>= 1;
    }
    
    current == *anchor
}
```

---

## 12. Size Calculations & Optimization

### 12.1 Transaction Size Examples

| Transaction Type     | Typical Size | Max Size | Notes                     |
| -------------------- | ------------ | -------- | ------------------------- |
| **UTXO (1â†’2)**       | 4.8 KB       | 50 KB    | 1 input, 2 outputs, proof |
| **UTXO (16â†’16)**     | 45 KB        | 500 KB   | Multi-party coinjoin      |
| **Account Transfer** | 3.5 KB       | 10 KB    | With balance proof        |
| **Cross-Shard**      | 8 KB         | 20 KB    | Phase 1 + Phase 2         |
| **Contract Call**    | 5-100 KB     | 1 MB     | Data-dependent            |

### 12.2 Bandwidth Analysis

**Block Capacity:**
- Target: 50,000 TPS
- Block time: 500 ms
- Transactions per block: 25,000

**With 4 KB average transaction:**
- Block size: 100 MB
- Network bandwidth: 200 MB/s (200 Mbps)
- Daily storage: 17.3 TB

**Optimization Strategies:**
1. **Proof Compression**: Recursive STARK aggregation
2. **Signature Aggregation**: Batch verification (v0.0002)
3. **Delta Encoding**: Only broadcast state changes
4. **Erasure Coding**: Reduce redundancy in DA layer

---

## 13. Implementation Reference

### 13.1 Rust Type Definitions

```rust
// src/transaction/mod.rs

use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Transaction {
    UTXO(UTXOTransaction),
    Account(AccountTransaction),
    Shield(ShieldTransaction),
    Unshield(UnshieldTransaction),
    ContractCall(ContractCallTransaction),
    CrossShard(CrossShardTransaction),
    Stake(StakeTransaction),
    Unstake(UnstakeTransaction),
    Governance(GovernanceTransaction),
}

impl Transaction {
    pub fn compute_hash(&self) -> TxHash {
        match self {
            Self::UTXO(tx) => compute_utxo_tx_hash(tx),
            Self::Account(tx) => compute_account_tx_hash(tx),
            // ... other types
        }
    }
    
    pub fn verify(&self, state: &State) -> Result<()> {
        match self {
            Self::UTXO(tx) => verify_utxo_tx(tx, state),
            Self::Account(tx) => verify_account_tx(tx, state),
            // ... other types
        }
    }
    
    pub fn serialize_canonical(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        self.write_canonical(&mut buf).unwrap();
        buf
    }
}

type TxHash = [u8; 32];
```

### 13.2 Serialization Traits

```rust
pub trait CanonicalSerialize {
    fn write_canonical<W: Write>(&self, writer: &mut W) -> Result<()>;
    fn read_canonical<R: Read>(reader: &mut R) -> Result<Self> where Self: Sized;
}

impl CanonicalSerialize for u64 {
    fn write_canonical<W: Write>(&self, writer: &mut W) -> Result<()> {
        writer.write_all(&self.to_le_bytes())?;
        Ok(())
    }
    
    fn read_canonical<R: Read>(reader: &mut R) -> Result<Self> {
        let mut bytes = [0u8; 8];
        reader.read_exact(&mut bytes)?;
        Ok(u64::from_le_bytes(bytes))
    }
}

impl CanonicalSerialize for Vec<u8> {
    fn write_canonical<W: Write>(&self, writer: &mut W) -> Result<()> {
        write_varint(writer, self.len() as u64)?;
        writer.write_all(self)?;
        Ok(())
    }
    
    fn read_canonical<R: Read>(reader: &mut R) -> Result<Self> {
        let len = read_varint(reader)? as usize;
        let mut buf = vec![0u8; len];
        reader.read_exact(&mut buf)?;
        Ok(buf)
    }
}
```

---

## 14. Testing & Validation

### 14.1 Test Vectors

**Example UTXO Transaction (Hex):**

```
0100                                    # version (1)
01                                      # tx_type (UTXO)
00                                      # shard_id (0)
0000010000000000                        # expiry_height (256)
00000000000000000000000000000000        # reserved
01                                      # num_inputs (1)
  [32 bytes nullifier]
  08                                    # merkle_path_len (8 siblings, height 256)
    [32 bytes sibling_0]
    ...
  [4 bytes anchor_index]
02                                      # num_outputs (2)
  [32 bytes commitment]
  [800 bytes ephemeral_pk]
  [varint ciphertext_len]
    [ciphertext bytes]
  [32 bytes enc_randomness]
  ...
[8 bytes fee]
[8 bytes binding_value_balance]
[varint spend_proof_len]
  [proof bytes]
[varint output_proof_len]
  [proof bytes]
[2420 bytes binding_signature]
00                                      # memo_present (false)
[32 bytes anchor]
```

### 14.2 Fuzzing Targets

```rust
#[cfg(fuzzing)]
mod fuzz_tests {
    use libfuzzer_sys::fuzz_target;
    
    fuzz_target!(|data: &[u8]| {
        // Attempt to deserialize
        if let Ok(tx) = Transaction::read_canonical(&mut &data[..]) {
            // Verify serialization round-trip
            let serialized = tx.serialize_canonical();
            assert_eq!(data, serialized);
            
            // Verify hash determinism
            let hash1 = tx.compute_hash();
            let hash2 = tx.compute_hash();
            assert_eq!(hash1, hash2);
        }
    });
}
```

---

## 15. Open Questions & Future Work

1. **Confidential Smart Contracts**: How to handle encrypted state in WASM contracts?

2. **Transaction Ordering Fairness**: MEV protection via encrypted mempool or threshold decryption?

3. **Signature Aggregation**: Efficient batch verification for ML-DSA signatures?

4. **Multi-Party Transactions**: Atomic swaps and coinjoin protocols with privacy?

5. **Fee Market Dynamics**: Optimal base fee adjustment algorithm under high variance?

---

**Document ID:** `ECLIPT-TX-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review

---

## Appendix A: Binary Encoding Reference Card

| Type        | Size          | Encoding                       | Notes              |
| ----------- | ------------- | ------------------------------ | ------------------ |
| `u8`        | 1 byte        | Raw byte                       |                    |
| `u16`       | 2 bytes       | Little-endian                  |                    |
| `u32`       | 4 bytes       | Little-endian                  |                    |
| `u64`       | 8 bytes       | Little-endian                  |                    |
| `i64`       | 8 bytes       | Little-endian two's complement |                    |
| `[u8; N]`   | N bytes       | Raw bytes                      | Fixed array        |
| `Vec<u8>`   | varint + data | Length-prefixed                | Variable array     |
| `Option<T>` | 1 + T         | 0x00 (None) or 0x01 + T (Some) |                    |
| `Address`   | 20 bytes      | Raw bytes                      | SHAKE-256 hash     |
| `TxHash`    | 32 bytes      | Raw bytes                      | SHAKE-256 output   |
| `Signature` | 2420 bytes    | Raw bytes                      | ML-DSA Dilithium-3 |

## Appendix B: Gas Cost Table (Complete)

| Operation     | Base Cost | Per-Byte Cost | Notes                     |
| ------------- | --------- | ------------- | ------------------------- |
| TX_BASE       | 21,000    | -             | Fixed per transaction     |
| UTXO_INPUT    | 16,000    | -             | Merkle proof verification |
| UTXO_OUTPUT   | 8,000     | -             | Commitment creation       |
| ACCOUNT_TX    | 21,000    | -             | Balance update            |
| STARK_VERIFY  | 50,000    | per KB        | Expensive computation     |
| STORAGE_WRITE | 20,000    | -             | Per 32-byte word          |
| STORAGE_READ  | 800       | -             | Cache-friendly            |
| MLKEM_DECAP   | 5,000     | -             | Post-quantum KEM          |
| MLDSA_VERIFY  | 3,000     | -             | Post-quantum signature    |
| DATA_COPY     | -         | 16            | Memory operations         |
| CROSS_SHARD   | 100,000   | -             | 2PC overhead              |