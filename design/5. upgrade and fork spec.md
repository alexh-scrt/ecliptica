# ðŸ”„ **Ecliptica Upgrade & Fork Management Specification**

### *Protocol Evolution & Governance for Post-Quantum Privacy Blockchain*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-UPGRADE-001`  
**Depends On:** `ECLIPT-GENESIS-001`, `ECLIPT-STATE-001`

---

## 1. Executive Summary

Ecliptica's upgrade framework balances **protocol evolution** with **network stability**, enabling:

- **Seamless Upgrades**: Coordinated hard forks without network splits
- **Backwards Compatibility**: Clear migration paths for soft forks
- **Emergency Response**: Rapid security patches within 24 hours
- **Decentralized Governance**: Validator and stakeholder voting
- **Version Negotiation**: Automatic peer compatibility detection

**Key Principles:**
- **Safety First**: No upgrade proceeds without â‰¥80% validator support
- **Transparency**: All upgrades publicly proposed and audited
- **Reversibility**: Emergency rollback procedures for critical failures
- **Post-Quantum Security**: All upgrade mechanisms use ML-DSA signatures

---

## 2. Upgrade Classification

### 2.1 Upgrade Types

| Type                | Definition               | Compatibility         | Activation               | Examples                                  |
| ------------------- | ------------------------ | --------------------- | ------------------------ | ----------------------------------------- |
| **Soft Fork**       | Tightens consensus rules | Forward-compatible    | Miner/validator majority | New opcode restrictions, gas cost changes |
| **Hard Fork**       | Expands consensus rules  | Backward-incompatible | Scheduled block height   | Protocol version bump, new cryptography   |
| **Emergency Patch** | Critical security fix    | May be incompatible   | Immediate or 24h window  | Zero-day vulnerability, consensus bug     |
| **Client Update**   | Bug fixes, optimizations | Fully compatible      | Rolling deployment       | Performance improvements, UI changes      |

### 2.2 Version Numbering Scheme

**Format:** `MAJOR.MINOR.PATCH` (Semantic Versioning)

```rust
struct ProtocolVersion {
    major: u8,    // Breaking changes (hard fork)
    minor: u8,    // New features (soft fork or compatible)
    patch: u8,    // Bug fixes (always compatible)
}

impl ProtocolVersion {
    fn is_compatible_with(&self, other: &Self) -> bool {
        // Same major version required
        if self.major != other.major {
            return false;
        }
        
        // Higher minor version can talk to lower (forward compat)
        self.minor >= other.minor || other.minor >= self.minor
    }
    
    fn requires_hard_fork(&self, current: &Self) -> bool {
        self.major > current.major
    }
    
    fn to_u32(&self) -> u32 {
        ((self.major as u32) << 16) | ((self.minor as u32) << 8) | (self.patch as u32)
    }
}
```

**Examples:**
- `v1.0.0` â†’ `v1.1.0`: Soft fork (new features, backward compatible)
- `v1.1.0` â†’ `v1.1.1`: Client update (bug fix)
- `v1.5.2` â†’ `v2.0.0`: Hard fork (breaking changes)

### 2.3 Feature Flags

```rust
struct FeatureFlags {
    // Bitmask of enabled features
    flags: u64,
}

// Feature definitions
const FEATURE_CROSS_SHARD_V2: u64       = 1 << 0;  // Optimized 2PC
const FEATURE_AGGREGATED_SIGNATURES: u64 = 1 << 1;  // Batch sig verification
const FEATURE_ZK_RECURSION: u64          = 1 << 2;  // Recursive STARKs
const FEATURE_ENCRYPTED_MEMPOOL: u64     = 1 << 3;  // Private mempool
const FEATURE_STATELESS_CLIENTS: u64     = 1 << 4;  // Light client improvements
const FEATURE_DYNAMIC_SHARDING: u64      = 1 << 5;  // Shard count adjustment

impl FeatureFlags {
    fn is_enabled(&self, feature: u64) -> bool {
        (self.flags & feature) != 0
    }
    
    fn enable(&mut self, feature: u64) {
        self.flags |= feature;
    }
    
    fn from_version(version: &ProtocolVersion) -> Self {
        let mut flags = Self { flags: 0 };
        
        // v1.1.0 enables aggregated signatures
        if version >= &ProtocolVersion { major: 1, minor: 1, patch: 0 } {
            flags.enable(FEATURE_AGGREGATED_SIGNATURES);
        }
        
        // v1.2.0 enables zk recursion
        if version >= &ProtocolVersion { major: 1, minor: 2, patch: 0 } {
            flags.enable(FEATURE_ZK_RECURSION);
        }
        
        // v2.0.0 enables dynamic sharding
        if version >= &ProtocolVersion { major: 2, minor: 0, patch: 0 } {
            flags.enable(FEATURE_DYNAMIC_SHARDING);
        }
        
        flags
    }
}
```

---

## 3. Hard Fork Coordination

### 3.1 Proposal Process

**Step 1: Proposal Submission (EIP-style)**

```rust
struct UpgradeProposal {
    // Identity
    proposal_id: u64,              // Sequential ID
    title: String,                 // "Upgrade to v2.0: Dynamic Sharding"
    
    // Content
    description: String,           // Detailed specification
    specification_url: String,     // Link to full spec (IPFS/GitHub)
    
    // Version info
    current_version: ProtocolVersion,
    target_version: ProtocolVersion,
    upgrade_type: UpgradeType,
    
    // Activation
    activation_height: Option<u64>, // Scheduled block height
    min_validator_support: f64,     // Required threshold (e.g., 0.80)
    voting_period: u64,             // Blocks for voting (e.g., 100,800 = ~2 weeks)
    
    // Implementation
    code_changes: Vec<String>,      // List of affected modules
    test_vectors: Vec<u8>,          // Serialized test cases
    
    // Author
    proposer: Address,
    proposer_signature: DilithiumSignature,
    
    // Status
    submitted_at: u64,              // Block height
    voting_starts_at: u64,
    voting_ends_at: u64,
}

enum UpgradeType {
    SoftFork,
    HardFork,
    EmergencyPatch,
}
```

**Example Proposal:**

```rust
let proposal = UpgradeProposal {
    proposal_id: 42,
    title: "EIP-42: Implement Recursive zk-STARK Aggregation".to_string(),
    description: "Enable recursive proof compression for cross-shard finality...".to_string(),
    specification_url: "ipfs://QmAbc123.../EIP-42.md".to_string(),
    
    current_version: ProtocolVersion { major: 1, minor: 1, patch: 0 },
    target_version: ProtocolVersion { major: 1, minor: 2, patch: 0 },
    upgrade_type: UpgradeType::SoftFork,
    
    activation_height: Some(current_height + 201_600),  // ~4 weeks
    min_validator_support: 0.80,
    voting_period: 100_800,  // 2 weeks
    
    code_changes: vec![
        "consensus/finality.rs".to_string(),
        "zk/aggregation.rs".to_string(),
        "beacon/verification.rs".to_string(),
    ],
    test_vectors: load_test_vectors(),
    
    proposer: governance_multisig,
    proposer_signature: sign_proposal(&proposal_data, &governance_sk),
    
    submitted_at: current_height,
    voting_starts_at: current_height + 14_400,  // +3 days review period
    voting_ends_at: current_height + 115_200,   // +2 weeks
};
```

**Step 2: Community Review (3-7 days)**

```rust
struct ProposalReview {
    proposal_id: u64,
    
    // Audits
    security_audits: Vec<AuditReport>,
    performance_benchmarks: Vec<BenchmarkResult>,
    
    // Feedback
    community_comments: Vec<Comment>,
    concerns_raised: Vec<Concern>,
    
    // Testnet deployment
    testnet_results: Option<TestnetDeployment>,
}

struct AuditReport {
    auditor: String,              // "Trail of Bits", "OpenZeppelin"
    report_url: String,           // IPFS link
    severity_issues: Vec<Issue>,
    recommendation: AuditRecommendation,
}

enum AuditRecommendation {
    Approve,
    ApproveWithConditions(Vec<String>),
    Reject,
}
```

**Step 3: Validator Voting**

```rust
struct Vote {
    proposal_id: u64,
    voter: Address,               // Validator address
    vote: VoteChoice,
    stake_weight: u64,            // Voting power
    signature: DilithiumSignature,
    voted_at: u64,
}

enum VoteChoice {
    Yes,
    No,
    Abstain,
}

fn cast_vote(
    proposal_id: u64,
    choice: VoteChoice,
    validator_sk: &DilithiumSecretKey,
) -> Result<Vote> {
    let validator = get_validator_state()?;
    
    // Ensure validator is active
    if !validator.is_active {
        return Err(Error::ValidatorNotActive);
    }
    
    // Ensure within voting period
    let proposal = get_proposal(proposal_id)?;
    let current_height = get_current_height();
    
    if current_height < proposal.voting_starts_at || current_height > proposal.voting_ends_at {
        return Err(Error::VotingPeriodClosed);
    }
    
    // Create vote
    let vote = Vote {
        proposal_id,
        voter: validator.address,
        vote: choice,
        stake_weight: validator.total_stake,
        signature: sign_vote(&vote_data, validator_sk),
        voted_at: current_height,
    };
    
    // Submit on-chain
    submit_vote_transaction(vote)?;
    
    Ok(vote)
}
```

**Step 4: Vote Tally**

```rust
struct VoteResult {
    proposal_id: u64,
    
    // Vote counts
    yes_stake: u64,
    no_stake: u64,
    abstain_stake: u64,
    total_stake: u64,
    
    // Participation
    voters: Vec<Address>,
    participation_rate: f64,
    
    // Result
    passed: bool,
    threshold_met: bool,
    
    // Finalization
    tally_height: u64,
}

fn tally_votes(proposal_id: u64) -> Result<VoteResult> {
    let proposal = get_proposal(proposal_id)?;
    let votes = get_all_votes(proposal_id)?;
    
    let mut yes_stake = 0u64;
    let mut no_stake = 0u64;
    let mut abstain_stake = 0u64;
    let mut voters = Vec::new();
    
    for vote in votes {
        voters.push(vote.voter);
        
        match vote.vote {
            VoteChoice::Yes => yes_stake += vote.stake_weight,
            VoteChoice::No => no_stake += vote.stake_weight,
            VoteChoice::Abstain => abstain_stake += vote.stake_weight,
        }
    }
    
    let total_stake = get_total_validator_stake()?;
    let yes_ratio = yes_stake as f64 / total_stake as f64;
    let participation_rate = (yes_stake + no_stake + abstain_stake) as f64 / total_stake as f64;
    
    let threshold_met = yes_ratio >= proposal.min_validator_support;
    let passed = threshold_met && (yes_stake > no_stake);
    
    Ok(VoteResult {
        proposal_id,
        yes_stake,
        no_stake,
        abstain_stake,
        total_stake,
        voters,
        participation_rate,
        passed,
        threshold_met,
        tally_height: get_current_height(),
    })
}
```

### 3.2 Activation Mechanism

**Scheduled Activation (Block Height)**

```rust
struct ActivationConfig {
    proposal_id: u64,
    target_version: ProtocolVersion,
    activation_height: u64,
    feature_flags: FeatureFlags,
}

fn check_activation(current_height: u64) -> Option<ActivationConfig> {
    // Check if any approved upgrades activate at this height
    for upgrade in get_approved_upgrades() {
        if upgrade.activation_height == current_height {
            return Some(ActivationConfig {
                proposal_id: upgrade.proposal_id,
                target_version: upgrade.target_version,
                activation_height: current_height,
                feature_flags: FeatureFlags::from_version(&upgrade.target_version),
            });
        }
    }
    None
}

fn activate_upgrade(config: ActivationConfig) -> Result<()> {
    // 1. Validate all nodes support new version
    validate_network_readiness(&config)?;
    
    // 2. Apply state migration (if needed)
    if let Some(migration) = get_state_migration(config.target_version) {
        apply_state_migration(migration)?;
    }
    
    // 3. Update protocol version
    set_protocol_version(config.target_version)?;
    
    // 4. Enable new features
    set_feature_flags(config.feature_flags)?;
    
    // 5. Log activation
    log_upgrade_event(UpgradeEvent::Activated {
        proposal_id: config.proposal_id,
        height: config.activation_height,
        version: config.target_version,
    });
    
    Ok(())
}
```

**Signaling-Based Activation (BIP-9 style)**

```rust
struct SignalingState {
    // Signaling window
    window_start: u64,
    window_size: u64,              // e.g., 10,080 blocks (1 week)
    
    // Thresholds
    activation_threshold: f64,      // e.g., 95% of blocks
    
    // Tracking
    blocks_signaling: u64,
    total_blocks: u64,
    
    // Status
    status: SignalingStatus,
}

enum SignalingStatus {
    Defined,        // Proposal defined, not yet signaling
    Started,        // Signaling period active
    LockedIn,       // Threshold reached, will activate
    Active,         // Feature is active
    Failed,         // Did not reach threshold
}

fn check_signaling(block: &Block, upgrade: &UpgradeProposal) -> SignalingState {
    let window_start = (block.height / SIGNALING_WINDOW) * SIGNALING_WINDOW;
    let window_end = window_start + SIGNALING_WINDOW;
    
    // Count blocks signaling support
    let signaling_count = count_signaling_blocks(window_start, block.height, upgrade.proposal_id);
    let total_blocks = block.height - window_start;
    
    let ratio = signaling_count as f64 / SIGNALING_WINDOW as f64;
    
    let status = if ratio >= upgrade.min_validator_support {
        SignalingStatus::LockedIn
    } else if block.height == window_end {
        SignalingStatus::Failed
    } else {
        SignalingStatus::Started
    };
    
    SignalingState {
        window_start,
        window_size: SIGNALING_WINDOW,
        activation_threshold: upgrade.min_validator_support,
        blocks_signaling: signaling_count,
        total_blocks,
        status,
    }
}
```

### 3.3 Hard Fork Checklist

**Pre-Activation (T-4 weeks):**
- [ ] Proposal approved by â‰¥80% validator stake
- [ ] Security audits completed and published
- [ ] Testnet deployment successful (â‰¥2 weeks runtime)
- [ ] Client software released (â‰¥3 independent implementations)
- [ ] Documentation updated
- [ ] Community notified (blog, social media, validator calls)

**Pre-Activation (T-1 week):**
- [ ] â‰¥90% of validators upgraded to new software
- [ ] Exchange integrations confirmed
- [ ] Block explorer support ready
- [ ] Wallet support confirmed
- [ ] Monitoring dashboards updated

**Activation Day (T-0):**
- [ ] Monitor block production continuously
- [ ] Emergency response team on standby
- [ ] Communication channels active (Discord, Telegram)
- [ ] Rollback plan ready (if needed)

**Post-Activation (T+24 hours):**
- [ ] No consensus failures detected
- [ ] New features functioning correctly
- [ ] Performance metrics within bounds
- [ ] No critical bugs reported

---

## 4. Soft Fork Strategy

### 4.1 Soft Fork Definition

**Key Property:** Old nodes accept new blocks, but new nodes reject some blocks that old nodes would accept.

**Examples:**
- Tightening validation rules (e.g., lower gas limit)
- Adding new opcodes (that old nodes treat as no-ops)
- Enabling new transaction types (that old nodes ignore)

### 4.2 Soft Fork Activation

```rust
fn activate_soft_fork(fork_config: SoftForkConfig) -> Result<()> {
    // Soft forks can activate with majority (>50%) support
    let support = get_validator_support(&fork_config)?;
    
    if support < 0.51 {
        return Err(Error::InsufficientSupport);
    }
    
    // Enable new rules immediately for upgraded nodes
    enable_new_consensus_rules(&fork_config.rules)?;
    
    // Old nodes will follow majority chain automatically
    Ok(())
}
```

### 4.3 Soft Fork Example: Gas Cost Adjustment

```rust
// Before soft fork (v1.0)
const GAS_COST_SSTORE: u64 = 20_000;

// After soft fork (v1.1)
const GAS_COST_SSTORE: u64 = 22_000;  // Increased

// Migration logic
fn get_gas_cost_sstore(version: &ProtocolVersion) -> u64 {
    if version >= &ProtocolVersion { major: 1, minor: 1, patch: 0 } {
        22_000  // New nodes enforce higher cost
    } else {
        20_000  // Old nodes use old cost
    }
}

// Compatibility: Old nodes accept blocks from new nodes
// because new nodes enforce stricter rules (higher gas costs)
```

---

## 5. Emergency Patch Process

### 5.1 Emergency Classification

**Severity Levels:**

```rust
enum EmergencySeverity {
    Critical,   // Active exploit, network halt, consensus failure
    High,       // Potential exploit, performance degradation
    Medium,     // Minor bug, non-critical issue
    Low,        // Enhancement, optimization
}

struct EmergencyPatch {
    severity: EmergencySeverity,
    issue: String,                  // CVE-ID or description
    affected_versions: Vec<ProtocolVersion>,
    patch_version: ProtocolVersion,
    
    // Activation timeline
    discovery_time: SystemTime,
    patch_release_time: SystemTime,
    activation_deadline: SystemTime,
    
    // Patch content
    code_diff: String,              // Git diff
    binary_url: String,             // Pre-compiled binaries
    signature: DilithiumSignature,  // Signed by security team
}
```

**Response Timelines:**

| Severity     | Disclosure         | Patch Release | Activation             |
| ------------ | ------------------ | ------------- | ---------------------- |
| **Critical** | Private (0-24h)    | 0-24 hours    | Immediate              |
| **High**     | Private (1-7 days) | 1-3 days      | 24-48 hours            |
| **Medium**   | Public             | 1-2 weeks     | Next scheduled upgrade |
| **Low**      | Public             | Next release  | Next scheduled upgrade |

### 5.2 Emergency Response Workflow

**Step 1: Vulnerability Discovery**

```rust
fn report_vulnerability(report: VulnerabilityReport) -> Result<()> {
    // Encrypted submission to security team
    let encrypted_report = mlkem_encrypt(&SECURITY_TEAM_PUBKEY, &serialize(&report));
    
    submit_to_bugtracker(encrypted_report)?;
    
    // Automatic notification
    notify_security_team()?;
    
    Ok(())
}

struct VulnerabilityReport {
    reporter: String,               // Encrypted identity
    title: String,
    description: String,
    proof_of_concept: Option<Vec<u8>>,
    affected_components: Vec<String>,
    severity_estimate: EmergencySeverity,
}
```

**Step 2: Triage & Assessment (0-6 hours)**

```rust
fn triage_vulnerability(report: VulnerabilityReport) -> TriageResult {
    // Security team assessment
    let severity = assess_severity(&report);
    let exploitability = assess_exploitability(&report);
    let impact = assess_impact(&report);
    
    TriageResult {
        confirmed: is_valid_vulnerability(&report),
        severity,
        exploitability,
        impact,
        recommended_action: determine_action(severity, exploitability, impact),
    }
}

struct TriageResult {
    confirmed: bool,
    severity: EmergencySeverity,
    exploitability: Exploitability,
    impact: Impact,
    recommended_action: EmergencyAction,
}

enum EmergencyAction {
    ImmediatePatch,         // Critical: Deploy within 24h
    ScheduledPatch,         // High: Deploy within 1 week
    RegularRelease,         // Medium/Low: Next regular release
    NoAction,               // False positive or duplicate
}
```

**Step 3: Patch Development (0-24 hours for Critical)**

```rust
fn develop_emergency_patch(issue: TriageResult) -> EmergencyPatch {
    // 1. Implement fix
    let fix = implement_fix(&issue)?;
    
    // 2. Test fix
    run_regression_tests(&fix)?;
    run_exploit_tests(&fix, &issue)?;
    
    // 3. Create patch
    let patch = EmergencyPatch {
        severity: issue.severity,
        issue: issue.description,
        affected_versions: detect_affected_versions(&issue),
        patch_version: increment_patch_version(CURRENT_VERSION),
        
        discovery_time: SystemTime::now(),
        patch_release_time: SystemTime::now() + Duration::from_hours(12),
        activation_deadline: SystemTime::now() + Duration::from_hours(24),
        
        code_diff: generate_diff(&fix),
        binary_url: build_and_publish_binary(&fix)?,
        signature: sign_patch(&patch, &SECURITY_TEAM_SK),
    };
    
    patch
}
```

**Step 4: Coordinated Disclosure**

```rust
fn coordinate_emergency_patch(patch: EmergencyPatch) -> Result<()> {
    match patch.severity {
        EmergencySeverity::Critical => {
            // 1. Private notification to validators (0-6h before public)
            notify_validators_privately(&patch)?;
            
            // 2. Public disclosure after validators patched
            wait_for_validator_quorum(0.67)?;  // 2/3 patched
            
            // 3. Public announcement
            publish_security_advisory(&patch)?;
        },
        
        EmergencySeverity::High => {
            // 1. Private notification (24h lead time)
            notify_validators_privately(&patch)?;
            
            // 2. Public disclosure after 24h
            sleep(Duration::from_secs(86400));
            publish_security_advisory(&patch)?;
        },
        
        _ => {
            // Immediate public disclosure for non-critical
            publish_security_advisory(&patch)?;
        }
    }
    
    Ok(())
}
```

**Step 5: Emergency Activation**

```rust
fn activate_emergency_patch(patch: EmergencyPatch) -> Result<()> {
    match patch.severity {
        EmergencySeverity::Critical => {
            // Immediate activation without voting
            // Requires multi-sig from security team + foundation
            
            let activation_height = current_height + 10;  // 10 block grace period
            
            broadcast_emergency_upgrade(UpgradeMessage {
                patch_version: patch.patch_version,
                activation_height,
                emergency: true,
                signature: patch.signature,
            })?;
            
            // Validators must upgrade or halt
            enforce_version_at_height(activation_height, patch.patch_version)?;
        },
        
        _ => {
            // Normal activation process
            schedule_upgrade(patch.patch_version, current_height + 14_400)?;  // +3 days
        }
    }
    
    Ok(())
}
```

### 5.3 Emergency Rollback

**Trigger Conditions:**
- Critical bug in emergency patch
- Unintended consensus split
- Catastrophic performance degradation

```rust
fn emergency_rollback(reason: RollbackReason) -> Result<()> {
    // Requires multi-sig authorization
    let rollback_authorization = collect_rollback_signatures()?;
    
    if rollback_authorization.signatures.len() < EMERGENCY_MULTISIG_THRESHOLD {
        return Err(Error::InsufficientAuthorization);
    }
    
    // 1. Broadcast rollback signal
    broadcast_rollback_signal(RollbackSignal {
        target_height: current_height - 100,  // Rollback 100 blocks
        target_version: PREVIOUS_STABLE_VERSION,
        reason: reason.clone(),
        authorization: rollback_authorization,
    })?;
    
    // 2. Revert to previous version
    revert_to_version(PREVIOUS_STABLE_VERSION)?;
    
    // 3. Restore state from snapshot
    restore_state_snapshot(current_height - 100)?;
    
    // 4. Resume consensus
    resume_consensus()?;
    
    // 5. Post-mortem
    schedule_postmortem_report(reason)?;
    
    Ok(())
}

struct RollbackReason {
    description: String,
    affected_components: Vec<String>,
    severity: EmergencySeverity,
    incident_report_url: String,
}
```

---

## 6. Version Negotiation Between Nodes

### 6.1 Handshake Protocol

```rust
struct NodeHandshake {
    // Identity
    peer_id: PeerId,
    
    // Version info
    protocol_version: ProtocolVersion,
    client_name: String,            // "ecliptica-node"
    client_version: String,         // "v1.2.3"
    
    // Capabilities
    supported_features: FeatureFlags,
    supported_shards: Vec<u8>,
    
    // Network
    chain_id: u64,
    genesis_hash: [u8; 32],
    
    // Current state
    best_height: u64,
    best_hash: [u8; 32],
    
    // Signature
    timestamp: u64,
    signature: DilithiumSignature,
}

fn negotiate_connection(remote_handshake: NodeHandshake) -> Result<Connection> {
    let local = get_local_handshake();
    
    // 1. Verify same chain
    if local.chain_id != remote_handshake.chain_id {
        return Err(Error::ChainMismatch);
    }
    
    if local.genesis_hash != remote_handshake.genesis_hash {
        return Err(Error::GenesisMismatch);
    }
    
    // 2. Check version compatibility
    if !local.protocol_version.is_compatible_with(&remote_handshake.protocol_version) {
        return Err(Error::IncompatibleVersion {
            local: local.protocol_version,
            remote: remote_handshake.protocol_version,
        });
    }
    
    // 3. Negotiate features
    let shared_features = FeatureFlags {
        flags: local.supported_features.flags & remote_handshake.supported_features.flags,
    };
    
    // 4. Establish connection
    Ok(Connection {
        peer_id: remote_handshake.peer_id,
        protocol_version: remote_handshake.protocol_version.min(&local.protocol_version),
        features: shared_features,
        established_at: SystemTime::now(),
    })
}
```

### 6.2 Peer Discovery & Filtering

```rust
fn filter_compatible_peers(peers: Vec<PeerInfo>) -> Vec<PeerInfo> {
    let local_version = get_protocol_version();
    
    peers.into_iter()
        .filter(|peer| {
            // Only connect to compatible versions
            local_version.is_compatible_with(&peer.protocol_version)
        })
        .collect()
}

fn peer_compatibility_score(peer: &PeerInfo) -> f64 {
    let mut score = 0.0;
    
    let local_version = get_protocol_version();
    
    // Same major version: +50 points
    if peer.protocol_version.major == local_version.major {
        score += 50.0;
    }
    
    // Same minor version: +30 points
    if peer.protocol_version.minor == local_version.minor {
        score += 30.0;
    }
    
    // Same patch version: +20 points
    if peer.protocol_version.patch == local_version.patch {
        score += 20.0;
    }
    
    // Shared features
    let local_features = get_feature_flags();
    let shared = local_features.flags & peer.features.flags;
    let shared_count = shared.count_ones();
    score += shared_count as f64;
    
    score
}
```

### 6.3 Version Announcement Protocol

```rust
struct VersionAnnouncement {
    // New version available
    version: ProtocolVersion,
    release_notes_url: String,
    binary_url: String,
    
    // Urgency
    severity: UpdateSeverity,
    deadline: Option<SystemTime>,
    
    // Verification
    signature: DilithiumSignature,
    checksum: [u8; 32],
}

enum UpdateSeverity {
    Optional,       // Nice to have
    Recommended,    // Should update soon
    Required,       // Must update before deadline
    Emergency,      // Critical security fix
}

fn broadcast_version_announcement(announcement: VersionAnnouncement) {
    // Gossip to all peers
    for peer in get_connected_peers() {
        send_message(peer, Message::VersionAnnouncement(announcement.clone()));
    }
}

fn handle_version_announcement(announcement: VersionAnnouncement) {
    // Verify signature
    if !verify_announcement_signature(&announcement) {
        return;
    }
    
    match announcement.severity {
        UpdateSeverity::Emergency => {
            // Notify operator immediately
            alert!(Critical, "Emergency update required: {}", announcement.version);
            notify_operator_urgently();
        },
        
        UpdateSeverity::Required => {
            // Schedule update before deadline
            schedule_update(announcement.version, announcement.deadline.unwrap());
        },
        
        UpdateSeverity::Recommended => {
            // Log and notify
            log::info!("Update recommended: {}", announcement.version);
            notify_operator();
        },
        
        UpdateSeverity::Optional => {
            // Log only
            log::debug!("Optional update available: {}", announcement.version);
        },
    }
}
```

---

## 7. State Migration

### 7.1 Migration Types

```rust
enum MigrationType {
    NoMigration,        // No state changes needed
    AccountMigration,   // Modify account structure
    StorageMigration,   // Update contract storage layout
    IndexMigration,     // Rebuild indices
    FullMigration,      // Complete state transformation
}

struct StateMigration {
    from_version: ProtocolVersion,
    to_version: ProtocolVersion,
    migration_type: MigrationType,
    
    // Migration logic
    migrate_fn: fn(&State) -> Result<State>,
    
    // Validation
    validation_fn: fn(&State) -> Result<()>,
    
    // Estimated time
    estimated_duration: Duration,
}
```

### 7.2 Migration Execution

```rust
fn execute_state_migration(
    migration: StateMigration,
    state: &State,
) -> Result<State> {
    log::info!("Starting state migration: {} -> {}",
        migration.from_version,
        migration.to_version
    );
    
    // 1. Create snapshot before migration
    let snapshot = create_state_snapshot(state)?;
    
    // 2. Execute migration
    let start_time = Instant::now();
    let new_state = (migration.migrate_fn)(state).map_err(|e| {
        // Restore snapshot on failure
        restore_state_snapshot(&snapshot)?;
        e
    })?;
    
    let duration = start_time.elapsed();
    log::info!("Migration completed in {:?}", duration);
    
    // 3. Validate new state
    (migration.validation_fn)(&new_state)?;
    
    // 4. Verify state root
    let new_root = new_state.compute_state_root();
    log::info!("New state root: {}", hex::encode(new_root));
    
    Ok(new_state)
}
```

### 7.3 Example: Account Structure Migration

**Scenario: Adding a new field to accounts (v1.0 â†’ v1.1)**

```rust
// v1.0 account structure
struct AccountV1_0 {
    address: Address,
    balance: u64,
    nonce: u64,
    code_hash: Option<[u8; 32]>,
}

// v1.1 account structure (added staking field)
struct AccountV1_1 {
    address: Address,
    balance: u64,
    nonce: u64,
    code_hash: Option<[u8; 32]>,
    staking_info: Option<StakingInfo>,  // NEW
}

fn migrate_accounts_v1_0_to_v1_1(state: &State) -> Result<State> {
    let mut new_state = state.clone();
    
    for (address, account_v1_0) in state.accounts.iter() {
        let account_v1_1 = AccountV1_1 {
            address: account_v1_0.address,
            balance: account_v1_0.balance,
            nonce: account_v1_0.nonce,
            code_hash: account_v1_0.code_hash,
            staking_info: None,  // Initialize new field
        };
        
        new_state.accounts.insert(*address, account_v1_1);
    }
    
    Ok(new_state)
}
```

---

## 8. Backwards Compatibility Strategy

### 8.1 Compatibility Guarantees

**Transaction Format:**
- Old transactions remain valid indefinitely
- New optional fields added, never removed
- Transaction version field enables gradual migration

**State Format:**
- Old state can always be read by new nodes
- New state may include additional fields
- Migrations are one-way (forward only)

**RPC API:**
- Deprecated endpoints maintained for â‰¥2 major versions
- New endpoints added incrementally
- Clear deprecation warnings

### 8.2 Deprecation Policy

```rust
struct DeprecationNotice {
    item: String,               // "RPC method: eth_getBalance"
    version_deprecated: ProtocolVersion,
    version_removed: ProtocolVersion,
    replacement: Option<String>,
    migration_guide: String,
}

fn deprecate_feature(notice: DeprecationNotice) {
    log::warn!(
        "DEPRECATED: {} in version {}. Will be removed in {}. {}",
        notice.item,
        notice.version_deprecated,
        notice.version_removed,
        notice.migration_guide
    );
    
    // Log to deprecation registry
    DEPRECATION_REGISTRY.insert(notice.item.clone(), notice);
}

// Example
deprecate_feature(DeprecationNotice {
    item: "Transaction type 0x00".to_string(),
    version_deprecated: ProtocolVersion { major: 1, minor: 2, patch: 0 },
    version_removed: ProtocolVersion { major: 2, minor: 0, patch: 0 },
    replacement: Some("Transaction type 0x02".to_string()),
    migration_guide: "See https://docs.ecliptica.network/migration/tx-types".to_string(),
});
```

### 8.3 Multi-Version Testing

```rust
fn test_cross_version_compatibility() {
    let versions = vec![
        ProtocolVersion { major: 1, minor: 0, patch: 0 },
        ProtocolVersion { major: 1, minor: 1, patch: 0 },
        ProtocolVersion { major: 1, minor: 2, patch: 0 },
    ];
    
    for (i, v1) in versions.iter().enumerate() {
        for v2 in &versions[i+1..] {
            // Test that v2 can read v1 transactions
            test_tx_compatibility(v1, v2)?;
            
            // Test that v2 can sync from v1 nodes
            test_sync_compatibility(v1, v2)?;
            
            // Test that v1 and v2 can gossip
            test_gossip_compatibility(v1, v2)?;
        }
    }
}
```

---

## 9. Governance Integration

### 9.1 Governance Structure

```rust
struct GovernanceProposal {
    proposal_id: u64,
    proposal_type: ProposalType,
    
    // Voting
    voting_period: u64,             // Blocks
    quorum: f64,                    // Minimum participation
    threshold: f64,                 // Approval threshold
    
    // Execution
    executable: bool,               // Auto-execute on pass?
    execution_delay: u64,           // Blocks before execution
}

enum ProposalType {
    ProtocolUpgrade(UpgradeProposal),
    ParameterChange(ParameterChange),
    TreasurySpend(TreasuryProposal),
    EmergencyAction(EmergencyProposal),
}

struct ParameterChange {
    parameter: String,              // "block_gas_limit", "base_fee"
    current_value: Vec<u8>,
    proposed_value: Vec<u8>,
    rationale: String,
}
```

### 9.2 Quadratic Voting (Optional)

```rust
fn compute_voting_power(stake: u64) -> f64 {
    // Quadratic voting: power = sqrt(stake)
    // Reduces plutocracy, increases decentralization
    (stake as f64).sqrt()
}

fn cast_governance_vote(
    proposal_id: u64,
    choice: VoteChoice,
    stake: u64,
) -> Result<GovernanceVote> {
    let voting_power = compute_voting_power(stake);
    
    Ok(GovernanceVote {
        proposal_id,
        voter: get_caller_address(),
        vote: choice,
        voting_power,
        stake,
        timestamp: current_timestamp(),
    })
}
```

### 9.3 Multi-Chamber Voting (Advanced)

```rust
struct MultiChamberVote {
    // Chamber 1: Validators (by stake)
    validator_result: VoteResult,
    validator_weight: f64,          // e.g., 0.60
    
    // Chamber 2: Token holders (quadratic)
    token_holder_result: VoteResult,
    token_holder_weight: f64,       // e.g., 0.40
    
    // Combined result
    combined_approval: f64,
    passed: bool,
}

fn tally_multi_chamber_vote(proposal_id: u64) -> MultiChamberVote {
    let validator_result = tally_validator_votes(proposal_id);
    let token_holder_result = tally_token_holder_votes(proposal_id);
    
    let combined_approval = 
        (validator_result.yes_ratio * VALIDATOR_WEIGHT) +
        (token_holder_result.yes_ratio * TOKEN_HOLDER_WEIGHT);
    
    let passed = combined_approval >= COMBINED_THRESHOLD;
    
    MultiChamberVote {
        validator_result,
        validator_weight: VALIDATOR_WEIGHT,
        token_holder_result,
        token_holder_weight: TOKEN_HOLDER_WEIGHT,
        combined_approval,
        passed,
    }
}
```

---

## 10. Monitoring & Observability

### 10.1 Upgrade Metrics

```rust
struct UpgradeMetrics {
    // Version distribution
    node_versions: HashMap<ProtocolVersion, u32>,
    outdated_nodes: u32,
    
    // Upgrade progress
    upgrade_readiness: f64,         // % of validators upgraded
    estimated_activation: Option<SystemTime>,
    
    // Voting
    active_proposals: Vec<u64>,
    votes_cast: HashMap<u64, u64>,
    
    // Health
    consensus_healthy: bool,
    no_version_conflicts: bool,
}

fn collect_upgrade_metrics() -> UpgradeMetrics {
    let peers = get_all_peers();
    let mut version_dist = HashMap::new();
    
    for peer in peers {
        *version_dist.entry(peer.protocol_version).or_insert(0) += 1;
    }
    
    let total_nodes = peers.len() as u32;
    let current_version = get_protocol_version();
    let outdated = total_nodes - version_dist.get(&current_version).unwrap_or(&0);
    
    UpgradeMetrics {
        node_versions: version_dist,
        outdated_nodes: outdated,
        upgrade_readiness: calculate_readiness(),
        estimated_activation: estimate_activation_time(),
        active_proposals: get_active_proposals(),
        votes_cast: get_vote_counts(),
        consensus_healthy: check_consensus_health(),
        no_version_conflicts: check_no_conflicts(),
    }
}
```

### 10.2 Upgrade Dashboard

**Public Endpoint:** `https://upgrades.ecliptica.network`

```json
{
  "current_version": "1.1.0",
  "next_version": "1.2.0",
  "upgrade_status": "VOTING",
  "activation_height": 1234567,
  "blocks_remaining": 50000,
  "estimated_activation": "2025-06-15T00:00:00Z",
  
  "voting": {
    "proposal_id": 42,
    "yes_stake": "450000000",
    "no_stake": "50000000",
    "abstain_stake": "100000000",
    "participation": 0.60,
    "threshold_met": true
  },
  
  "readiness": {
    "validators_upgraded": 85,
    "validators_total": 100,
    "readiness_percent": 85.0,
    "ready": true
  },
  
  "version_distribution": {
    "1.0.0": 5,
    "1.1.0": 85,
    "1.2.0-rc": 10
  }
}
```

---

## 11. Testing & Validation

### 11.1 Upgrade Test Suite

```rust
#[cfg(test)]
mod upgrade_tests {
    #[test]
    fn test_version_compatibility() {
        let v1_0 = ProtocolVersion { major: 1, minor: 0, patch: 0 };
        let v1_1 = ProtocolVersion { major: 1, minor: 1, patch: 0 };
        let v2_0 = ProtocolVersion { major: 2, minor: 0, patch: 0 };
        
        assert!(v1_1.is_compatible_with(&v1_0));
        assert!(!v2_0.is_compatible_with(&v1_0));
    }
    
    #[test]
    fn test_state_migration() {
        let state_v1_0 = create_test_state_v1_0();
        let migration = get_migration_v1_0_to_v1_1();
        
        let state_v1_1 = execute_state_migration(migration, &state_v1_0).unwrap();
        
        // Verify all accounts migrated
        assert_eq!(state_v1_0.accounts.len(), state_v1_1.accounts.len());
        
        // Verify state root changed
        assert_ne!(state_v1_0.state_root(), state_v1_1.state_root());
    }
    
    #[test]
    fn test_transaction_backward_compat() {
        // Create v1.0 transaction
        let tx_v1_0 = create_test_transaction_v1_0();
        
        // Verify v1.1 node can process it
        let mut node_v1_1 = TestNode::new(ProtocolVersion { major: 1, minor: 1, patch: 0 });
        assert!(node_v1_1.validate_transaction(&tx_v1_0).is_ok());
    }
    
    #[test]
    fn test_emergency_patch_activation() {
        let patch = create_test_emergency_patch();
        
        // Should activate immediately without voting
        let activation_result = activate_emergency_patch(patch);
        assert!(activation_result.is_ok());
        
        // Verify version updated
        assert_eq!(get_protocol_version(), patch.patch_version);
    }
}
```

### 11.2 Testnet Deployment

```rust
fn deploy_upgrade_to_testnet(upgrade: UpgradeProposal) -> Result<()> {
    // 1. Deploy to separate testnet instance
    let testnet_instance = create_testnet_fork()?;
    
    // 2. Activate upgrade
    testnet_instance.activate_upgrade(upgrade.clone())?;
    
    // 3. Run for minimum 2 weeks
    testnet_instance.run_for_duration(Duration::from_secs(1_209_600))?;
    
    // 4. Collect metrics
    let metrics = testnet_instance.collect_metrics()?;
    
    // 5. Validate success criteria
    assert!(metrics.consensus_healthy);
    assert!(metrics.no_critical_errors);
    assert!(metrics.performance_acceptable);
    
    // 6. Generate report
    generate_testnet_report(upgrade, metrics)?;
    
    Ok(())
}
```

---

## 12. Documentation Requirements

### 12.1 Upgrade Documentation Checklist

**For Every Upgrade:**
- [ ] EIP-style specification document
- [ ] Migration guide (if state changes)
- [ ] Breaking changes list
- [ ] API deprecation notices
- [ ] Performance impact analysis
- [ ] Security audit reports
- [ ] Testnet deployment results
- [ ] Rollback procedures
- [ ] FAQ document

### 12.2 Communication Templates

**Validator Announcement:**

```markdown
# ðŸš€ Ecliptica Upgrade Announcement: v1.2.0

## Summary
Ecliptica will upgrade to v1.2.0 on **June 15, 2025 at block height 1,234,567**.

## What's New
- Recursive zk-STARK proof aggregation
- 30% reduction in proof size
- Improved cross-shard latency

## Action Required
- **Validators:** Upgrade node software by June 10, 2025
- **Users:** No action required (backward compatible)

## Upgrade Timeline
- May 15: Proposal submitted (EIP-42)
- May 22: Voting begins
- June 1: Voting ends
- June 15: Activation at block 1,234,567

## Resources
- Proposal: https://github.com/ecliptica/EIPs/blob/main/EIP-42.md
- Binary: https://github.com/ecliptica/releases/v1.2.0
- Migration guide: https://docs.ecliptica.network/upgrades/v1.2.0

## Support
- Discord: https://discord.gg/ecliptica
- Validator channel: #validator-support
```

---

## Appendix A: Upgrade History Template

```markdown
# Ecliptica Upgrade History

## v1.2.0 - "Quantum Leap" (June 15, 2025)
- **Type:** Soft Fork
- **Activation:** Block 1,234,567
- **Features:**
  - Recursive zk-STARK aggregation
  - Cross-shard optimization
- **Vote:** 92% Yes (85% participation)
- **Incidents:** None

## v1.1.0 - "Foundation" (March 1, 2025)
- **Type:** Soft Fork
- **Activation:** Block 500,000
- **Features:**
  - Signature aggregation
  - Gas optimizations
- **Vote:** 88% Yes (78% participation)
- **Incidents:** None

## v1.0.0 - "Genesis" (January 1, 2025)
- **Type:** Mainnet Launch
- **Genesis Block:** 0
- **Validators:** 100
- **Initial Supply:** 1,000,000,000 ECLIPT
```

---

**Document ID:** `ECLIPT-UPGRADE-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review