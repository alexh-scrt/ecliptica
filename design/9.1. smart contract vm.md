# üîê **Ecliptica Smart Contract VM & Privacy-Preserving Execution Specification**

### *Post-Quantum Confidential Computing on Blockchain*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-CONTRACT-001`  
**Depends On:** `ECLIPT-STATE-001`, `ECLIPT-TX-001`, `ECLIPT-MEV-001`

---

## 1. Executive Summary

Ecliptica's smart contract layer combines **Wasmtime** with a custom **privacy-preserving execution environment** to enable:

- **Confidential State**: All contract storage encrypted with ML-KEM
- **Post-Quantum Security**: ML-DSA signatures, ML-KEM encryption throughout
- **Deterministic Execution**: Strict configuration ensuring reproducibility
- **High Performance**: JIT compilation with gas metering
- **Privacy-Preserving Calls**: Encrypted inter-contract communication
- **Selective Disclosure**: Viewing keys for granular access control

**Performance Targets:**
- Contract execution: 10,000 TPS
- Gas cost overhead (privacy): +30-50% vs plaintext
- Contract deployment: <100ms
- Encrypted storage access: <1ms per key
- Cross-contract call: <5ms

---

## 2. Architecture Overview

### 2.1 System Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Ecliptica Smart Contract Architecture            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Contract SDK (Rust)                            ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Encrypted state macros                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Message passing interfaces                   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - PQ crypto primitives                         ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ cargo build --target wasm32        ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  WASM Bytecode (deterministic)                  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - No floats, no threads, no WASI               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Gas instrumentation                          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Memory sandboxing                            ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ deploy                               ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Contract Registry (on-chain)                   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Code hash ‚Üí WASM bytecode                    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Contract address ‚Üí Code hash                 ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Access control policies                      ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ instantiate                          ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Wasmtime Runtime (configured)                  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Deterministic config                         ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Fuel metering                                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Memory limits                                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - No syscalls                                  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ execute                              ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Host Environment (Ecliptica VM)                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - storage_read/write (encrypted)               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - crypto_encrypt/decrypt (ML-KEM)              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - crypto_sign/verify (ML-DSA)                  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - call_contract (encrypted)                    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - emit_event (encrypted)                       ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ persist                              ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Encrypted Contract State                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - KV store (all values encrypted)              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - State commitments (Merkle tree)              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Access logs (encrypted)                      ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Contract Lifecycle

```
1. DEVELOPMENT
   Developer writes contract in Rust
   ‚Üì
2. COMPILATION
   cargo build --target wasm32-unknown-unknown
   ‚Üì
3. OPTIMIZATION
   wasm-opt (deterministic optimizations only)
   ‚Üì
4. DEPLOYMENT
   Submit WASM bytecode + initial state
   Pay deployment fee
   ‚Üì
5. INSTANTIATION
   Contract address assigned
   Code stored on-chain
   Initial state encrypted and stored
   ‚Üì
6. EXECUTION
   Users call contract methods
   State updates encrypted
   Events emitted (encrypted)
   ‚Üì
7. UPGRADE (optional)
   Deploy new code
   Migrate state (if needed)
   Old code remains accessible
```

---

## 3. Wasmtime Configuration

### 3.1 Engine Configuration

```rust
use wasmtime::*;

pub struct EclipticaEngine {
    engine: Engine,
    module_cache: ModuleCache,
}

impl EclipticaEngine {
    pub fn new() -> Result<Self> {
        let mut config = Config::new();
        
        // === DETERMINISM REQUIREMENTS ===
        
        // Disable non-deterministic features
        config.wasm_simd(false);              // SIMD non-deterministic on some CPUs
        config.wasm_threads(false);           // Threads = non-determinism
        config.wasm_multi_memory(false);      // Not needed
        config.wasm_memory64(false);          // Not needed
        
        // Enable safe deterministic features
        config.wasm_bulk_memory(true);        // Deterministic bulk ops
        config.wasm_multi_value(true);        // Multiple return values
        config.wasm_reference_types(false);   // Complex, not needed
        
        // === COMPILATION STRATEGY ===
        
        // Use Cranelift AOT (deterministic)
        config.strategy(Strategy::Cranelift)?;
        config.cranelift_opt_level(OptLevel::Speed)?;
        
        // Deterministic float handling (if ever enabled)
        config.cranelift_nan_canonicalization(true);
        
        // === RESOURCE LIMITS ===
        
        config.max_wasm_stack(1024 * 1024)?;  // 1 MB stack max
        
        // Pooling allocator (pre-allocate resources)
        config.allocation_strategy(InstanceAllocationStrategy::Pooling {
            strategy: PoolingAllocationStrategy {
                instance_limits: InstanceLimits {
                    count: 1000,              // Max 1000 concurrent instances
                    memory_pages: 2048,       // 128 MB max memory per instance
                    table_elements: 10_000,   // Max table size
                },
                pooling_allocation_config: PoolingAllocationConfig {
                    max_core_instance_size: 1024 * 1024,  // 1 MB
                    max_memories_per_module: 1,
                    max_tables_per_module: 1,
                    total_memories: 1000,
                    total_tables: 1000,
                    total_stacks: 1000,
                    max_memory_size: 128 * 1024 * 1024,   // 128 MB
                },
            },
        });
        
        // === GAS METERING ===
        
        config.consume_fuel(true)?;           // Enable fuel consumption
        config.epoch_interruption(true);      // Enable epoch-based timeout
        
        // === SECURITY ===
        
        // No WASI (no syscalls)
        // No dynamic linking
        // No file system access
        
        let engine = Engine::new(&config)?;
        
        Ok(Self {
            engine,
            module_cache: ModuleCache::new(),
        })
    }
}

// Module cache (avoid recompilation)
struct ModuleCache {
    cache: lru::LruCache<[u8; 32], Module>,
}

impl ModuleCache {
    fn new() -> Self {
        Self {
            cache: lru::LruCache::new(std::num::NonZeroUsize::new(100).unwrap()),
        }
    }
    
    fn get_or_compile(&mut self, code_hash: [u8; 32], wasm: &[u8], engine: &Engine) -> Result<Module> {
        if let Some(module) = self.cache.get(&code_hash) {
            return Ok(module.clone());
        }
        
        // Compile and cache
        let module = Module::new(engine, wasm)?;
        self.cache.put(code_hash, module.clone());
        
        Ok(module)
    }
}
```

### 3.2 Instance Configuration

```rust
pub struct ContractInstance {
    instance: Instance,
    store: Store<ContractState>,
    memory: Memory,
}

pub struct ContractState {
    // Contract metadata
    contract_address: Address,
    code_hash: [u8; 32],
    
    // Execution context
    caller: Address,
    block_height: u64,
    block_timestamp: u64,
    
    // Gas metering
    gas_limit: u64,
    gas_used: u64,
    
    // Storage interface
    storage: Arc<RwLock<EncryptedStorage>>,
    
    // Crypto interface
    crypto: Arc<CryptoProvider>,
    
    // Call stack (prevent reentrancy)
    call_depth: u32,
    max_call_depth: u32,
}

impl ContractInstance {
    pub fn instantiate(
        engine: &Engine,
        module: &Module,
        contract_address: Address,
        caller: Address,
        gas_limit: u64,
    ) -> Result<Self> {
        let state = ContractState {
            contract_address,
            code_hash: compute_code_hash(module),
            caller,
            block_height: get_current_height(),
            block_timestamp: get_current_timestamp(),
            gas_limit,
            gas_used: 0,
            storage: Arc::new(RwLock::new(EncryptedStorage::new(contract_address))),
            crypto: Arc::new(CryptoProvider::new()),
            call_depth: 0,
            max_call_depth: 10,
        };
        
        let mut store = Store::new(engine, state);
        
        // Set gas limit
        store.set_fuel(gas_limit)?;
        
        // Set epoch deadline (timeout protection)
        store.set_epoch_deadline(1);
        
        // Create linker with host functions
        let mut linker = Linker::new(engine);
        register_host_functions(&mut linker)?;
        
        // Instantiate
        let instance = linker.instantiate(&mut store, module)?;
        
        // Get memory export
        let memory = instance.get_memory(&mut store, "memory")
            .ok_or(Error::NoMemoryExport)?;
        
        Ok(Self {
            instance,
            store,
            memory,
        })
    }
}
```

---

## 4. Host Functions (VM ‚Üî Blockchain Interface)

### 4.1 Storage Operations

```rust
fn register_host_functions(linker: &mut Linker<ContractState>) -> Result<()> {
    // === STORAGE ===
    
    // Read encrypted value from storage
    linker.func_wrap(
        "env",
        "storage_read",
        |mut caller: Caller<'_, ContractState>, key_ptr: i32, key_len: i32| -> i32 {
            let state = caller.data();
            
            // Charge gas
            charge_gas(&mut caller, GAS_STORAGE_READ)?;
            
            // Read key from WASM memory
            let memory = get_memory(&mut caller)?;
            let key = read_bytes(&memory, &caller, key_ptr, key_len)?;
            
            // Read from encrypted storage
            let storage = state.storage.read().unwrap();
            let value = storage.read(&key, &state.contract_address)?;
            
            // Write value to WASM memory (return pointer)
            let value_ptr = allocate_in_wasm(&mut caller, value.len())?;
            write_bytes(&memory, &mut caller, value_ptr, &value)?;
            
            Ok(value_ptr)
        },
    )?;
    
    // Write encrypted value to storage
    linker.func_wrap(
        "env",
        "storage_write",
        |mut caller: Caller<'_, ContractState>, 
         key_ptr: i32, key_len: i32,
         value_ptr: i32, value_len: i32| -> Result<()> {
            let state = caller.data();
            
            // Charge gas (more expensive)
            charge_gas(&mut caller, GAS_STORAGE_WRITE)?;
            
            // Read key and value from WASM memory
            let memory = get_memory(&mut caller)?;
            let key = read_bytes(&memory, &caller, key_ptr, key_len)?;
            let value = read_bytes(&memory, &caller, value_ptr, value_len)?;
            
            // Write to encrypted storage
            let mut storage = state.storage.write().unwrap();
            storage.write(&key, &value, &state.contract_address)?;
            
            Ok(())
        },
    )?;
    
    // Remove value from storage
    linker.func_wrap(
        "env",
        "storage_remove",
        |mut caller: Caller<'_, ContractState>, key_ptr: i32, key_len: i32| -> Result<()> {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_STORAGE_WRITE)?;
            
            let memory = get_memory(&mut caller)?;
            let key = read_bytes(&memory, &caller, key_ptr, key_len)?;
            
            let mut storage = state.storage.write().unwrap();
            storage.remove(&key, &state.contract_address)?;
            
            Ok(())
        },
    )?;
    
    // === CRYPTOGRAPHY ===
    
    // ML-KEM encryption
    linker.func_wrap(
        "env",
        "crypto_encrypt",
        |mut caller: Caller<'_, ContractState>,
         pubkey_ptr: i32, pubkey_len: i32,
         plaintext_ptr: i32, plaintext_len: i32| -> i32 {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_MLKEM_ENCRYPT)?;
            
            let memory = get_memory(&mut caller)?;
            let pubkey = read_bytes(&memory, &caller, pubkey_ptr, pubkey_len)?;
            let plaintext = read_bytes(&memory, &caller, plaintext_ptr, plaintext_len)?;
            
            // Encrypt with ML-KEM-512
            let ciphertext = state.crypto.mlkem_encrypt(&pubkey, &plaintext)?;
            
            // Return ciphertext
            let ct_ptr = allocate_in_wasm(&mut caller, ciphertext.len())?;
            write_bytes(&memory, &mut caller, ct_ptr, &ciphertext)?;
            
            Ok(ct_ptr)
        },
    )?;
    
    // ML-KEM decryption (requires viewing key)
    linker.func_wrap(
        "env",
        "crypto_decrypt",
        |mut caller: Caller<'_, ContractState>,
         seckey_ptr: i32, seckey_len: i32,
         ciphertext_ptr: i32, ciphertext_len: i32| -> i32 {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_MLKEM_DECRYPT)?;
            
            let memory = get_memory(&mut caller)?;
            let seckey = read_bytes(&memory, &caller, seckey_ptr, seckey_len)?;
            let ciphertext = read_bytes(&memory, &caller, ciphertext_ptr, ciphertext_len)?;
            
            // Decrypt with ML-KEM-512
            let plaintext = state.crypto.mlkem_decrypt(&seckey, &ciphertext)?;
            
            let pt_ptr = allocate_in_wasm(&mut caller, plaintext.len())?;
            write_bytes(&memory, &mut caller, pt_ptr, &plaintext)?;
            
            Ok(pt_ptr)
        },
    )?;
    
    // ML-DSA signing
    linker.func_wrap(
        "env",
        "crypto_sign",
        |mut caller: Caller<'_, ContractState>,
         seckey_ptr: i32, seckey_len: i32,
         message_ptr: i32, message_len: i32| -> i32 {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_MLDSA_SIGN)?;
            
            let memory = get_memory(&mut caller)?;
            let seckey = read_bytes(&memory, &caller, seckey_ptr, seckey_len)?;
            let message = read_bytes(&memory, &caller, message_ptr, message_len)?;
            
            // Sign with ML-DSA (Dilithium-3)
            let signature = state.crypto.mldsa_sign(&seckey, &message)?;
            
            let sig_ptr = allocate_in_wasm(&mut caller, signature.len())?;
            write_bytes(&memory, &mut caller, sig_ptr, &signature)?;
            
            Ok(sig_ptr)
        },
    )?;
    
    // ML-DSA verification
    linker.func_wrap(
        "env",
        "crypto_verify",
        |mut caller: Caller<'_, ContractState>,
         pubkey_ptr: i32, pubkey_len: i32,
         message_ptr: i32, message_len: i32,
         signature_ptr: i32, signature_len: i32| -> i32 {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_MLDSA_VERIFY)?;
            
            let memory = get_memory(&mut caller)?;
            let pubkey = read_bytes(&memory, &caller, pubkey_ptr, pubkey_len)?;
            let message = read_bytes(&memory, &caller, message_ptr, message_len)?;
            let signature = read_bytes(&memory, &caller, signature_ptr, signature_len)?;
            
            // Verify with ML-DSA
            let valid = state.crypto.mldsa_verify(&pubkey, &message, &signature)?;
            
            Ok(if valid { 1 } else { 0 })
        },
    )?;
    
    // === BLOCKCHAIN CONTEXT ===
    
    linker.func_wrap(
        "env",
        "get_caller",
        |mut caller: Caller<'_, ContractState>| -> i32 {
            let state = caller.data();
            let memory = get_memory(&mut caller)?;
            
            let caller_ptr = allocate_in_wasm(&mut caller, 20)?;
            write_bytes(&memory, &mut caller, caller_ptr, &state.caller)?;
            
            Ok(caller_ptr)
        },
    )?;
    
    linker.func_wrap(
        "env",
        "get_block_height",
        |caller: Caller<'_, ContractState>| -> i64 {
            Ok(caller.data().block_height as i64)
        },
    )?;
    
    linker.func_wrap(
        "env",
        "get_block_timestamp",
        |caller: Caller<'_, ContractState>| -> i64 {
            Ok(caller.data().block_timestamp as i64)
        },
    )?;
    
    // === INTER-CONTRACT CALLS ===
    
    linker.func_wrap(
        "env",
        "call_contract",
        |mut caller: Caller<'_, ContractState>,
         contract_addr_ptr: i32,
         method_ptr: i32, method_len: i32,
         args_ptr: i32, args_len: i32,
         gas_limit: i64| -> i32 {
            let state = caller.data_mut();
            
            // Check call depth
            if state.call_depth >= state.max_call_depth {
                return Err(Error::CallDepthExceeded);
            }
            
            charge_gas(&mut caller, GAS_CALL_CONTRACT_BASE)?;
            
            let memory = get_memory(&mut caller)?;
            let contract_addr = read_bytes(&memory, &caller, contract_addr_ptr, 20)?;
            let method = read_bytes(&memory, &caller, method_ptr, method_len)?;
            let args = read_bytes(&memory, &caller, args_ptr, args_len)?;
            
            // Increment call depth
            state.call_depth += 1;
            
            // Execute sub-call
            let result = execute_contract_call(
                &contract_addr.try_into().unwrap(),
                &method,
                &args,
                gas_limit as u64,
            )?;
            
            // Decrement call depth
            state.call_depth -= 1;
            
            // Return result
            let result_ptr = allocate_in_wasm(&mut caller, result.len())?;
            write_bytes(&memory, &mut caller, result_ptr, &result)?;
            
            Ok(result_ptr)
        },
    )?;
    
    // === EVENTS ===
    
    linker.func_wrap(
        "env",
        "emit_event",
        |mut caller: Caller<'_, ContractState>,
         topic_ptr: i32, topic_len: i32,
         data_ptr: i32, data_len: i32| -> Result<()> {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_EMIT_EVENT)?;
            
            let memory = get_memory(&mut caller)?;
            let topic = read_bytes(&memory, &caller, topic_ptr, topic_len)?;
            let data = read_bytes(&memory, &caller, data_ptr, data_len)?;
            
            // Emit encrypted event
            emit_contract_event(
                &state.contract_address,
                &topic,
                &data,
            )?;
            
            Ok(())
        },
    )?;
    
    Ok(())
}
```

### 4.2 Gas Costs

```rust
// Gas costs for host functions
const GAS_STORAGE_READ: u64 = 5_000;
const GAS_STORAGE_WRITE: u64 = 20_000;
const GAS_MLKEM_ENCRYPT: u64 = 10_000;
const GAS_MLKEM_DECRYPT: u64 = 10_000;
const GAS_MLDSA_SIGN: u64 = 15_000;
const GAS_MLDSA_VERIFY: u64 = 8_000;
const GAS_CALL_CONTRACT_BASE: u64 = 50_000;
const GAS_EMIT_EVENT: u64 = 1_000;

// WASM instruction gas costs (via instrumentation)
const GAS_PER_INSTRUCTION: u64 = 1;
const GAS_PER_MEMORY_GROW: u64 = 1_000;  // Per page (64 KB)

fn charge_gas(caller: &mut Caller<'_, ContractState>, amount: u64) -> Result<()> {
    let state = caller.data_mut();
    
    state.gas_used += amount;
    
    if state.gas_used > state.gas_limit {
        return Err(Error::OutOfGas);
    }
    
    // Also consume fuel in Wasmtime
    caller.consume_fuel(amount)?;
    
    Ok(())
}
```

---

## 5. Encrypted Storage Layer

### 5.1 Storage Architecture

```rust
pub struct EncryptedStorage {
    contract_address: Address,
    
    // In-memory cache (plaintext)
    cache: HashMap<Vec<u8>, Vec<u8>>,
    
    // Persistent backend (encrypted)
    backend: Arc<dyn StorageBackend>,
    
    // Encryption key (derived from contract address)
    storage_key: [u8; 32],
}

impl EncryptedStorage {
    pub fn new(contract_address: Address) -> Self {
        // Derive storage encryption key from contract address
        let storage_key = derive_storage_key(&contract_address);
        
        Self {
            contract_address,
            cache: HashMap::new(),
            backend: Arc::new(RocksDBBackend::new()),
            storage_key,
        }
    }
    
    pub fn read(&self, key: &[u8], contract_addr: &Address) -> Result<Vec<u8>> {
        // Check cache first
        if let Some(value) = self.cache.get(key) {
            return Ok(value.clone());
        }
        
        // Read from encrypted backend
        let storage_key_hash = compute_storage_key_hash(contract_addr, key);
        let encrypted_value = self.backend.get(&storage_key_hash)?
            .ok_or(Error::KeyNotFound)?;
        
        // Decrypt value
        let plaintext = aes_gcm_decrypt(&encrypted_value, &self.storage_key)?;
        
        Ok(plaintext)
    }
    
    pub fn write(&mut self, key: &[u8], value: &[u8], contract_addr: &Address) -> Result<()> {
        // Update cache
        self.cache.insert(key.to_vec(), value.to_vec());
        
        // Encrypt value
        let encrypted_value = aes_gcm_encrypt(value, &self.storage_key)?;
        
        // Write to backend
        let storage_key_hash = compute_storage_key_hash(contract_addr, key);
        self.backend.set(&storage_key_hash, &encrypted_value)?;
        
        Ok(())
    }
    
    pub fn remove(&mut self, key: &[u8], contract_addr: &Address) -> Result<()> {
        // Remove from cache
        self.cache.remove(key);
        
        // Remove from backend
        let storage_key_hash = compute_storage_key_hash(contract_addr, key);
        self.backend.delete(&storage_key_hash)?;
        
        Ok(())
    }
    
    pub fn commit(&mut self) -> Result<()> {
        // Flush cache to backend
        self.backend.commit()?;
        Ok(())
    }
}

fn derive_storage_key(contract_address: &Address) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_STORAGE_KEY_v1");
    hasher.update(contract_address);
    
    let mut key = [0u8; 32];
    hasher.finalize_xof_into(&mut key);
    key
}

fn compute_storage_key_hash(contract_addr: &Address, key: &[u8]) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(contract_addr);
    hasher.update(key);
    
    let mut hash = [0u8; 32];
    hasher.finalize_xof_into(&mut hash);
    hash
}
```

### 5.2 Viewing Keys for Storage

```rust
pub struct StorageViewingKey {
    contract_address: Address,
    viewing_key: [u8; 32],              // Derived from user secret
    permissions: ViewingPermissions,
}

#[derive(Clone)]
pub struct ViewingPermissions {
    can_read_all: bool,
    specific_keys: HashSet<Vec<u8>>,    // Specific keys allowed
}

impl StorageViewingKey {
    pub fn derive(
        user_secret: &[u8; 32],
        contract_address: &Address,
    ) -> Self {
        let viewing_key = derive_contract_viewing_key(user_secret, contract_address);
        
        Self {
            contract_address: *contract_address,
            viewing_key,
            permissions: ViewingPermissions {
                can_read_all: true,
                specific_keys: HashSet::new(),
            },
        }
    }
    
    pub fn read_with_viewing_key(
        &self,
        storage: &EncryptedStorage,
        key: &[u8],
    ) -> Result<Vec<u8>> {
        // Check permissions
        if !self.permissions.can_read_all && !self.permissions.specific_keys.contains(key) {
            return Err(Error::PermissionDenied);
        }
        
        // Read encrypted value
        let storage_key_hash = compute_storage_key_hash(&self.contract_address, key);
        let encrypted_value = storage.backend.get(&storage_key_hash)?
            .ok_or(Error::KeyNotFound)?;
        
        // Decrypt with viewing key
        let plaintext = aes_gcm_decrypt(&encrypted_value, &self.viewing_key)?;
        
        Ok(plaintext)
    }
}

fn derive_contract_viewing_key(user_secret: &[u8; 32], contract_addr: &Address) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_VIEWING_KEY_v1");
    hasher.update(user_secret);
    hasher.update(contract_addr);
    
    let mut key = [0u8; 32];
    hasher.finalize_xof_into(&mut key);
    key
}
```

---

## 6. Contract SDK (Rust Developer API)

### 6.1 Contract Macro

```rust
// ecliptica_contract_sdk/src/lib.rs

use proc_macro::TokenStream;

/// Main contract macro
/// 
/// Example:
/// ```
/// #[contract]
/// pub struct Counter {
///     count: u64,
/// }
/// 
/// #[contract_impl]
/// impl Counter {
///     pub fn new() -> Self {
///         Self { count: 0 }
///     }
///     
///     pub fn increment(&mut self) {
///         self.count += 1;
///     }
///     
///     pub fn get_count(&self) -> u64 {
///         self.count
///     }
/// }
/// ```
#[proc_macro_attribute]
pub fn contract(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // Generate boilerplate:
    // - Serialization/deserialization
    // - Storage encoding
    // - Entry points
    
    let input = parse_macro_input!(item as ItemStruct);
    
    quote! {
        #[derive(serde::Serialize, serde::Deserialize)]
        #input
        
        // Auto-generate storage methods
        impl #input {
            pub fn load() -> Self {
                let state_bytes = ecliptica_sdk::storage::read(b"STATE");
                serde_json::from_slice(&state_bytes).unwrap_or_default()
            }
            
            pub fn save(&self) {
                let state_bytes = serde_json::to_vec(self).unwrap();
                ecliptica_sdk::storage::write(b"STATE", &state_bytes);
            }
        }
    }.into()
}

#[proc_macro_attribute]
pub fn contract_impl(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // Generate entry points for each public method
    
    let input = parse_macro_input!(item as ItemImpl);
    
    // For each public method, generate an export
    quote! {
        #input
        
        // Auto-generate WASM exports
        #[no_mangle]
        pub extern "C" fn call(method_ptr: i32, method_len: i32, args_ptr: i32, args_len: i32) -> i32 {
            // Dispatch to appropriate method
            // ...
        }
    }.into()
}
```

### 6.2 SDK Core Functions

```rust
// ecliptica_contract_sdk/src/storage.rs

pub mod storage {
    extern "C" {
        fn storage_read(key_ptr: *const u8, key_len: usize) -> i32;
        fn storage_write(key_ptr: *const u8, key_len: usize, value_ptr: *const u8, value_len: usize);
        fn storage_remove(key_ptr: *const u8, key_len: usize);
    }
    
    pub fn read(key: &[u8]) -> Vec<u8> {
        unsafe {
            let result_ptr = storage_read(key.as_ptr(), key.len());
            // Read result from returned pointer
            read_bytes_from_host(result_ptr)
        }
    }
    
    pub fn write(key: &[u8], value: &[u8]) {
        unsafe {
            storage_write(key.as_ptr(), key.len(), value.as_ptr(), value.len());
        }
    }
    
    pub fn remove(key: &[u8]) {
        unsafe {
            storage_remove(key.as_ptr(), key.len());
        }
    }
}

// ecliptica_contract_sdk/src/crypto.rs

pub mod crypto {
    extern "C" {
        fn crypto_encrypt(pubkey_ptr: *const u8, pubkey_len: usize, 
                         plaintext_ptr: *const u8, plaintext_len: usize) -> i32;
        fn crypto_decrypt(seckey_ptr: *const u8, seckey_len: usize,
                         ciphertext_ptr: *const u8, ciphertext_len: usize) -> i32;
        fn crypto_sign(seckey_ptr: *const u8, seckey_len: usize,
                      message_ptr: *const u8, message_len: usize) -> i32;
        fn crypto_verify(pubkey_ptr: *const u8, pubkey_len: usize,
                        message_ptr: *const u8, message_len: usize,
                        signature_ptr: *const u8, signature_len: usize) -> i32;
    }
    
    pub fn encrypt(pubkey: &[u8], plaintext: &[u8]) -> Vec<u8> {
        unsafe {
            let result_ptr = crypto_encrypt(
                pubkey.as_ptr(), pubkey.len(),
                plaintext.as_ptr(), plaintext.len(),
            );
            read_bytes_from_host(result_ptr)
        }
    }
    
    pub fn decrypt(seckey: &[u8], ciphertext: &[u8]) -> Vec<u8> {
        unsafe {
            let result_ptr = crypto_decrypt(
                seckey.as_ptr(), seckey.len(),
                ciphertext.as_ptr(), ciphertext.len(),
            );
            read_bytes_from_host(result_ptr)
        }
    }
    
    pub fn sign(seckey: &[u8], message: &[u8]) -> Vec<u8> {
        unsafe {
            let result_ptr = crypto_sign(
                seckey.as_ptr(), seckey.len(),
                message.as_ptr(), message.len(),
            );
            read_bytes_from_host(result_ptr)
        }
    }
    
    pub fn verify(pubkey: &[u8], message: &[u8], signature: &[u8]) -> bool {
        unsafe {
            let result = crypto_verify(
                pubkey.as_ptr(), pubkey.len(),
                message.as_ptr(), message.len(),
                signature.as_ptr(), signature.len(),
            );
            result == 1
        }
    }
}

// ecliptica_contract_sdk/src/context.rs

pub mod context {
    extern "C" {
        fn get_caller() -> i32;
        fn get_block_height() -> i64;
        fn get_block_timestamp() -> i64;
    }
    
    pub fn caller() -> [u8; 20] {
        unsafe {
            let ptr = get_caller();
            read_address_from_host(ptr)
        }
    }
    
    pub fn block_height() -> u64 {
        unsafe { get_block_height() as u64 }
    }
    
    pub fn block_timestamp() -> u64 {
        unsafe { get_block_timestamp() as u64 }
    }
}

// ecliptica_contract_sdk/src/contract.rs

pub mod contract {
    extern "C" {
        fn call_contract(
            contract_addr_ptr: *const u8,
            method_ptr: *const u8, method_len: usize,
            args_ptr: *const u8, args_len: usize,
            gas_limit: i64,
        ) -> i32;
        fn emit_event(topic_ptr: *const u8, topic_len: usize,
                     data_ptr: *const u8, data_len: usize);
    }
    
    pub fn call(
        contract_addr: &[u8; 20],
        method: &str,
        args: &[u8],
        gas_limit: u64,
    ) -> Vec<u8> {
        unsafe {
            let result_ptr = call_contract(
                contract_addr.as_ptr(),
                method.as_ptr(), method.len(),
                args.as_ptr(), args.len(),
                gas_limit as i64,
            );
            read_bytes_from_host(result_ptr)
        }
    }
    
    pub fn emit_event(topic: &str, data: &[u8]) {
        unsafe {
            emit_event(
                topic.as_ptr(), topic.len(),
                data.as_ptr(), data.len(),
            );
        }
    }
}
```

### 6.3 Example Contract

```rust
use ecliptica_contract_sdk::*;

#[contract]
pub struct PrivateToken {
    // Total supply (public)
    total_supply: u64,
    
    // Balances (encrypted per user)
    // Key: user_address, Value: encrypted_balance
    balances: HashMap<Address, EncryptedBalance>,
}

#[derive(Serialize, Deserialize)]
struct EncryptedBalance {
    ciphertext: Vec<u8>,                // ML-KEM encrypted
    commitment: [u8; 32],               // Pedersen commitment
}

#[contract_impl]
impl PrivateToken {
    pub fn new(total_supply: u64, creator: Address, creator_pubkey: &[u8]) -> Self {
        let mut contract = Self {
            total_supply,
            balances: HashMap::new(),
        };
        
        // Mint entire supply to creator (encrypted)
        let balance_bytes = total_supply.to_le_bytes();
        let encrypted_balance = crypto::encrypt(creator_pubkey, &balance_bytes);
        
        contract.balances.insert(creator, EncryptedBalance {
            ciphertext: encrypted_balance,
            commitment: compute_pedersen_commitment(total_supply),
        });
        
        contract
    }
    
    pub fn transfer(
        &mut self,
        to: Address,
        to_pubkey: &[u8],
        amount_proof: TransferProof,
    ) -> Result<()> {
        let from = context::caller();
        
        // Verify zero-knowledge proof of sufficient balance
        if !self.verify_transfer_proof(&from, &to, &amount_proof) {
            return Err(Error::InvalidProof);
        }
        
        // Update balances (encrypted)
        self.balances.insert(from, amount_proof.new_sender_balance);
        self.balances.insert(to, amount_proof.new_receiver_balance);
        
        // Emit encrypted event
        contract::emit_event("transfer", &serialize(&amount_proof));
        
        Ok(())
    }
    
    pub fn get_balance(&self, user: Address, viewing_key: &[u8]) -> Result<u64> {
        let encrypted_balance = self.balances.get(&user)
            .ok_or(Error::UserNotFound)?;
        
        // Decrypt with viewing key
        let balance_bytes = crypto::decrypt(viewing_key, &encrypted_balance.ciphertext)?;
        
        let balance = u64::from_le_bytes(balance_bytes.try_into().unwrap());
        
        Ok(balance)
    }
    
    fn verify_transfer_proof(&self, from: &Address, to: &Address, proof: &TransferProof) -> bool {
        // Verify zk-STARK proof that:
        // 1. Sender has sufficient balance
        // 2. New balances are correct
        // 3. Total supply unchanged
        
        verify_stark_proof(&proof.stark_proof, &proof.public_inputs)
    }
}

#[derive(Serialize, Deserialize)]
struct TransferProof {
    // New encrypted balances
    new_sender_balance: EncryptedBalance,
    new_receiver_balance: EncryptedBalance,
    
    // zk-STARK proof of valid transfer
    stark_proof: Vec<u8>,
    public_inputs: Vec<u8>,
}

fn compute_pedersen_commitment(value: u64) -> [u8; 32] {
    // Pedersen commitment: C = value * G + r * H
    // (Simplified - use actual lattice-based commitment)
    shake256(&value.to_le_bytes())
}
```

---

## 7. Contract Deployment

### 7.1 Deployment Transaction

```rust
struct ContractDeployTransaction {
    // WASM bytecode
    code: Vec<u8>,
    
    // Initial state (encrypted)
    initial_state: Vec<u8>,
    
    // Constructor arguments
    constructor_args: Vec<u8>,
    
    // Gas limit
    gas_limit: u64,
    
    // Deployer
    deployer: Address,
    signature: DilithiumSignature,
}

fn deploy_contract(tx: ContractDeployTransaction) -> Result<Address> {
    // 1. Validate WASM bytecode
    validate_wasm_module(&tx.code)?;
    
    // 2. Compute code hash
    let code_hash = shake256(&tx.code);
    
    // 3. Assign contract address (deterministic)
    let contract_address = compute_contract_address(&tx.deployer, tx.nonce, &code_hash);
    
    // 4. Store code on-chain
    store_contract_code(&code_hash, &tx.code)?;
    
    // 5. Register contract
    register_contract(&contract_address, &code_hash)?;
    
    // 6. Execute constructor
    let instance = instantiate_contract(&contract_address, &tx.deployer, tx.gas_limit)?;
    instance.call_constructor(&tx.constructor_args)?;
    
    // 7. Commit initial state
    instance.storage.commit()?;
    
    Ok(contract_address)
}

fn compute_contract_address(deployer: &Address, nonce: u64, code_hash: &[u8; 32]) -> Address {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_ADDRESS_v1");
    hasher.update(deployer);
    hasher.update(&nonce.to_le_bytes());
    hasher.update(code_hash);
    
    let mut addr = [0u8; 20];
    hasher.finalize_xof_into(&mut addr);
    addr
}
```

### 7.2 WASM Validation

```rust
fn validate_wasm_module(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Validator, WasmFeatures};
    
    // Configure allowed features
    let features = WasmFeatures {
        mutable_global: true,
        saturating_float_to_int: false,  // No floats
        sign_extension: true,
        simd: false,                      // No SIMD
        threads: false,                   // No threads
        tail_call: false,
        bulk_memory: true,
        multi_value: true,
        reference_types: false,
        ..WasmFeatures::default()
    };
    
    // Validate
    let mut validator = Validator::new_with_features(features);
    validator.validate_all(wasm)?;
    
    // Additional checks
    check_no_floats(wasm)?;
    check_no_start_function(wasm)?;
    check_memory_limits(wasm)?;
    check_no_imports_except_env(wasm)?;
    
    Ok(())
}

fn check_no_floats(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Parser, Payload};
    
    for payload in Parser::new(0).parse_all(wasm) {
        match payload? {
            Payload::CodeSectionEntry(body) => {
                for op in body.get_operators_reader()? {
                    let op = op?;
                    if is_float_instruction(&op) {
                        return Err(Error::FloatsNotAllowed);
                    }
                }
            },
            _ => {},
        }
    }
    
    Ok(())
}
```

---

## 8. Gas Metering

### 8.1 WASM Instrumentation

```rust
use wasm_instrument::gas_metering;

fn instrument_wasm_for_gas(wasm: &[u8]) -> Result<Vec<u8>> {
    let rules = Rules::default();
    
    let instrumented = gas_metering::inject(
        wasm,
        &rules,
        "env",          // Module name
        "charge_gas",   // Function name
    )?;
    
    Ok(instrumented)
}

struct Rules;

impl gas_metering::Rules for Rules {
    fn instruction_cost(&self, instruction: &wasm_instrument::parity_wasm::elements::Instruction) -> Option<u32> {
        use wasm_instrument::parity_wasm::elements::Instruction::*;
        
        Some(match instruction {
            // Memory operations
            I32Load(_, _) | I64Load(_, _) => 3,
            I32Store(_, _) | I64Store(_, _) => 3,
            MemoryGrow(_) => 1000,          // Expensive
            
            // Arithmetic
            I32Add | I64Add | I32Sub | I64Sub => 1,
            I32Mul | I64Mul => 4,
            I32DivU | I64DivU | I32DivS | I64DivS => 16,
            
            // Control flow
            Call(_) => 10,
            CallIndirect(_, _) => 15,
            
            // Default
            _ => 1,
        })
    }
    
    fn memory_grow_cost(&self) -> u32 {
        1000  // Per page (64 KB)
    }
}
```

### 8.2 Gas Estimation

```rust
pub fn estimate_contract_call_gas(
    contract_addr: &Address,
    method: &str,
    args: &[u8],
) -> Result<u64> {
    // Create a dry-run instance with high gas limit
    let instance = instantiate_contract(
        contract_addr,
        &Address::default(),
        u64::MAX,
    )?;
    
    // Execute dry-run
    let result = instance.call_method(method, args)?;
    
    // Return gas used (with 20% buffer)
    Ok(instance.store.data().gas_used * 120 / 100)
}
```

---

## 9. Security Considerations

### 9.1 Reentrancy Protection

```rust
impl ContractState {
    fn check_reentrancy(&self, contract_addr: &Address) -> Result<()> {
        // Check if this contract is already in the call stack
        if self.is_in_call_stack(contract_addr) {
            return Err(Error::ReentrancyDetected);
        }
        Ok(())
    }
    
    fn is_in_call_stack(&self, contract_addr: &Address) -> bool {
        // Track call stack in execution context
        self.call_stack.contains(contract_addr)
    }
}
```

### 9.2 DoS Protection

```rust
const MAX_CONTRACT_SIZE: usize = 1024 * 1024;  // 1 MB
const MAX_STORAGE_SIZE: usize = 10 * 1024 * 1024;  // 10 MB per contract
const MAX_CALL_DEPTH: u32 = 10;
const MAX_EXECUTION_TIME: Duration = Duration::from_secs(10);

fn enforce_limits(instance: &ContractInstance) -> Result<()> {
    // Contract size limit
    if instance.code_size() > MAX_CONTRACT_SIZE {
        return Err(Error::ContractTooLarge);
    }
    
    // Storage size limit
    if instance.storage_size() > MAX_STORAGE_SIZE {
        return Err(Error::StorageLimitExceeded);
    }
    
    // Call depth limit
    if instance.store.data().call_depth > MAX_CALL_DEPTH {
        return Err(Error::CallDepthExceeded);
    }
    
    Ok(())
}
```

---

## 10. Performance Benchmarks

### 10.1 Execution Performance

| Operation                      | Gas Cost | Time (avg) | Throughput  |
| ------------------------------ | -------- | ---------- | ----------- |
| **Empty contract call**        | 21,000   | 0.1ms      | 10,000 TPS  |
| **Storage read**               | 5,000    | 0.5ms      | 2,000 ops/s |
| **Storage write**              | 20,000   | 2ms        | 500 ops/s   |
| **ML-KEM encrypt**             | 10,000   | 1.2ms      | 833 ops/s   |
| **ML-KEM decrypt**             | 10,000   | 1.0ms      | 1,000 ops/s |
| **ML-DSA sign**                | 15,000   | 1.8ms      | 555 ops/s   |
| **ML-DSA verify**              | 8,000    | 0.8ms      | 1,250 ops/s |
| **Token transfer (encrypted)** | 150,000  | 8ms        | 125 TPS     |

### 10.2 Compared to EVM

| Metric              | Ecliptica WASM         | Ethereum EVM | Ratio                 |
| ------------------- | ---------------------- | ------------ | --------------------- |
| **Base throughput** | 10,000 TPS             | 15 TPS       | 666√ó                  |
| **Gas per tx**      | 150,000                | 21,000       | 7√ó (privacy overhead) |
| **Privacy**         | Native encrypted state | None         | ‚àû                     |
| **PQ Security**     | Yes                    | No           | -                     |

---

## Appendix A: Complete Example Contract

```rust
// Private voting contract

use ecliptica_contract_sdk::*;

#[contract]
pub struct PrivateVoting {
    // Proposal details (public)
    proposal_id: u64,
    proposal_text: String,
    deadline: u64,
    
    // Vote tally (encrypted)
    yes_votes: EncryptedTally,
    no_votes: EncryptedTally,
    
    // Voter registry (encrypted)
    voters: HashMap<Address, VoterRecord>,
    
    // Admin
    admin: Address,
}

#[derive(Serialize, Deserialize)]
struct EncryptedTally {
    ciphertext: Vec<u8>,
    commitment: [u8; 32],
}

#[derive(Serialize, Deserialize)]
struct VoterRecord {
    has_voted: bool,
    vote_commitment: [u8; 32],
}

#[contract_impl]
impl PrivateVoting {
    pub fn new(
        proposal_text: String,
        deadline: u64,
        admin_pubkey: &[u8],
    ) -> Self {
        let admin = context::caller();
        
        // Initialize encrypted tallies (both start at 0)
        let zero_bytes = 0u64.to_le_bytes();
        let yes_votes = EncryptedTally {
            ciphertext: crypto::encrypt(admin_pubkey, &zero_bytes),
            commitment: compute_commitment(0),
        };
        let no_votes = yes_votes.clone();
        
        Self {
            proposal_id: context::block_height(),
            proposal_text,
            deadline,
            yes_votes,
            no_votes,
            voters: HashMap::new(),
            admin,
        }
    }
    
    pub fn cast_vote(
        &mut self,
        vote: bool,
        vote_proof: VoteProof,
    ) -> Result<()> {
        let voter = context::caller();
        
        // Check deadline
        if context::block_height() > self.deadline {
            return Err(Error::VotingClosed);
        }
        
        // Check if already voted
        if self.voters.get(&voter).map_or(false, |r| r.has_voted) {
            return Err(Error::AlreadyVoted);
        }
        
        // Verify vote proof (proves voter eligibility)
        if !self.verify_vote_proof(&voter, &vote_proof) {
            return Err(Error::InvalidProof);
        }
        
        // Update tally (encrypted)
        if vote {
            self.yes_votes = vote_proof.new_yes_tally;
        } else {
            self.no_votes = vote_proof.new_no_tally;
        }
        
        // Mark as voted
        self.voters.insert(voter, VoterRecord {
            has_voted: true,
            vote_commitment: vote_proof.vote_commitment,
        });
        
        // Emit encrypted event
        contract::emit_event("vote_cast", &serialize(&vote_proof));
        
        Ok(())
    }
    
    pub fn get_results(&self, viewing_key: &[u8]) -> Result<(u64, u64)> {
        // Only admin or authorized parties can view
        if context::caller() != self.admin {
            return Err(Error::Unauthorized);
        }
        
        // Check if voting closed
        if context::block_height() <= self.deadline {
            return Err(Error::VotingStillOpen);
        }
        
        // Decrypt tallies
        let yes_bytes = crypto::decrypt(viewing_key, &self.yes_votes.ciphertext)?;
        let no_bytes = crypto::decrypt(viewing_key, &self.no_votes.ciphertext)?;
        
        let yes_count = u64::from_le_bytes(yes_bytes.try_into().unwrap());
        let no_count = u64::from_le_bytes(no_bytes.try_into().unwrap());
        
        Ok((yes_count, no_count))
    }
    
    fn verify_vote_proof(&self, voter: &Address, proof: &VoteProof) -> bool {
        // Verify zk-STARK proof that:
        // 1. Voter is eligible
        // 2. New tally is correct
        // 3. Voter hasn't voted before
        
        verify_stark_proof(&proof.stark_proof, &proof.public_inputs)
    }
}

#[derive(Serialize, Deserialize)]
struct VoteProof {
    new_yes_tally: EncryptedTally,
    new_no_tally: EncryptedTally,
    vote_commitment: [u8; 32],
    stark_proof: Vec<u8>,
    public_inputs: Vec<u8>,
}

fn compute_commitment(value: u64) -> [u8; 32] {
    shake256(&value.to_le_bytes())
}
```

---

**Document ID:** `ECLIPT-CONTRACT-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review