# üîê **Ecliptica Smart Contract VM & Privacy-Preserving Execution Specification**

### *Post-Quantum Confidential Computing on Blockchain*

**Version:** 1.0 (Complete Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-CONTRACT-001`  
**Depends On:** `ECLIPT-STATE-001`, `ECLIPT-TX-001`, `ECLIPT-MEV-001`

---

## 1. Executive Summary

Ecliptica's smart contract layer combines **Wasmtime** with a custom **privacy-preserving execution environment** to enable:

- **Confidential State**: All contract storage encrypted with ML-KEM
- **Post-Quantum Security**: ML-DSA signatures, ML-KEM encryption throughout
- **Deterministic Execution**: Strict configuration ensuring reproducibility
- **High Performance**: JIT compilation with gas metering
- **Privacy-Preserving Calls**: Encrypted inter-contract communication
- **Selective Disclosure**: Viewing keys for granular access control

**Performance Targets:**
- Contract execution: 10,000 TPS
- Gas cost overhead (privacy): +30-50% vs plaintext
- Contract deployment: <100ms
- Encrypted storage access: <1ms per key
- Cross-contract call: <5ms

---

## 2. Architecture Overview

### 2.1 System Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Ecliptica Smart Contract Architecture            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Contract SDK (Rust)                            ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Encrypted state macros                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Message passing interfaces                   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - PQ crypto primitives                         ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ cargo build --target wasm32        ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  WASM Bytecode (deterministic)                  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - No floats, no threads, no WASI               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Gas instrumentation                          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Memory sandboxing                            ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ deploy                               ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Contract Registry (on-chain)                   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Code hash ‚Üí WASM bytecode                    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Contract address ‚Üí Code hash                 ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Access control policies                      ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ instantiate                          ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Wasmtime Runtime (configured)                  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Deterministic config                         ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Fuel metering                                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Memory limits                                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - No syscalls                                  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ execute                              ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Host Environment (Ecliptica VM)                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - storage_read/write (encrypted)               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - crypto_encrypt/decrypt (ML-KEM)              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - crypto_sign/verify (ML-DSA)                  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - call_contract (encrypted)                    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - emit_event (encrypted)                       ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                    ‚îÇ persist                              ‚îÇ
‚îÇ                    ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  Encrypted Contract State                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - KV store (all values encrypted)              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - State commitments (Merkle tree)              ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Access logs (encrypted)                      ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Contract Lifecycle

```
1. DEVELOPMENT
   Developer writes contract in Rust
   ‚Üì
2. COMPILATION
   cargo build --target wasm32-unknown-unknown
   ‚Üì
3. OPTIMIZATION
   wasm-opt (deterministic optimizations only)
   ‚Üì
4. DEPLOYMENT
   Submit WASM bytecode + initial state
   Pay deployment fee
   ‚Üì
5. INSTANTIATION
   Contract address assigned
   Code stored on-chain
   Initial state encrypted and stored
   ‚Üì
6. EXECUTION
   Users call contract methods
   State updates encrypted
   Events emitted (encrypted)
   ‚Üì
7. UPGRADE (optional)
   Deploy new code
   Migrate state (if needed)
   Old code remains accessible
```

---

## 3. Wasmtime Configuration

### 3.1 Engine Configuration

```rust
use wasmtime::*;

pub struct EclipticaEngine {
    engine: Engine,
    module_cache: ModuleCache,
}

impl EclipticaEngine {
    pub fn new() -> Result<Self> {
        let mut config = Config::new();
        
        // === DETERMINISM REQUIREMENTS ===
        
        // Disable non-deterministic features
        config.wasm_simd(false);              // SIMD non-deterministic on some CPUs
        config.wasm_threads(false);           // Threads = non-determinism
        config.wasm_memory64(false);          // Not needed
        
        // Enable safe deterministic features
        config.wasm_bulk_memory(true);        // Deterministic bulk ops
        config.wasm_multi_value(true);        // Multiple return values
        config.wasm_reference_types(false);   // Complex, not needed
        
        // === COMPILATION STRATEGY ===
        
        // Use Cranelift AOT (deterministic)
        config.strategy(Strategy::Cranelift)?;
        config.cranelift_opt_level(OptLevel::Speed)?;
        
        // Deterministic float handling (if ever enabled)
        config.cranelift_nan_canonicalization(true);
        
        // === RESOURCE LIMITS ===
        
        config.max_wasm_stack(1024 * 1024)?;  // 1 MB stack max
        
        // Pooling allocator (pre-allocate resources)
        config.allocation_strategy(InstanceAllocationStrategy::Pooling {
            strategy: PoolingAllocationStrategy {
                instance_limits: InstanceLimits {
                    count: 1000,              // Max 1000 concurrent instances
                    memory_pages: 2048,       // 128 MB max memory per instance
                    table_elements: 10_000,   // Max table size
                },
                pooling_allocation_config: PoolingAllocationConfig {
                    max_core_instance_size: 1024 * 1024,  // 1 MB
                    max_memories_per_module: 1,
                    max_tables_per_module: 1,
                    total_memories: 1000,
                    total_tables: 1000,
                    total_stacks: 1000,
                    max_memory_size: 128 * 1024 * 1024,   // 128 MB
                },
            },
        });
        
        // === GAS METERING ===
        
        config.consume_fuel(true)?;           // Enable fuel consumption
        config.epoch_interruption(true);      // Enable epoch-based timeout
        
        // === SECURITY ===
        
        // No WASI (no syscalls)
        // No dynamic linking
        // No file system access
        
        let engine = Engine::new(&config)?;
        
        Ok(Self {
            engine,
            module_cache: ModuleCache::new(),
        })
    }
}

// Module cache (avoid recompilation)
struct ModuleCache {
    cache: lru::LruCache<[u8; 32], Module>,
}

impl ModuleCache {
    fn new() -> Self {
        Self {
            cache: lru::LruCache::new(std::num::NonZeroUsize::new(100).unwrap()),
        }
    }
    
    fn get_or_compile(&mut self, code_hash: [u8; 32], wasm: &[u8], engine: &Engine) -> Result<Module> {
        if let Some(module) = self.cache.get(&code_hash) {
            return Ok(module.clone());
        }
        
        // Compile and cache
        let module = Module::new(engine, wasm)?;
        self.cache.put(code_hash, module.clone());
        
        Ok(module)
    }
}
```

### 3.2 Instance Configuration

```rust
pub struct ContractInstance {
    instance: Instance,
    store: Store<ContractState>,
    memory: Memory,
}

pub struct ContractState {
    // Contract metadata
    contract_address: Address,
    code_hash: [u8; 32],
    
    // Execution context
    caller: Address,
    block_height: u64,
    block_timestamp: u64,
    
    // Gas metering
    gas_limit: u64,
    gas_used: u64,
    
    // Storage interface
    storage: Arc<RwLock<EncryptedStorage>>,
    
    // Crypto interface
    crypto: Arc<CryptoProvider>,
    
    // Call stack (prevent reentrancy)
    call_depth: u32,
    max_call_depth: u32,
}

impl ContractInstance {
    pub fn instantiate(
        engine: &Engine,
        module: &Module,
        contract_address: Address,
        caller: Address,
        gas_limit: u64,
    ) -> Result<Self> {
        let state = ContractState {
            contract_address,
            code_hash: compute_code_hash(module),
            caller,
            block_height: get_current_height(),
            block_timestamp: get_current_timestamp(),
            gas_limit,
            gas_used: 0,
            storage: Arc::new(RwLock::new(EncryptedStorage::new(contract_address))),
            crypto: Arc::new(CryptoProvider::new()),
            call_depth: 0,
            max_call_depth: 10,
        };
        
        let mut store = Store::new(engine, state);
        
        // Set gas limit
        store.set_fuel(gas_limit)?;
        
        // Set epoch deadline (timeout protection)
        store.set_epoch_deadline(1);
        
        // Create linker with host functions
        let mut linker = Linker::new(engine);
        register_host_functions(&mut linker)?;
        
        // Instantiate
        let instance = linker.instantiate(&mut store, module)?;
        
        // Get memory export
        let memory = instance.get_memory(&mut store, "memory")
            .ok_or(Error::NoMemoryExport)?;
        
        Ok(Self {
            instance,
            store,
            memory,
        })
    }
}
```

---

## 4. Host Functions (VM ‚Üî Blockchain Interface)

### 4.1 Complete Host Function Registry

```rust
fn register_host_functions(linker: &mut Linker<ContractState>) -> Result<()> {
    // === STORAGE OPERATIONS (3) ===
    
    // Read encrypted value from storage
    linker.func_wrap(
        "env",
        "storage_read",
        |mut caller: Caller<'_, ContractState>, key_ptr: i32, key_len: i32| -> i32 {
            let state = caller.data();
            
            // Charge gas
            charge_gas(&mut caller, GAS_STORAGE_READ)?;
            
            // Read key from WASM memory
            let memory = get_memory(&mut caller)?;
            let key = read_bytes(&memory, &caller, key_ptr, key_len)?;
            
            // Read from encrypted storage
            let storage = state.storage.read().unwrap();
            let value = storage.read(&key, &state.contract_address)?;
            
            // Write value to WASM memory (return pointer)
            let value_ptr = allocate_in_wasm(&mut caller, value.len())?;
            write_bytes(&memory, &mut caller, value_ptr, &value)?;
            
            Ok(value_ptr)
        },
    )?;
    
    // Write encrypted value to storage
    linker.func_wrap(
        "env",
        "storage_write",
        |mut caller: Caller<'_, ContractState>, 
         key_ptr: i32, key_len: i32,
         value_ptr: i32, value_len: i32| -> Result<()> {
            let state = caller.data();
            
            // Charge gas (more expensive)
            charge_gas(&mut caller, GAS_STORAGE_WRITE)?;
            
            // Read key and value from WASM memory
            let memory = get_memory(&mut caller)?;
            let key = read_bytes(&memory, &caller, key_ptr, key_len)?;
            let value = read_bytes(&memory, &caller, value_ptr, value_len)?;
            
            // Write to encrypted storage
            let mut storage = state.storage.write().unwrap();
            storage.write(&key, &value, &state.contract_address)?;
            
            Ok(())
        },
    )?;
    
    // Remove value from storage
    linker.func_wrap(
        "env",
        "storage_remove",
        |mut caller: Caller<'_, ContractState>, key_ptr: i32, key_len: i32| -> Result<()> {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_STORAGE_WRITE)?;
            
            let memory = get_memory(&mut caller)?;
            let key = read_bytes(&memory, &caller, key_ptr, key_len)?;
            
            let mut storage = state.storage.write().unwrap();
            storage.remove(&key, &state.contract_address)?;
            
            Ok(())
        },
    )?;
    
    // === CRYPTOGRAPHY OPERATIONS (4) ===
    
    // ML-KEM-512 encryption
    linker.func_wrap(
        "env",
        "crypto_encrypt",
        |mut caller: Caller<'_, ContractState>,
         plaintext_ptr: i32, plaintext_len: i32,
         pubkey_ptr: i32| -> i32 {
            charge_gas(&mut caller, GAS_MLKEM_ENCRYPT)?;
            
            let memory = get_memory(&mut caller)?;
            let plaintext = read_bytes(&memory, &caller, plaintext_ptr, plaintext_len)?;
            let pubkey = read_bytes(&memory, &caller, pubkey_ptr, ML_KEM_PUBKEY_SIZE)?;
            
            let state = caller.data();
            let ciphertext = state.crypto.ml_kem_encrypt(&pubkey, &plaintext)?;
            
            let ct_ptr = allocate_in_wasm(&mut caller, ciphertext.len())?;
            write_bytes(&memory, &mut caller, ct_ptr, &ciphertext)?;
            
            Ok(ct_ptr)
        },
    )?;
    
    // ML-KEM-512 decryption
    linker.func_wrap(
        "env",
        "crypto_decrypt",
        |mut caller: Caller<'_, ContractState>,
         ciphertext_ptr: i32, ciphertext_len: i32,
         seckey_ptr: i32| -> i32 {
            charge_gas(&mut caller, GAS_MLKEM_DECRYPT)?;
            
            let memory = get_memory(&mut caller)?;
            let ciphertext = read_bytes(&memory, &caller, ciphertext_ptr, ciphertext_len)?;
            let seckey = read_bytes(&memory, &caller, seckey_ptr, ML_KEM_SECKEY_SIZE)?;
            
            let state = caller.data();
            let plaintext = state.crypto.ml_kem_decrypt(&seckey, &ciphertext)?;
            
            let pt_ptr = allocate_in_wasm(&mut caller, plaintext.len())?;
            write_bytes(&memory, &mut caller, pt_ptr, &plaintext)?;
            
            Ok(pt_ptr)
        },
    )?;
    
    // ML-DSA signature
    linker.func_wrap(
        "env",
        "crypto_sign",
        |mut caller: Caller<'_, ContractState>,
         message_ptr: i32, message_len: i32,
         seckey_ptr: i32| -> i32 {
            charge_gas(&mut caller, GAS_MLDSA_SIGN)?;
            
            let memory = get_memory(&mut caller)?;
            let message = read_bytes(&memory, &caller, message_ptr, message_len)?;
            let seckey = read_bytes(&memory, &caller, seckey_ptr, ML_DSA_SECKEY_SIZE)?;
            
            let state = caller.data();
            let signature = state.crypto.ml_dsa_sign(&seckey, &message)?;
            
            let sig_ptr = allocate_in_wasm(&mut caller, signature.len())?;
            write_bytes(&memory, &mut caller, sig_ptr, &signature)?;
            
            Ok(sig_ptr)
        },
    )?;
    
    // ML-DSA verification
    linker.func_wrap(
        "env",
        "crypto_verify",
        |mut caller: Caller<'_, ContractState>,
         message_ptr: i32, message_len: i32,
         signature_ptr: i32, signature_len: i32,
         pubkey_ptr: i32| -> i32 {
            charge_gas(&mut caller, GAS_MLDSA_VERIFY)?;
            
            let memory = get_memory(&mut caller)?;
            let message = read_bytes(&memory, &caller, message_ptr, message_len)?;
            let signature = read_bytes(&memory, &caller, signature_ptr, signature_len)?;
            let pubkey = read_bytes(&memory, &caller, pubkey_ptr, ML_DSA_PUBKEY_SIZE)?;
            
            let state = caller.data();
            let valid = state.crypto.ml_dsa_verify(&pubkey, &message, &signature)?;
            
            Ok(if valid { 1 } else { 0 })
        },
    )?;
    
    // === BLOCKCHAIN CONTEXT (3) ===
    
    // Get caller address
    linker.func_wrap(
        "env",
        "get_caller",
        |mut caller: Caller<'_, ContractState>| -> i32 {
            charge_gas(&mut caller, 100)?;  // Minimal gas
            
            let state = caller.data();
            let memory = get_memory(&mut caller)?;
            
            let addr_ptr = allocate_in_wasm(&mut caller, 20)?;
            write_bytes(&memory, &mut caller, addr_ptr, &state.caller)?;
            
            Ok(addr_ptr)
        },
    )?;
    
    // Get current block height
    linker.func_wrap(
        "env",
        "get_block_height",
        |mut caller: Caller<'_, ContractState>| -> i64 {
            charge_gas(&mut caller, 100)?;
            Ok(caller.data().block_height as i64)
        },
    )?;
    
    // Get current block timestamp
    linker.func_wrap(
        "env",
        "get_block_timestamp",
        |mut caller: Caller<'_, ContractState>| -> i64 {
            charge_gas(&mut caller, 100)?;
            Ok(caller.data().block_timestamp as i64)
        },
    )?;
    
    // === INTER-CONTRACT OPERATIONS (2) ===
    
    // Call another contract
    linker.func_wrap(
        "env",
        "call_contract",
        |mut caller: Caller<'_, ContractState>,
         contract_addr_ptr: i32,
         method_ptr: i32, method_len: i32,
         args_ptr: i32, args_len: i32,
         gas_limit: i64| -> i32 {
            let state = caller.data();
            
            // Check reentrancy
            if state.call_depth >= state.max_call_depth {
                return Err(Error::MaxCallDepthExceeded);
            }
            
            // Charge base gas
            charge_gas(&mut caller, GAS_CALL_CONTRACT_BASE)?;
            
            let memory = get_memory(&mut caller)?;
            let contract_addr = read_bytes(&memory, &caller, contract_addr_ptr, 20)?;
            let method = read_bytes(&memory, &caller, method_ptr, method_len)?;
            let args = read_bytes(&memory, &caller, args_ptr, args_len)?;
            
            // Execute cross-contract call
            let result = execute_contract_call(
                &contract_addr,
                &method,
                &args,
                gas_limit as u64,
                state.call_depth + 1,
            )?;
            
            // Return result
            let result_ptr = allocate_in_wasm(&mut caller, result.len())?;
            write_bytes(&memory, &mut caller, result_ptr, &result)?;
            
            Ok(result_ptr)
        },
    )?;
    
    // Emit encrypted event
    linker.func_wrap(
        "env",
        "emit_event",
        |mut caller: Caller<'_, ContractState>,
         topic_ptr: i32, topic_len: i32,
         data_ptr: i32, data_len: i32| -> Result<()> {
            let state = caller.data();
            
            charge_gas(&mut caller, GAS_EMIT_EVENT)?;
            
            let memory = get_memory(&mut caller)?;
            let topic = read_bytes(&memory, &caller, topic_ptr, topic_len)?;
            let data = read_bytes(&memory, &caller, data_ptr, data_len)?;
            
            // Emit encrypted event
            emit_contract_event(
                &state.contract_address,
                &topic,
                &data,
            )?;
            
            Ok(())
        },
    )?;
    
    // === HELPER FUNCTIONS (5) ===
    
    // Hash function (SHAKE-256)
    linker.func_wrap(
        "env",
        "hash",
        |mut caller: Caller<'_, ContractState>,
         data_ptr: i32, data_len: i32| -> i32 {
            charge_gas(&mut caller, 1000)?;
            
            let memory = get_memory(&mut caller)?;
            let data = read_bytes(&memory, &caller, data_ptr, data_len)?;
            
            let hash = shake256(&data);
            
            let hash_ptr = allocate_in_wasm(&mut caller, 32)?;
            write_bytes(&memory, &mut caller, hash_ptr, &hash)?;
            
            Ok(hash_ptr)
        },
    )?;
    
    // Random bytes (deterministic from block hash)
    linker.func_wrap(
        "env",
        "random_bytes",
        |mut caller: Caller<'_, ContractState>, len: i32| -> i32 {
            charge_gas(&mut caller, 1000)?;
            
            let state = caller.data();
            let random = derive_random_bytes(
                state.block_height,
                &state.contract_address,
                len as usize,
            );
            
            let memory = get_memory(&mut caller)?;
            let random_ptr = allocate_in_wasm(&mut caller, random.len())?;
            write_bytes(&memory, &mut caller, random_ptr, &random)?;
            
            Ok(random_ptr)
        },
    )?;
    
    // Debug log (only in dev mode)
    #[cfg(debug_assertions)]
    linker.func_wrap(
        "env",
        "debug_log",
        |mut caller: Caller<'_, ContractState>, msg_ptr: i32, msg_len: i32| {
            let memory = get_memory(&mut caller)?;
            let msg = read_bytes(&memory, &caller, msg_ptr, msg_len)?;
            let msg_str = String::from_utf8_lossy(&msg);
            eprintln!("[CONTRACT DEBUG] {}", msg_str);
            Ok(())
        },
    )?;
    
    Ok(())
}
```

### 4.2 Gas Costs

```rust
// Gas costs for host functions
const GAS_STORAGE_READ: u64 = 5_000;
const GAS_STORAGE_WRITE: u64 = 20_000;
const GAS_MLKEM_ENCRYPT: u64 = 10_000;
const GAS_MLKEM_DECRYPT: u64 = 10_000;
const GAS_MLDSA_SIGN: u64 = 15_000;
const GAS_MLDSA_VERIFY: u64 = 8_000;
const GAS_CALL_CONTRACT_BASE: u64 = 50_000;
const GAS_EMIT_EVENT: u64 = 1_000;

// WASM instruction gas costs (via instrumentation)
const GAS_PER_INSTRUCTION: u64 = 1;
const GAS_PER_MEMORY_GROW: u64 = 1_000;  // Per page (64 KB)

// Crypto key sizes
const ML_KEM_PUBKEY_SIZE: usize = 800;
const ML_KEM_SECKEY_SIZE: usize = 1632;
const ML_DSA_PUBKEY_SIZE: usize = 1952;
const ML_DSA_SECKEY_SIZE: usize = 4000;

fn charge_gas(caller: &mut Caller<'_, ContractState>, amount: u64) -> Result<()> {
    let state = caller.data_mut();
    
    state.gas_used += amount;
    
    if state.gas_used > state.gas_limit {
        return Err(Error::OutOfGas);
    }
    
    // Also consume fuel in Wasmtime
    caller.consume_fuel(amount)?;
    
    Ok(())
}
```

---

## 5. Encrypted Storage Layer

### 5.1 Storage Architecture

```rust
pub struct EncryptedStorage {
    contract_address: Address,
    
    // In-memory cache (plaintext)
    cache: HashMap<Vec<u8>, Vec<u8>>,
    
    // Persistent backend (encrypted)
    backend: Arc<dyn StorageBackend>,
    
    // Encryption key (derived from contract address)
    storage_key: [u8; 32],
}

impl EncryptedStorage {
    pub fn new(contract_address: Address) -> Self {
        // Derive storage encryption key from contract address
        let storage_key = derive_storage_key(&contract_address);
        
        Self {
            contract_address,
            cache: HashMap::new(),
            backend: Arc::new(RocksDBBackend::new()),
            storage_key,
        }
    }
    
    pub fn read(&self, key: &[u8], contract_addr: &Address) -> Result<Vec<u8>> {
        // Check cache first
        if let Some(value) = self.cache.get(key) {
            return Ok(value.clone());
        }
        
        // Read from encrypted backend
        let storage_key_hash = compute_storage_key_hash(contract_addr, key);
        let encrypted_value = self.backend.get(&storage_key_hash)?
            .ok_or(Error::KeyNotFound)?;
        
        // Decrypt value
        let plaintext = aes_gcm_decrypt(&encrypted_value, &self.storage_key)?;
        
        Ok(plaintext)
    }
    
    pub fn write(&mut self, key: &[u8], value: &[u8], contract_addr: &Address) -> Result<()> {
        // Encrypt value
        let encrypted_value = aes_gcm_encrypt(value, &self.storage_key)?;
        
        // Compute storage key
        let storage_key_hash = compute_storage_key_hash(contract_addr, key);
        
        // Write to backend
        self.backend.put(&storage_key_hash, &encrypted_value)?;
        
        // Update cache
        self.cache.insert(key.to_vec(), value.to_vec());
        
        Ok(())
    }
    
    pub fn remove(&mut self, key: &[u8], contract_addr: &Address) -> Result<()> {
        // Remove from cache
        self.cache.remove(key);
        
        // Remove from backend
        let storage_key_hash = compute_storage_key_hash(contract_addr, key);
        self.backend.delete(&storage_key_hash)?;
        
        Ok(())
    }
    
    pub fn commit(&mut self) -> Result<()> {
        // Flush cache to backend
        self.backend.commit()?;
        Ok(())
    }
}

fn derive_storage_key(contract_address: &Address) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_STORAGE_KEY_v1");
    hasher.update(contract_address);
    
    let mut key = [0u8; 32];
    hasher.finalize_xof_into(&mut key);
    key
}

fn compute_storage_key_hash(contract_addr: &Address, key: &[u8]) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(contract_addr);
    hasher.update(key);
    
    let mut hash = [0u8; 32];
    hasher.finalize_xof_into(&mut hash);
    hash
}
```

### 5.2 Viewing Keys for Storage

```rust
pub struct StorageViewingKey {
    contract_address: Address,
    viewing_key: [u8; 32],              // Derived from user secret
    permissions: ViewingPermissions,
}

#[derive(Clone)]
pub struct ViewingPermissions {
    can_read_all: bool,
    specific_keys: HashSet<Vec<u8>>,    // Specific keys allowed
}

impl StorageViewingKey {
    pub fn derive(
        user_secret: &[u8; 32],
        contract_address: &Address,
    ) -> Self {
        let viewing_key = derive_contract_viewing_key(user_secret, contract_address);
        
        Self {
            contract_address: *contract_address,
            viewing_key,
            permissions: ViewingPermissions {
                can_read_all: true,
                specific_keys: HashSet::new(),
            },
        }
    }
    
    pub fn read_with_viewing_key(
        &self,
        storage: &EncryptedStorage,
        key: &[u8],
    ) -> Result<Vec<u8>> {
        // Check permissions
        if !self.permissions.can_read_all && !self.permissions.specific_keys.contains(key) {
            return Err(Error::PermissionDenied);
        }
        
        // Read encrypted value
        let storage_key_hash = compute_storage_key_hash(&self.contract_address, key);
        let encrypted_value = storage.backend.get(&storage_key_hash)?
            .ok_or(Error::KeyNotFound)?;
        
        // Decrypt with viewing key
        let plaintext = aes_gcm_decrypt(&encrypted_value, &self.viewing_key)?;
        
        Ok(plaintext)
    }
}

fn derive_contract_viewing_key(user_secret: &[u8; 32], contract_addr: &Address) -> [u8; 32] {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_VIEWING_KEY_v1");
    hasher.update(user_secret);
    hasher.update(contract_addr);
    
    let mut key = [0u8; 32];
    hasher.finalize_xof_into(&mut key);
    key
}
```

---

## 6. Contract SDK (Rust Developer API)

### 6.1 Core Macros

```rust
// ecliptica_contract_sdk/src/lib.rs

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemStruct, ItemImpl};

/// Main contract macro - marks a struct as a contract
/// 
/// Generates:
/// - Serialization/deserialization
/// - Storage load/save methods
/// - Entry point exports
#[proc_macro_attribute]
pub fn contract(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    let struct_name = &input.ident;
    
    quote! {
        #[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
        #input
        
        impl #struct_name {
            /// Load contract state from storage
            pub fn load() -> Self {
                match ecliptica_sdk::storage::read(b"STATE") {
                    Ok(state_bytes) => {
                        serde_json::from_slice(&state_bytes)
                            .expect("Failed to deserialize contract state")
                    }
                    Err(_) => Self::default(),
                }
            }
            
            /// Save contract state to storage
            pub fn save(&self) {
                let state_bytes = serde_json::to_vec(self)
                    .expect("Failed to serialize contract state");
                ecliptica_sdk::storage::write(b"STATE", &state_bytes)
                    .expect("Failed to save contract state");
            }
        }
    }.into()
}

/// Contract implementation macro - generates entry points
#[proc_macro_attribute]
pub fn contract_impl(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemImpl);
    let self_ty = &input.self_ty;
    
    // Extract public methods
    let mut entry_points = Vec::new();
    for item in &input.items {
        if let syn::ImplItem::Fn(method) = item {
            if matches!(method.vis, syn::Visibility::Public(_)) {
                let method_name = &method.sig.ident;
                let method_name_str = method_name.to_string();
                
                entry_points.push(quote! {
                    #[no_mangle]
                    pub extern "C" fn #method_name() -> i32 {
                        let mut contract = #self_ty::load();
                        let result = contract.#method_name();
                        contract.save();
                        
                        // Serialize and return result
                        let result_bytes = serde_json::to_vec(&result).unwrap();
                        ecliptica_sdk::__return_bytes(&result_bytes)
                    }
                });
            }
        }
    }
    
    quote! {
        #input
        
        // Generated entry points
        #(#entry_points)*
    }.into()
}
```

### 6.2 SDK Modules

```rust
// ecliptica_contract_sdk/src/storage.rs

pub mod storage {
    extern "C" {
        fn storage_read(key_ptr: *const u8, key_len: usize) -> i32;
        fn storage_write(key_ptr: *const u8, key_len: usize, value_ptr: *const u8, value_len: usize);
        fn storage_remove(key_ptr: *const u8, key_len: usize);
    }
    
    pub fn read(key: &[u8]) -> Result<Vec<u8>, Error> {
        unsafe {
            let value_ptr = storage_read(key.as_ptr(), key.len());
            if value_ptr < 0 {
                return Err(Error::KeyNotFound);
            }
            Ok(read_bytes_from_host(value_ptr))
        }
    }
    
    pub fn write(key: &[u8], value: &[u8]) -> Result<(), Error> {
        unsafe {
            storage_write(key.as_ptr(), key.len(), value.as_ptr(), value.len());
            Ok(())
        }
    }
    
    pub fn remove(key: &[u8]) -> Result<(), Error> {
        unsafe {
            storage_remove(key.as_ptr(), key.len());
            Ok(())
        }
    }
}

// ecliptica_contract_sdk/src/crypto.rs

pub mod crypto {
    extern "C" {
        fn crypto_encrypt(plaintext_ptr: *const u8, plaintext_len: usize, pubkey_ptr: *const u8) -> i32;
        fn crypto_decrypt(ciphertext_ptr: *const u8, ciphertext_len: usize, seckey_ptr: *const u8) -> i32;
        fn crypto_sign(message_ptr: *const u8, message_len: usize, seckey_ptr: *const u8) -> i32;
        fn crypto_verify(message_ptr: *const u8, message_len: usize, 
                        signature_ptr: *const u8, signature_len: usize,
                        pubkey_ptr: *const u8) -> i32;
    }
    
    pub fn encrypt(plaintext: &[u8], pubkey: &[u8]) -> Vec<u8> {
        unsafe {
            let ct_ptr = crypto_encrypt(plaintext.as_ptr(), plaintext.len(), pubkey.as_ptr());
            read_bytes_from_host(ct_ptr)
        }
    }
    
    pub fn decrypt(ciphertext: &[u8], seckey: &[u8]) -> Vec<u8> {
        unsafe {
            let pt_ptr = crypto_decrypt(ciphertext.as_ptr(), ciphertext.len(), seckey.as_ptr());
            read_bytes_from_host(pt_ptr)
        }
    }
    
    pub fn sign(message: &[u8], seckey: &[u8]) -> Vec<u8> {
        unsafe {
            let sig_ptr = crypto_sign(message.as_ptr(), message.len(), seckey.as_ptr());
            read_bytes_from_host(sig_ptr)
        }
    }
    
    pub fn verify(message: &[u8], signature: &[u8], pubkey: &[u8]) -> bool {
        unsafe {
            crypto_verify(
                message.as_ptr(), message.len(),
                signature.as_ptr(), signature.len(),
                pubkey.as_ptr()
            ) == 1
        }
    }
}

// ecliptica_contract_sdk/src/context.rs

pub mod context {
    extern "C" {
        fn get_caller() -> i32;
        fn get_block_height() -> i64;
        fn get_block_timestamp() -> i64;
    }
    
    pub fn caller() -> [u8; 20] {
        unsafe {
            let ptr = get_caller();
            read_address_from_host(ptr)
        }
    }
    
    pub fn block_height() -> u64 {
        unsafe { get_block_height() as u64 }
    }
    
    pub fn block_timestamp() -> u64 {
        unsafe { get_block_timestamp() as u64 }
    }
}

// ecliptica_contract_sdk/src/contract.rs

pub mod contract {
    extern "C" {
        fn call_contract(
            contract_addr_ptr: *const u8,
            method_ptr: *const u8, method_len: usize,
            args_ptr: *const u8, args_len: usize,
            gas_limit: i64,
        ) -> i32;
        fn emit_event(topic_ptr: *const u8, topic_len: usize,
                     data_ptr: *const u8, data_len: usize);
    }
    
    pub fn call(
        contract_addr: &[u8; 20],
        method: &str,
        args: &[u8],
        gas_limit: u64,
    ) -> Vec<u8> {
        unsafe {
            let result_ptr = call_contract(
                contract_addr.as_ptr(),
                method.as_ptr(), method.len(),
                args.as_ptr(), args.len(),
                gas_limit as i64,
            );
            read_bytes_from_host(result_ptr)
        }
    }
    
    pub fn emit_event(topic: &str, data: &[u8]) {
        unsafe {
            emit_event(
                topic.as_ptr(), topic.len(),
                data.as_ptr(), data.len(),
            );
        }
    }
}
```

### 6.3 Complete Example: Private Token

```rust
use ecliptica_contract_sdk::*;
use std::collections::HashMap;

#[contract]
pub struct PrivateToken {
    // Token metadata (public)
    name: String,
    symbol: String,
    decimals: u8,
    total_supply: u64,
    
    // Encrypted balances
    // Maps address ‚Üí encrypted balance
    balances: HashMap<Address, EncryptedBalance>,
    
    // Owner
    owner: Address,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct EncryptedBalance {
    ciphertext: Vec<u8>,        // ML-KEM encrypted
    commitment: [u8; 32],       // Pedersen commitment for ZK proofs
}

#[contract_impl]
impl PrivateToken {
    /// Constructor
    pub fn new(name: String, symbol: String, decimals: u8, initial_supply: u64) -> Self {
        let owner = context::caller();
        
        // Create encrypted balance for owner
        let owner_balance = Self::encrypt_balance(initial_supply, &owner);
        
        let mut balances = HashMap::new();
        balances.insert(owner, owner_balance);
        
        Self {
            name,
            symbol,
            decimals,
            total_supply: initial_supply,
            balances,
            owner,
        }
    }
    
    /// Get token metadata (public)
    pub fn metadata(&self) -> TokenMetadata {
        TokenMetadata {
            name: self.name.clone(),
            symbol: self.symbol.clone(),
            decimals: self.decimals,
            total_supply: self.total_supply,
        }
    }
    
    /// Transfer tokens (privacy-preserving)
    pub fn transfer(&mut self, to: Address, amount: u64, proof: TransferProof) -> Result<(), Error> {
        let from = context::caller();
        
        // Verify ZK proof of:
        // 1. Sender has sufficient balance
        // 2. Amount is positive
        // 3. New balances are correctly computed
        if !self.verify_transfer_proof(&from, &to, amount, &proof) {
            return Err(Error::InvalidProof);
        }
        
        // Update encrypted balances
        let from_new_balance = proof.new_from_balance.clone();
        let to_new_balance = proof.new_to_balance.clone();
        
        self.balances.insert(from, from_new_balance);
        self.balances.insert(to, to_new_balance);
        
        // Emit encrypted event
        let event_data = serde_json::to_vec(&TransferEvent {
            from,
            to,
            commitment: proof.amount_commitment,
        }).unwrap();
        
        contract::emit_event("Transfer", &event_data);
        
        Ok(())
    }
    
    /// Get encrypted balance
    pub fn balance_of(&self, account: &Address) -> Option<EncryptedBalance> {
        self.balances.get(account).cloned()
    }
    
    /// Decrypt balance with viewing key (read-only)
    pub fn decrypt_balance(&self, account: &Address, viewing_key: &[u8; 32]) -> Result<u64, Error> {
        let encrypted_balance = self.balances.get(account)
            .ok_or(Error::AccountNotFound)?;
        
        // Decrypt using viewing key
        let plaintext = crypto::decrypt(&encrypted_balance.ciphertext, viewing_key);
        let balance = u64::from_le_bytes(plaintext.try_into().unwrap());
        
        Ok(balance)
    }
    
    /// Mint new tokens (owner only)
    pub fn mint(&mut self, to: Address, amount: u64) -> Result<(), Error> {
        let caller = context::caller();
        
        if caller != self.owner {
            return Err(Error::Unauthorized);
        }
        
        // Update total supply
        self.total_supply += amount;
        
        // Update encrypted balance
        if let Some(existing) = self.balances.get(&to) {
            // Decrypt, add, re-encrypt
            let current = self.decrypt_balance_internal(&existing)?;
            let new_balance = current + amount;
            self.balances.insert(to, Self::encrypt_balance(new_balance, &to));
        } else {
            // New account
            self.balances.insert(to, Self::encrypt_balance(amount, &to));
        }
        
        Ok(())
    }
    
    // === Helper Functions ===
    
    fn encrypt_balance(amount: u64, address: &Address) -> EncryptedBalance {
        // Derive encryption key from address
        let pubkey = derive_address_pubkey(address);
        
        // Encrypt balance
        let plaintext = amount.to_le_bytes();
        let ciphertext = crypto::encrypt(&plaintext, &pubkey);
        
        // Create commitment
        let commitment = compute_commitment(amount);
        
        EncryptedBalance {
            ciphertext,
            commitment,
        }
    }
    
    fn decrypt_balance_internal(&self, encrypted: &EncryptedBalance) -> Result<u64, Error> {
        // Internal decryption (requires contract secret)
        // In practice, this would use a contract-specific key
        unimplemented!("Internal decryption requires secure key management")
    }
    
    fn verify_transfer_proof(
        &self,
        from: &Address,
        to: &Address,
        amount: u64,
        proof: &TransferProof,
    ) -> bool {
        // Verify zk-STARK proof
        // Proof shows:
        // 1. balance_from >= amount
        // 2. balance_from' = balance_from - amount
        // 3. balance_to' = balance_to + amount
        // 4. Commitments match
        
        verify_stark_proof(&proof.stark_proof, &proof.public_inputs)
    }
}

// === Supporting Types ===

#[derive(Serialize, Deserialize)]
pub struct TokenMetadata {
    pub name: String,
    pub symbol: String,
    pub decimals: u8,
    pub total_supply: u64,
}

#[derive(Serialize, Deserialize)]
pub struct TransferProof {
    new_from_balance: EncryptedBalance,
    new_to_balance: EncryptedBalance,
    amount_commitment: [u8; 32],
    stark_proof: Vec<u8>,
    public_inputs: Vec<u8>,
}

#[derive(Serialize, Deserialize)]
pub struct TransferEvent {
    from: Address,
    to: Address,
    commitment: [u8; 32],
}

fn compute_commitment(value: u64) -> [u8; 32] {
    // Pedersen commitment: C = vG + rH
    // For simplicity, using hash-based commitment
    shake256(&value.to_le_bytes())
}

fn derive_address_pubkey(address: &Address) -> Vec<u8> {
    // Derive ML-KEM public key from address
    // In practice, this would be stored or derived securely
    unimplemented!("Address to pubkey derivation")
}

fn verify_stark_proof(proof: &[u8], public_inputs: &[u8]) -> bool {
    // Verify STARK proof
    // TODO: Integration with winterfell or miden
    true
}
```

---

## 7. Contract Deployment

### 7.1 Deployment Transaction

```rust
#[derive(Serialize, Deserialize)]
struct ContractDeployTransaction {
    // WASM bytecode
    code: Vec<u8>,
    
    // Initial state (encrypted)
    initial_state: Vec<u8>,
    
    // Constructor arguments
    constructor_args: Vec<u8>,
    
    // Gas limit
    gas_limit: u64,
    
    // Deployer
    deployer: Address,
    signature: DilithiumSignature,
}

fn deploy_contract(tx: ContractDeployTransaction) -> Result<Address> {
    // 1. Validate WASM bytecode
    validate_wasm_module(&tx.code)?;
    
    // 2. Compute code hash
    let code_hash = shake256(&tx.code);
    
    // 3. Assign contract address (deterministic)
    let contract_address = compute_contract_address(&tx.deployer, tx.nonce, &code_hash);
    
    // 4. Store code on-chain
    store_contract_code(&code_hash, &tx.code)?;
    
    // 5. Register contract
    register_contract(&contract_address, &code_hash)?;
    
    // 6. Execute constructor
    let instance = instantiate_contract(&contract_address, &tx.deployer, tx.gas_limit)?;
    instance.call_constructor(&tx.constructor_args)?;
    
    // 7. Commit initial state
    instance.storage.commit()?;
    
    Ok(contract_address)
}

fn compute_contract_address(deployer: &Address, nonce: u64, code_hash: &[u8; 32]) -> Address {
    let mut hasher = Shake256::default();
    hasher.update(b"ECLIPTICA_CONTRACT_ADDRESS_v1");
    hasher.update(deployer);
    hasher.update(&nonce.to_le_bytes());
    hasher.update(code_hash);
    
    let mut addr = [0u8; 20];
    hasher.finalize_xof_into(&mut addr);
    addr
}
```

### 7.2 WASM Validation

```rust
fn validate_wasm_module(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Validator, WasmFeatures};
    
    // Configure allowed features
    let features = WasmFeatures {
        mutable_global: true,
        saturating_float_to_int: false,  // No floats
        sign_extension: true,
        simd: false,                      // No SIMD
        threads: false,                   // No threads
        tail_call: false,
        bulk_memory: true,
        multi_value: true,
        reference_types: false,
        ..WasmFeatures::default()
    };
    
    // Validate
    let mut validator = Validator::new_with_features(features);
    validator.validate_all(wasm)?;
    
    // Additional checks
    check_no_floats(wasm)?;
    check_no_start_function(wasm)?;
    check_memory_limits(wasm)?;
    check_no_imports_except_env(wasm)?;
    
    Ok(())
}

fn check_no_floats(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Parser, Payload, Operator};
    
    for payload in Parser::new(0).parse_all(wasm) {
        match payload? {
            Payload::CodeSectionEntry(body) => {
                for op in body.get_operators_reader()? {
                    let op = op?;
                    match op {
                        // Reject float operations
                        Operator::F32Load { .. } | Operator::F64Load { .. } |
                        Operator::F32Store { .. } | Operator::F64Store { .. } |
                        Operator::F32Const { .. } | Operator::F64Const { .. } |
                        Operator::F32Add | Operator::F64Add |
                        Operator::F32Sub | Operator::F64Sub |
                        Operator::F32Mul | Operator::F64Mul |
                        Operator::F32Div | Operator::F64Div => {
                            return Err(Error::FloatsNotAllowed);
                        }
                        _ => {}
                    }
                }
            },
            _ => {},
        }
    }
    
    Ok(())
}

fn check_no_start_function(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Parser, Payload};
    
    for payload in Parser::new(0).parse_all(wasm) {
        if matches!(payload?, Payload::StartSection { .. }) {
            return Err(Error::StartFunctionNotAllowed);
        }
    }
    
    Ok(())
}

fn check_memory_limits(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Parser, Payload};
    
    for payload in Parser::new(0).parse_all(wasm) {
        if let Payload::MemorySection(reader) = payload? {
            for memory in reader {
                let memory = memory?;
                if memory.initial > 2048 {  // 128 MB max
                    return Err(Error::MemoryLimitExceeded);
                }
            }
        }
    }
    
    Ok(())
}

fn check_no_imports_except_env(wasm: &[u8]) -> Result<()> {
    use wasmparser::{Parser, Payload};
    
    for payload in Parser::new(0).parse_all(wasm) {
        if let Payload::ImportSection(reader) = payload? {
            for import in reader {
                let import = import?;
                if import.module != "env" {
                    return Err(Error::IllegalImport(import.module.to_string()));
                }
            }
        }
    }
    
    Ok(())
}
```

---

## 8. Gas Metering

### 8.1 WASM Instrumentation

```rust
use wasm_instrument::gas_metering;

fn instrument_wasm_for_gas(wasm: &[u8]) -> Result<Vec<u8>> {
    let rules = EclipticaGasRules;
    
    let instrumented = gas_metering::inject(
        wasm,
        &rules,
        "env",          // Module name
        "charge_gas",   // Function name
    )?;
    
    Ok(instrumented)
}

struct EclipticaGasRules;

impl gas_metering::Rules for EclipticaGasRules {
    fn instruction_cost(&self, instruction: &wasm_instrument::parity_wasm::elements::Instruction) -> Option<u32> {
        use wasm_instrument::parity_wasm::elements::Instruction::*;
        
        Some(match instruction {
            // Memory operations
            I32Load(_, _) | I64Load(_, _) |
            I32Load8S(_, _) | I32Load8U(_, _) |
            I32Load16S(_, _) | I32Load16U(_, _) |
            I64Load8S(_, _) | I64Load8U(_, _) |
            I64Load16S(_, _) | I64Load16U(_, _) |
            I64Load32S(_, _) | I64Load32U(_, _) => 3,
            
            I32Store(_, _) | I64Store(_, _) |
            I32Store8(_, _) | I32Store16(_, _) |
            I64Store8(_, _) | I64Store16(_, _) |
            I64Store32(_, _) => 3,
            
            MemoryGrow(_) => 1000,          // Expensive
            MemorySize(_) => 1,
            
            // Arithmetic
            I32Add | I64Add | I32Sub | I64Sub |
            I32And | I64And | I32Or | I64Or |
            I32Xor | I64Xor | I32Shl | I64Shl |
            I32ShrS | I64ShrS | I32ShrU | I64ShrU |
            I32Rotl | I64Rotl | I32Rotr | I64Rotr => 1,
            
            I32Mul | I64Mul => 4,
            I32DivU | I64DivU | I32DivS | I64DivS |
            I32RemU | I64RemU | I32RemS | I64RemS => 16,
            
            // Comparison
            I32Eqz | I64Eqz | I32Eq | I64Eq |
            I32Ne | I64Ne | I32LtS | I64LtS |
            I32LtU | I64LtU | I32GtS | I64GtS |
            I32GtU | I64GtU | I32LeS | I64LeS |
            I32LeU | I64LeU | I32GeS | I64GeS |
            I32GeU | I64GeU => 1,
            
            // Control flow
            Call(_) => 10,
            CallIndirect(_, _) => 15,
            Block(_) | Loop(_) | If(_) => 2,
            Br(_) | BrIf(_) | BrTable(_) => 2,
            Return => 2,
            
            // Local/Global
            LocalGet(_) | LocalSet(_) | LocalTee(_) => 1,
            GlobalGet(_) | GlobalSet(_) => 2,
            
            // Default
            _ => 1,
        })
    }
    
    fn memory_grow_cost(&self) -> u32 {
        1000  // Per page (64 KB)
    }
}
```

### 8.2 Gas Estimation

```rust
pub fn estimate_contract_call_gas(
    contract_addr: &Address,
    method: &str,
    args: &[u8],
) -> Result<u64> {
    // Create a dry-run instance with high gas limit
    let instance = instantiate_contract(
        contract_addr,
        &Address::default(),
        u64::MAX,
    )?;
    
    // Execute dry-run
    let result = instance.call_method(method, args)?;
    
    // Return gas used (with 20% buffer)
    Ok(instance.store.data().gas_used * 120 / 100)
}
```

---

## 9. Security Considerations

### 9.1 Reentrancy Protection

```rust
impl ContractState {
    fn check_reentrancy(&self, contract_addr: &Address) -> Result<()> {
        // Check if this contract is already in the call stack
        if self.is_in_call_stack(contract_addr) {
            return Err(Error::ReentrancyDetected);
        }
        Ok(())
    }
    
    fn is_in_call_stack(&self, contract_addr: &Address) -> bool {
        // Track call stack in execution context
        self.call_stack.contains(contract_addr)
    }
}
```

### 9.2 DoS Protection

```rust
const MAX_CONTRACT_SIZE: usize = 1024 * 1024;  // 1 MB
const MAX_STORAGE_SIZE: usize = 10 * 1024 * 1024;  // 10 MB per contract
const MAX_CALL_DEPTH: u32 = 10;
const MAX_EXECUTION_TIME: Duration = Duration::from_secs(10);

fn enforce_limits(instance: &ContractInstance) -> Result<()> {
    // Contract size limit
    if instance.code_size() > MAX_CONTRACT_SIZE {
        return Err(Error::ContractTooLarge);
    }
    
    // Storage size limit
    if instance.storage_size() > MAX_STORAGE_SIZE {
        return Err(Error::StorageLimitExceeded);
    }
    
    // Call depth limit
    if instance.store.data().call_depth > MAX_CALL_DEPTH {
        return Err(Error::CallDepthExceeded);
    }
    
    Ok(())
}
```

---

## 10. Performance Benchmarks

### 10.1 Execution Performance

| Operation                      | Gas Cost | Time (avg) | Throughput  |
| ------------------------------ | -------- | ---------- | ----------- |
| **Empty contract call**        | 21,000   | 0.1ms      | 10,000 TPS  |
| **Storage read**               | 5,000    | 0.5ms      | 2,000 ops/s |
| **Storage write**              | 20,000   | 2ms        | 500 ops/s   |
| **ML-KEM encrypt**             | 10,000   | 1.2ms      | 833 ops/s   |
| **ML-KEM decrypt**             | 10,000   | 1.0ms      | 1,000 ops/s |
| **ML-DSA sign**                | 15,000   | 1.8ms      | 555 ops/s   |
| **ML-DSA verify**              | 8,000    | 0.8ms      | 1,250 ops/s |
| **Token transfer (encrypted)** | 150,000  | 8ms        | 125 TPS     |
| **Cross-contract call**        | 50,000+  | 5ms        | 200 TPS     |

### 10.2 Compared to EVM

| Metric              | Ecliptica WASM         | Ethereum EVM | Ratio                 |
| ------------------- | ---------------------- | ------------ | --------------------- |
| **Base throughput** | 10,000 TPS             | 15 TPS       | 666√ó                  |
| **Gas per tx**      | 150,000                | 21,000       | 7√ó (privacy overhead) |
| **Privacy**         | Native encrypted state | None         | ‚àû                     |
| **PQ Security**     | Yes                    | No           | -                     |
| **Determinism**     | Strict                 | Strict       | ‚úì                     |

---

## 11. Contract Upgrade Mechanism

### 11.1 Proxy Pattern

```rust
#[contract]
pub struct Proxy {
    // Current implementation address
    implementation: Address,
    
    // Admin who can upgrade
    admin: Address,
    
    // Storage for delegated contract
    delegated_storage: HashMap<Vec<u8>, Vec<u8>>,
}

#[contract_impl]
impl Proxy {
    pub fn new(implementation: Address) -> Self {
        Self {
            implementation,
            admin: context::caller(),
            delegated_storage: HashMap::new(),
        }
    }
    
    /// Upgrade to new implementation
    pub fn upgrade(&mut self, new_implementation: Address) -> Result<(), Error> {
        let caller = context::caller();
        
        if caller != self.admin {
            return Err(Error::Unauthorized);
        }
        
        // Verify new implementation exists
        verify_contract_exists(&new_implementation)?;
        
        self.implementation = new_implementation;
        
        // Emit upgrade event
        contract::emit_event("Upgraded", &new_implementation);
        
        Ok(())
    }
    
    /// Fallback: delegate all calls to implementation
    #[fallback]
    pub fn fallback(&mut self, method: &str, args: &[u8]) -> Vec<u8> {
        // Delegate call to implementation
        contract::call(
            &self.implementation,
            method,
            args,
            1_000_000,  // Gas limit
        )
    }
}
```

### 11.2 Migration Strategy

```rust
/// State migration interface
pub trait StateMigration {
    /// Old state version
    type OldState: serde::de::DeserializeOwned;
    
    /// New state version
    type NewState: serde::Serialize;
    
    /// Migrate from old to new
    fn migrate(old: Self::OldState) -> Result<Self::NewState, Error>;
}

/// Example migration
impl StateMigration for TokenV2 {
    type OldState = TokenV1;
    type NewState = TokenV2;
    
    fn migrate(old: TokenV1) -> Result<TokenV2, Error> {
        Ok(TokenV2 {
            name: old.name,
            symbol: old.symbol,
            decimals: old.decimals,
            total_supply: old.total_supply,
            balances: old.balances,
            // New field with default
            paused: false,
        })
    }
}
```

---

## 12. Testing Framework

### 12.1 Unit Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use ecliptica_test_utils::*;
    
    #[test]
    fn test_token_transfer() {
        // Setup test environment
        let mut env = TestEnv::new();
        
        // Deploy contract
        let token_addr = env.deploy_contract(
            include_bytes!("../target/wasm32-unknown-unknown/release/token.wasm"),
            &TokenConstructor {
                name: "Test Token".to_string(),
                symbol: "TST".to_string(),
                decimals: 18,
                initial_supply: 1_000_000,
            },
        ).unwrap();
        
        // Setup accounts
        let alice = env.create_account();
        let bob = env.create_account();
        
        // Transfer tokens
        let result = env.call_contract(
            &token_addr,
            &alice,
            "transfer",
            &TransferArgs {
                to: bob,
                amount: 100,
                proof: generate_test_proof(),
            },
        );
        
        assert!(result.is_ok());
        
        // Verify balances
        let alice_balance = env.query_contract(&token_addr, "balance_of", &alice);
        let bob_balance = env.query_contract(&token_addr, "balance_of", &bob);
        
        assert_eq!(decrypt_balance(&alice_balance), 999_900);
        assert_eq!(decrypt_balance(&bob_balance), 100);
    }
    
    #[test]
    fn test_insufficient_balance() {
        let mut env = TestEnv::new();
        let token_addr = env.deploy_contract(/* ... */).unwrap();
        
        let alice = env.create_account_with_balance(0);
        let bob = env.create_account();
        
        // Should fail
        let result = env.call_contract(
            &token_addr,
            &alice,
            "transfer",
            &TransferArgs {
                to: bob,
                amount: 100,
                proof: generate_test_proof(),
            },
        );
        
        assert!(matches!(result, Err(Error::InsufficientBalance)));
    }
}
```

### 12.2 Integration Testing

```rust
#[test]
fn test_cross_contract_calls() {
    let mut env = TestEnv::new();
    
    // Deploy Token contract
    let token = env.deploy_contract(
        include_bytes!("token.wasm"),
        &token_constructor(),
    ).unwrap();
    
    // Deploy DEX contract
    let dex = env.deploy_contract(
        include_bytes!("dex.wasm"),
        &dex_constructor(token),
    ).unwrap();
    
    // Test token approval + swap
    let alice = env.create_account();
    
    // Approve DEX to spend tokens
    env.call_contract(&token, &alice, "approve", &ApproveArgs {
        spender: dex,
        amount: 1000,
    }).unwrap();
    
    // Execute swap
    env.call_contract(&dex, &alice, "swap", &SwapArgs {
        amount_in: 1000,
        min_amount_out: 900,
    }).unwrap();
    
    // Verify balances changed
    assert_balance_decreased(&env, &token, &alice);
}
```

### 12.3 Fuzzing

```rust
#[cfg(fuzzing)]
mod fuzz {
    use libfuzzer_sys::fuzz_target;
    
    fuzz_target!(|data: &[u8]| {
        if let Ok(args) = parse_transfer_args(data) {
            let mut env = TestEnv::new();
            let token = deploy_token(&mut env);
            
            // Fuzz transfer calls
            let _ = env.call_contract(
                &token,
                &args.from,
                "transfer",
                &args,
            );
            
            // Verify invariants
            assert_total_supply_unchanged(&env, &token);
            assert_no_negative_balances(&env, &token);
        }
    });
}
```

---

## 13. Developer Tools

### 13.1 CLI Tools

```bash
# Compile contract
ecliptica contract build ./my-contract

# Deploy to testnet
ecliptica contract deploy \
  --wasm ./target/wasm32/release/my_contract.wasm \
  --args '{"name": "MyToken", "supply": 1000000}' \
  --network testnet \
  --key ./deployer.key

# Call contract
ecliptica contract call \
  --address 0x1234... \
  --method "transfer" \
  --args '{"to": "0x5678...", "amount": 100}' \
  --gas 200000

# Query contract state
ecliptica contract query \
  --address 0x1234... \
  --method "balance_of" \
  --args '{"account": "0x5678..."}'

# Estimate gas
ecliptica contract estimate-gas \
  --address 0x1234... \
  --method "complex_operation" \
  --args '{"data": "..."}'
```

### 13.2 Development Server

```bash
# Start local dev node
ecliptica dev start

# Watch and rebuild on changes
ecliptica contract watch ./my-contract

# Interactive console
ecliptica console
> let contract = await loadContract("0x1234...")
> await contract.methods.transfer("0x5678...", 100)
> await contract.events.Transfer.get()
```

---

## 14. RPC API

### 14.1 Contract Queries

```rust
// JSON-RPC endpoint
#[rpc]
impl ContractRPC {
    /// Get contract code
    async fn get_contract_code(&self, address: Address) -> Result<Vec<u8>> {
        self.state.get_contract_code(&address)
    }
    
    /// Get contract storage (encrypted)
    async fn get_contract_storage(
        &self,
        address: Address,
        key: Vec<u8>,
    ) -> Result<Vec<u8>> {
        self.state.get_storage(&address, &key)
    }
    
    /// Call contract (read-only)
    async fn call_contract(
        &self,
        request: CallRequest,
    ) -> Result<CallResult> {
        let instance = self.instantiate_contract(
            &request.contract_address,
            &request.caller,
            request.gas_limit,
        )?;
        
        let result = instance.call_method(
            &request.method,
            &request.args,
        )?;
        
        Ok(CallResult {
            return_value: result,
            gas_used: instance.store.data().gas_used,
            logs: instance.get_logs(),
        })
    }
    
    /// Estimate gas for contract call
    async fn estimate_gas(
        &self,
        request: CallRequest,
    ) -> Result<u64> {
        estimate_contract_call_gas(
            &request.contract_address,
            &request.method,
            &request.args,
        )
    }
    
    /// Get contract events
    async fn get_contract_events(
        &self,
        address: Address,
        from_block: u64,
        to_block: u64,
        topics: Vec<String>,
    ) -> Result<Vec<Event>> {
        self.state.query_events(address, from_block, to_block, topics)
    }
}

#[derive(Serialize, Deserialize)]
struct CallRequest {
    contract_address: Address,
    caller: Address,
    method: String,
    args: Vec<u8>,
    gas_limit: u64,
}

#[derive(Serialize, Deserialize)]
struct CallResult {
    return_value: Vec<u8>,
    gas_used: u64,
    logs: Vec<String>,
}
```

---

## 15. Complete Example: Private Voting

```rust
use ecliptica_contract_sdk::*;

#[contract]
pub struct PrivateVoting {
    // Proposal details
    title: String,
    description: String,
    
    // Voting period
    start_block: u64,
    end_block: u64,
    
    // Encrypted vote tallies
    yes_votes: EncryptedTally,
    no_votes: EncryptedTally,
    
    // Vote commitments (prevent double voting)
    vote_commitments: HashMap<Address, [u8; 32]>,
    
    // Admin viewing key (for result disclosure)
    admin_viewing_key: [u8; 32],
    admin: Address,
}

#[derive(Serialize, Deserialize, Clone)]
struct EncryptedTally {
    ciphertext: Vec<u8>,
    commitment: [u8; 32],
}

#[contract_impl]
impl PrivateVoting {
    pub fn new(
        title: String,
        description: String,
        voting_period_blocks: u64,
        admin_viewing_key: [u8; 32],
    ) -> Self {
        let current_block = context::block_height();
        
        Self {
            title,
            description,
            start_block: current_block,
            end_block: current_block + voting_period_blocks,
            yes_votes: Self::encrypt_tally(0),
            no_votes: Self::encrypt_tally(0),
            vote_commitments: HashMap::new(),
            admin_viewing_key,
            admin: context::caller(),
        }
    }
    
    /// Cast encrypted vote
    pub fn vote(&mut self, vote_yes: bool, proof: VoteProof) -> Result<(), Error> {
        let voter = context::caller();
        let current_block = context::block_height();
        
        // Check voting period
        if current_block < self.start_block || current_block > self.end_block {
            return Err(Error::VotingClosed);
        }
        
        // Check if already voted
        if self.vote_commitments.contains_key(&voter) {
            return Err(Error::AlreadyVoted);
        }
        
        // Verify ZK proof
        if !self.verify_vote_proof(&voter, &proof) {
            return Err(Error::InvalidProof);
        }
        
        // Update tally
        if vote_yes {
            self.yes_votes = proof.new_yes_tally;
        } else {
            self.no_votes = proof.new_no_tally;
        }
        
        // Record vote commitment
        self.vote_commitments.insert(voter, proof.vote_commitment);
        
        // Emit event
        contract::emit_event("VoteCast", &serde_json::to_vec(&VoteEvent {
            voter,
            commitment: proof.vote_commitment,
        }).unwrap());
        
        Ok(())
    }
    
    /// Get proposal info (public)
    pub fn get_proposal(&self) -> ProposalInfo {
        ProposalInfo {
            title: self.title.clone(),
            description: self.description.clone(),
            start_block: self.start_block,
            end_block: self.end_block,
            is_active: self.is_active(),
        }
    }
    
    /// Reveal results (admin only, after voting ends)
    pub fn reveal_results(&self, viewing_key: &[u8; 32]) -> Result<(u64, u64), Error> {
        let current_block = context::block_height();
        
        // Must be after voting period
        if current_block <= self.end_block {
            return Err(Error::VotingNotEnded);
        }
        
        // Verify viewing key
        if viewing_key != &self.admin_viewing_key {
            return Err(Error::InvalidViewingKey);
        }
        
        // Decrypt tallies
        let yes_bytes = crypto::decrypt(&self.yes_votes.ciphertext, viewing_key);
        let no_bytes = crypto::decrypt(&self.no_votes.ciphertext, viewing_key);
        
        let yes_count = u64::from_le_bytes(yes_bytes.try_into().unwrap());
        let no_count = u64::from_le_bytes(no_bytes.try_into().unwrap());
        
        Ok((yes_count, no_count))
    }
    
    fn is_active(&self) -> bool {
        let current_block = context::block_height();
        current_block >= self.start_block && current_block <= self.end_block
    }
    
    fn encrypt_tally(count: u64) -> EncryptedTally {
        // Encrypt the tally
        let plaintext = count.to_le_bytes();
        // In practice, use proper encryption key
        let ciphertext = vec![0u8; 32];  // Placeholder
        
        EncryptedTally {
            ciphertext,
            commitment: compute_commitment(count),
        }
    }
    
    fn verify_vote_proof(&self, voter: &Address, proof: &VoteProof) -> bool {
        // Verify zk-STARK proof that:
        // 1. Voter is eligible
        // 2. New tally is correct (incremented by 1)
        // 3. Voter hasn't voted before
        
        verify_stark_proof(&proof.stark_proof, &proof.public_inputs)
    }
}

#[derive(Serialize, Deserialize)]
struct VoteProof {
    new_yes_tally: EncryptedTally,
    new_no_tally: EncryptedTally,
    vote_commitment: [u8; 32],
    stark_proof: Vec<u8>,
    public_inputs: Vec<u8>,
}

#[derive(Serialize, Deserialize)]
struct ProposalInfo {
    title: String,
    description: String,
    start_block: u64,
    end_block: u64,
    is_active: bool,
}

#[derive(Serialize, Deserialize)]
struct VoteEvent {
    voter: Address,
    commitment: [u8; 32],
}

fn compute_commitment(value: u64) -> [u8; 32] {
    shake256(&value.to_le_bytes())
}
```

---

## 16. Best Practices

### 16.1 Security Guidelines

**DO:**
- ‚úÖ Always validate inputs
- ‚úÖ Use reentrancy guards for external calls
- ‚úÖ Check call depth before cross-contract calls
- ‚úÖ Emit events for important state changes
- ‚úÖ Use viewing keys for controlled disclosure
- ‚úÖ Implement access control (owner, admin roles)
- ‚úÖ Test edge cases thoroughly

**DON'T:**
- ‚ùå Store sensitive data unencrypted
- ‚ùå Trust user-provided proofs without verification
- ‚ùå Make unbounded loops (gas exhaustion)
- ‚ùå Use floating point arithmetic
- ‚ùå Rely on block timestamp for critical logic
- ‚ùå Allow arbitrary external calls without checks

### 16.2 Gas Optimization

```rust
// BAD: Multiple storage writes
pub fn bad_transfer(&mut self, to: Address, amount: u64) {
    let from_balance = self.balances.get(&self.caller()).unwrap();
    self.balances.insert(self.caller(), from_balance - amount);  // Write 1
    
    let to_balance = self.balances.get(&to).unwrap();
    self.balances.insert(to, to_balance + amount);  // Write 2
}

// GOOD: Batch storage operations
pub fn good_transfer(&mut self, to: Address, amount: u64) {
    let from_balance = self.balances.get(&self.caller()).unwrap();
    let to_balance = self.balances.get(&to).unwrap();
    
    // Compute new balances
    let new_from = from_balance - amount;
    let new_to = to_balance + amount;
    
    // Single storage transaction
    self.balances.batch_update(vec![
        (self.caller(), new_from),
        (to, new_to),
    ]);
}
```

### 16.3 Privacy Best Practices

```rust
// Use viewing keys for selective disclosure
pub fn create_viewing_key(&self, granularity: ViewingGranularity) -> ViewingKey {
    match granularity {
        ViewingGranularity::Full => {
            // Full access to all state
            ViewingKey::full(&self.contract_address)
        }
        ViewingGranularity::Specific(keys) => {
            // Access only to specific keys
            ViewingKey::specific(&self.contract_address, keys)
        }
        ViewingGranularity::ReadOnly => {
            // Read-only, cannot modify
            ViewingKey::readonly(&self.contract_address)
        }
    }
}
```

---

## 17. Future Enhancements

### 17.1 Roadmap

**Phase 1 (Current):**
- ‚úÖ WASM runtime with Wasmtime
- ‚úÖ Encrypted storage layer
- ‚úÖ ML-KEM/ML-DSA crypto primitives
- ‚úÖ Basic cross-contract calls

**Phase 2 (Q2 2026):**
- üîÑ GPU-accelerated ZK proof generation
- üîÑ Recursive STARK proofs (proof aggregation)
- üîÑ WebAssembly Component Model support
- üîÑ Formal verification tools

**Phase 3 (Q4 2026):**
- üìã Threshold encryption for multi-party contracts
- üìã Homomorphic encryption primitives
- üìã Private smart contract composition
- üìã Confidential compute enclaves (TEE integration)

**Phase 4 (2027+):**
- üìã Contract-level ZK-VM (full execution privacy)
- üìã Cross-chain contract calls
- üìã AI/ML inference in contracts
- üìã Quantum-resistant homomorphic encryption

### 17.2 Research Directions

**Optimization:**
- Parallel contract execution within shards
- State channel integration for off-chain computation
- Optimistic execution with fraud proofs

**Privacy:**
- Multi-party computation (MPC) primitives
- Fully homomorphic encryption (FHE) for computation on encrypted data
- Anonymous credentials and attribute-based encryption

**Scalability:**
- Contract sharding across multiple shards
- State rent to limit storage growth
- Stateless contracts with validity proofs

---

## Appendix A: Gas Cost Schedule

### Complete Gas Cost Table

| Operation                   | Gas Cost | Notes               |
| --------------------------- | -------- | ------------------- |
| **WASM Instructions**       |          |                     |
| Basic arithmetic (add, sub) | 1        | Per instruction     |
| Multiplication              | 4        | More expensive      |
| Division / Modulo           | 16       | Most expensive      |
| Memory load                 | 3        | Per load            |
| Memory store                | 3        | Per store           |
| Function call               | 10       | Per call            |
| Memory grow                 | 1,000    | Per page (64 KB)    |
| **Storage Operations**      |          |                     |
| Storage read                | 5,000    | Includes decryption |
| Storage write               | 20,000   | Includes encryption |
| Storage remove              | 20,000   | Same as write       |
| **Cryptography**            |          |                     |
| ML-KEM encrypt              | 10,000   | ~1.2ms              |
| ML-KEM decrypt              | 10,000   | ~1.0ms              |
| ML-DSA sign                 | 15,000   | ~1.8ms              |
| ML-DSA verify               | 8,000    | ~0.8ms              |
| Hash (SHAKE-256)            | 1,000    | Per 32 bytes        |
| **Blockchain Context**      |          |                     |
| Get caller                  | 100      | Trivial             |
| Get block height            | 100      | Trivial             |
| Get block timestamp         | 100      | Trivial             |
| **Inter-Contract**          |          |                     |
| Call contract (base)        | 50,000   | Plus execution cost |
| Emit event                  | 1,000    | Per event           |
| **Contract Deployment**     |          |                     |
| Deploy base                 | 100,000  | Per contract        |
| Code storage                | 1,000    | Per KB              |
| Constructor execution       | Variable | Depends on logic    |

---

## Appendix B: Error Codes

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ContractError {
    // Execution errors (100-199)
    OutOfGas = 100,
    StackOverflow = 101,
    MemoryAccessOutOfBounds = 102,
    InvalidInstruction = 103,
    ExecutionTimeout = 104,
    
    // Storage errors (200-299)
    KeyNotFound = 200,
    StorageLimitExceeded = 201,
    EncryptionFailed = 202,
    DecryptionFailed = 203,
    
    // Contract errors (300-399)
    ContractNotFound = 300,
    ContractTooLarge = 301,
    InvalidContract = 302,
    ConstructorFailed = 303,
    
    // Validation errors (400-499)
    FloatsNotAllowed = 400,
    ThreadsNotAllowed = 401,
    StartFunctionNotAllowed = 402,
    IllegalImport = 403,
    MemoryLimitExceeded = 404,
    
    // Call errors (500-599)
    MaxCallDepthExceeded = 500,
    ReentrancyDetected = 501,
    CallFailed = 502,
    InvalidMethodName = 503,
    
    // Permission errors (600-699)
    Unauthorized = 600,
    PermissionDenied = 601,
    InvalidViewingKey = 602,
    
    // Crypto errors (700-799)
    InvalidSignature = 700,
    InvalidPublicKey = 701,
    InvalidCiphertext = 702,
    
    // ZK proof errors (800-899)
    InvalidProof = 800,
    ProofVerificationFailed = 801,
}
```

---

## Appendix C: Contract Examples Repository

See the `contracts/examples/` directory for complete working examples:

1. **Basic Examples:**
   - `counter.rs` - Simple state management
   - `token.rs` - Fungible token (ERC-20 equivalent)
   - `nft.rs` - Non-fungible token (ERC-721 equivalent)

2. **Privacy Examples:**
   - `private_token.rs` - Encrypted balances with ZK proofs
   - `private_voting.rs` - Anonymous voting with tallies
   - `sealed_auction.rs` - Sealed-bid auction

3. **DeFi Examples:**
   - `dex.rs` - Decentralized exchange with AMM
   - `lending.rs` - Lending/borrowing protocol
   - `staking.rs` - Staking with rewards

4. **Advanced Examples:**
   - `dao.rs` - Decentralized autonomous organization
   - `multisig.rs` - Multi-signature wallet
   - `oracle.rs` - Price oracle with aggregation

---

**Document ID:** `ECLIPT-CONTRACT-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Complete Draft for Review