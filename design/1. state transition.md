# üîê **Ecliptica State Transition & Execution Model**

### *Post-Quantum Privacy-Preserving State Machine Specification*

**Version:** 0.1 (Draft)  
**Date:** October 2025  
**Document ID:** `ECLIPT-STATE-001`

---

## 1. Executive Summary

Ecliptica employs a **hybrid UTXO-Account model** with **encrypted state commitments** verified through **zk-STARK range proofs**. All balances, amounts, and transaction details remain encrypted using **ML-KEM-512** (Kyber), while state transitions are proven valid through zero-knowledge proofs over **lattice-based commitments**.

The state machine guarantees:
- **Confidentiality**: All amounts and balances encrypted at rest and in transit
- **Integrity**: zk-STARK proofs ensure no double-spending or invalid state transitions
- **Post-Quantum Security**: All primitives (KEM, signatures, commitments) resist quantum attacks
- **Determinism**: Canonical state root calculation across all validators

---

## 2. State Model Architecture

### 2.1 Hybrid UTXO-Account Design

Ecliptica uses a **dual-layer state model**:

| Layer                      | Model                            | Use Case                                      | Privacy Level                            |
| -------------------------- | -------------------------------- | --------------------------------------------- | ---------------------------------------- |
| **Layer 1: UTXO Layer**    | Unspent Transaction Output notes | Native token transfers, high-privacy payments | **Maximum** (full encryption)            |
| **Layer 2: Account Layer** | Balance-keyed accounts           | Smart contracts, staking, DeFi state          | **Configurable** (encrypted or shielded) |

**Rationale:**
- **UTXO Layer**: Provides unconditional privacy through note-based model (similar to Zcash Sapling)
- **Account Layer**: Enables efficient smart contract state management with optional privacy
- **Interoperability**: Bi-directional conversion between layers through atomic operations

---

## 3. Core State Components

### 3.1 Global State Structure

The global state $\Sigma$ at height $h$ consists of:

$$
\Sigma_h = \langle \mathcal{U}_h, \mathcal{A}_h, \mathcal{N}_h, \mathcal{C}_h \rangle
$$

Where:
- $\mathcal{U}_h$ = UTXO note commitment set (Sparse Merkle Tree)
- $\mathcal{A}_h$ = Account state mapping (address ‚Üí encrypted balance + nonce)
- $\mathcal{N}_h$ = Nullifier set (spent note commitments)
- $\mathcal{C}_h$ = Contract storage trie

### 3.2 State Root Calculation

The canonical state root $\rho_h$ is computed as:

$$
\rho_h = \text{SHAKE-256}(\text{SMT-Root}(\mathcal{U}_h) \parallel \text{SMT-Root}(\mathcal{A}_h) \parallel \text{BF}(\mathcal{N}_h) \parallel \text{MPT-Root}(\mathcal{C}_h))
$$

Where:
- $\text{SMT-Root}$ = Sparse Merkle Tree root hash
- $\text{BF}$ = Bloom filter commitment of nullifier set
- $\text{MPT-Root}$ = Modified Patricia Trie root (for contracts)
- $\parallel$ = canonical concatenation (length-prefixed)

---

## 4. UTXO Layer Specification

### 4.1 Note Structure

Each UTXO note $\eta$ has the form:

$$
\eta = \langle \text{cm}, \text{epk}, C_{\text{enc}}, \rho_{\eta} \rangle
$$

Where:
- $\text{cm} = \text{Commit}(v, \text{addr}, r)$ = note commitment (binding)
- $\text{epk}$ = ephemeral ML-KEM-512 public key
- $C_{\text{enc}}$ = encrypted payload: $\text{ML-KEM.Enc}(\text{epk}, v \parallel \text{addr} \parallel \text{memo})$
- $\rho_{\eta}$ = note randomness (for nullifier derivation)

**Commitment Scheme:**

$$
\text{cm} = \text{SHAKE-256}(v \parallel \text{addr} \parallel r \parallel \text{domain-sep})
$$

Properties:
- **Hiding**: Commitment reveals nothing about $v$ or $\text{addr}$
- **Binding**: Computationally infeasible to find two openings for same commitment
- **Post-Quantum**: Based on symmetric crypto (SHA-3 family)

### 4.2 Nullifier Derivation

To prevent double-spending, each spent note produces a unique nullifier:

$$
\text{nf} = \text{PRF}_{\text{nk}}(\rho_{\eta} \parallel \text{cm})
$$

Where:
- $\text{nk}$ = nullifier key (derived from master secret via LWE-PRF)
- $\text{PRF}_{\text{nk}}$ = pseudorandom function (LWE-based, PQ-secure)

**Properties:**
- Deterministic given $(\text{nk}, \rho_{\eta}, \text{cm})$
- Unlinkable across notes without $\text{nk}$
- Collision-resistant

### 4.3 UTXO State Transition

**Input Validation:**

For each input note $\eta_i$:
1. Verify $\text{cm}_i \in \mathcal{U}_h$ (Merkle proof of inclusion)
2. Verify $\text{nf}_i \notin \mathcal{N}_h$ (nullifier not already spent)
3. Verify zk-STARK proof $\pi_{\text{spend}}$:

$$
\pi_{\text{spend}} \text{ proves: } \begin{cases}
\text{Know } (v_i, \text{addr}_i, r_i, \text{nk}) \\
\text{cm}_i = \text{Commit}(v_i, \text{addr}_i, r_i) \\
\text{nf}_i = \text{PRF}_{\text{nk}}(\rho_i \parallel \text{cm}_i) \\
\text{Signature valid under } \text{addr}_i
\end{cases}
$$

**Output Creation:**

For each output note $\eta_j$:
1. Generate fresh randomness $r_j \leftarrow \{0,1\}^{256}$
2. Compute commitment $\text{cm}_j = \text{Commit}(v_j, \text{addr}_j, r_j)$
3. Encrypt payload: $C_{\text{enc},j} = \text{ML-KEM.Enc}(\text{epk}_j, v_j \parallel \text{addr}_j \parallel \text{memo}_j)$

**Balance Conservation:**

The transaction must prove (in zero-knowledge):

$$
\sum_{i} v_i = \sum_{j} v_j + f_{\text{tx}}
$$

Where $f_{\text{tx}}$ is the transaction fee (revealed in plaintext).

**State Update:**

$$
\begin{align}
\mathcal{U}_{h+1} &= \mathcal{U}_h \cup \{\text{cm}_j : j \in \text{outputs}\} \\
\mathcal{N}_{h+1} &= \mathcal{N}_h \cup \{\text{nf}_i : i \in \text{inputs}\}
\end{align}
$$

---

## 5. Account Layer Specification

### 5.1 Account State Structure

Each account $\alpha$ at address $\text{addr}$ maintains:

$$
\text{Account}(\text{addr}) = \langle C_{\text{bal}}, n, s, \text{code-hash}, \text{storage-root} \rangle
$$

Where:
- $C_{\text{bal}}$ = encrypted balance commitment
- $n$ = nonce (replay protection, monotonic)
- $s$ = staking state (optional, for validators)
- $\text{code-hash}$ = SHAKE-256 hash of contract bytecode (if contract account)
- $\text{storage-root}$ = Merkle root of contract storage trie

### 5.2 Encrypted Balance Commitment

The balance commitment uses **additively homomorphic encryption**:

$$
C_{\text{bal}} = \text{Enc}_{\text{pk}}(v, r) = \text{ML-KEM.Enc}(\text{pk}, v \parallel r)
$$

Where:
- $\text{pk}$ = account's public key (ML-KEM-512)
- $v$ = balance (64-bit unsigned integer)
- $r$ = blinding factor (256-bit randomness)

**Homomorphic Property (Simulated):**

While ML-KEM is not natively homomorphic, we achieve balance updates through **re-encryption with proofs**:

$$
C'_{\text{bal}} = \text{Enc}_{\text{pk}}(v + \Delta v, r')
$$

With a zk-STARK proving:

$$
\pi_{\text{update}} \text{ proves: } \begin{cases}
\text{Know } (v, r, \Delta v, r') \\
C_{\text{bal}} = \text{Enc}_{\text{pk}}(v, r) \\
C'_{\text{bal}} = \text{Enc}_{\text{pk}}(v + \Delta v, r') \\
v + \Delta v \geq 0 \text{ (no underflow)} \\
v + \Delta v < 2^{64} \text{ (no overflow)}
\end{cases}
$$

### 5.3 Nonce Management

**Nonce Properties:**
- Strictly monotonic per account
- Prevents transaction replay
- Included in transaction signature
- Publicly visible (does not compromise privacy)

**Nonce Verification:**

For transaction $\text{tx}$ from $\text{addr}$:
1. Let $n_{\text{current}} = \text{Account}(\text{addr}).n$
2. Require $\text{tx.nonce} = n_{\text{current}} + 1$
3. After execution: $\text{Account}(\text{addr}).n \leftarrow n_{\text{current}} + 1$

**Nonce Gap Handling:**

If $\text{tx.nonce} > n_{\text{current}} + 1$:
- Transaction is **pending** (held in mempool)
- Not included in block until nonce gap is filled
- Subject to mempool expiry (configurable, e.g., 256 blocks)

### 5.4 Account State Transition

**Transfer Operation ($\text{addr}_A \rightarrow \text{addr}_B$):**

1. **Debit $\text{addr}_A$:**
   - Decrypt $v_A$ (off-chain, by owner)
   - Compute new balance: $v'_A = v_A - \Delta v - f_{\text{tx}}$
   - Generate proof $\pi_{\text{debit}}$:

$$
\pi_{\text{debit}} \text{ proves: } \begin{cases}
C_{\text{bal},A} = \text{Enc}_{\text{pk}_A}(v_A, r_A) \\
C'_{\text{bal},A} = \text{Enc}_{\text{pk}_A}(v'_A, r'_A) \\
v_A \geq \Delta v + f_{\text{tx}} \\
v'_A = v_A - \Delta v - f_{\text{tx}}
\end{cases}
$$

2. **Credit $\text{addr}_B$:**
   - Compute new balance commitment: $C'_{\text{bal},B} = \text{Enc}_{\text{pk}_B}(v_B + \Delta v, r'_B)$
   - Generate proof $\pi_{\text{credit}}$ (similar structure)

3. **Atomic Update:**

$$
\begin{align}
\text{Account}(\text{addr}_A).C_{\text{bal}} &\leftarrow C'_{\text{bal},A} \\
\text{Account}(\text{addr}_A).n &\leftarrow n_A + 1 \\
\text{Account}(\text{addr}_B).C_{\text{bal}} &\leftarrow C'_{\text{bal},B}
\end{align}
$$

---

## 6. Zero-Knowledge Proof System

### 6.1 zk-STARK Circuit Constraints

**Constraint System:**

All state transitions are proven using **zk-STARKs** over the Rescue-Prime hash function. The circuit enforces:

1. **Range Constraints:**
   - $0 \leq v < 2^{64}$ for all balances
   - Prevents underflow/overflow

2. **Commitment Consistency:**
   - $\text{cm} = \text{SHAKE-256}(v \parallel \text{addr} \parallel r)$
   - Verifiable without revealing $(v, \text{addr}, r)$

3. **Balance Conservation:**
   - $\sum \text{inputs} = \sum \text{outputs} + \text{fee}$
   - Proven with Pedersen-like commitments over lattice assumptions

4. **Nullifier Correctness:**
   - $\text{nf} = \text{PRF}_{\text{nk}}(\rho \parallel \text{cm})$
   - LWE-PRF implemented as circuit gadget

5. **Signature Verification:**
   - ML-DSA (Dilithium-3) signature verification circuit
   - Proves authorization without revealing signing key

### 6.2 Proof Generation & Verification

**Prover Input (Private Witness):**

$$
w = \langle v, \text{addr}, r, \text{nk}, \text{sk}, \text{nonce} \rangle
$$

**Public Input:**

$$
x = \langle \text{cm}, \text{nf}, C_{\text{enc}}, C_{\text{bal}}, \text{state-root}_h, \text{nonce} \rangle
$$

**Proof Statement:**

$$
\pi_{\text{tx}} \leftarrow \text{STARK.Prove}(\mathcal{C}_{\text{Ecliptica}}, x, w)
$$

Where $\mathcal{C}_{\text{Ecliptica}}$ is the constraint system encoding all rules above.

**Verification (On-Chain):**

$$
\{0, 1\} \leftarrow \text{STARK.Verify}(\mathcal{C}_{\text{Ecliptica}}, x, \pi_{\text{tx}})
$$

**Performance Targets:**
- Proof generation: < 2 seconds (on 16-core CPU)
- Proof size: < 50 KB (with recursive compression)
- Verification time: < 200 ms (single-threaded)

---

## 7. State Root Calculation (Canonical)

### 7.1 Sparse Merkle Tree (SMT) for UTXO Set

**Tree Structure:**
- Height: 256 (full address space)
- Leaf: $\text{SHAKE-256}(\text{cm} \parallel \text{metadata})$
- Branch: $\text{SHAKE-256}(\text{left} \parallel \text{right})$
- Empty node: constant $\emptyset = \text{SHAKE-256}(\text{"empty"})$

**Insertion:**

$$
\mathcal{U}_{h+1} = \text{SMT.Insert}(\mathcal{U}_h, \text{index}(\text{cm}), \text{leaf}(\text{cm}))
$$

Where $\text{index}(\text{cm}) = \text{SHAKE-256}(\text{cm})[0:256]$ (256-bit index).

**Proof of Inclusion:**

$$
\pi_{\text{incl}} = (\text{cm}, \text{path}, \text{siblings})
$$

Verifier checks:

$$
\text{SHAKE-256}^{(256)}(\text{cm}, \text{path}, \text{siblings}) = \rho_{\mathcal{U}}
$$

### 7.2 Account State Trie

**Modified Patricia Trie (MPT):**
- Key: $\text{SHAKE-256}(\text{addr})[0:160]$ (160-bit address)
- Value: $\text{RLP}(\text{Account}(\text{addr}))$ (Recursive Length Prefix encoding)
- Hash function: SHAKE-256

**State Root:**

$$
\rho_{\mathcal{A}} = \text{MPT-Root}(\{\text{addr} \mapsto \text{Account}(\text{addr}) : \forall \text{addr} \in \mathcal{A}\})
$$

---

## 8. Transaction Format

### 8.1 UTXO Transaction

```
UTXOTransaction {
  version: u8,
  inputs: Vec<Input>,
  outputs: Vec<Output>,
  fee: u64,                    // plaintext fee
  proof: STARKProof,           // zk-STARK covering all inputs/outputs
  binding_sig: [u8; 64],       // ML-DSA signature over tx hash
}

Input {
  note_cm: [u8; 32],           // note commitment
  nullifier: [u8; 32],         // derived nullifier
  merkle_path: Vec<[u8; 32]>,  // Merkle proof of cm inclusion
}

Output {
  note_cm: [u8; 32],           // new note commitment
  ephemeral_pk: [u8; 800],     // ML-KEM-512 public key
  ciphertext: Vec<u8>,         // encrypted payload
}
```

### 8.2 Account Transaction

```
AccountTransaction {
  version: u8,
  from: Address,               // sender address (20 bytes)
  to: Address,                 // recipient address
  nonce: u64,                  // sender nonce
  encrypted_amount: [u8; 768], // ML-KEM ciphertext of amount
  proof: STARKProof,           // balance update proof
  gas_limit: u64,
  gas_price: u64,
  signature: [u8; 2420],       // ML-DSA (Dilithium-3) signature
}
```

### 8.3 Transaction Hash (Canonical)

$$
\text{tx-hash} = \text{SHAKE-256}(\text{serialize}(\text{tx}))
$$

Where $\text{serialize}$ is **deterministic** (canonical byte ordering):
- Little-endian for integers
- Length-prefixed for variable-length fields
- Lexicographic ordering for vectors

---

## 9. State Transition Function

### 9.1 Formal Definition

The state transition function $\delta$ is defined as:

$$
\delta: \Sigma_h \times \text{Block}_h \rightarrow \Sigma_{h+1} \cup \{\bot\}
$$

Where $\bot$ indicates invalid transition (block rejected).

### 9.2 Block Validation

For block $B_h$ with transactions $\{\text{tx}_1, \ldots, \text{tx}_k\}$:

**Sequential Execution:**

$$
\Sigma_{h,0} = \Sigma_h
$$

For $i = 1 \ldots k$:

$$
\Sigma_{h,i} = \begin{cases}
\text{ApplyTx}(\Sigma_{h,i-1}, \text{tx}_i) & \text{if } \text{ValidateTx}(\text{tx}_i, \Sigma_{h,i-1}) = \text{true} \\
\Sigma_{h,i-1} & \text{otherwise (skip invalid tx)}
\end{cases}
$$

Final state: $\Sigma_{h+1} = \Sigma_{h,k}$

### 9.3 Transaction Validation

```
ValidateTx(tx, Œ£) ‚Üí {true, false}

1. Verify transaction format (deserializes correctly)
2. Check version compatibility
3. Verify signature (ML-DSA):
   - For UTXO: binding signature over tx-hash
   - For Account: sender signature over (nonce || to || amount || ...)
4. Check nonce (Account only):
   - tx.nonce = Account(tx.from).nonce + 1
5. Verify zk-STARK proof:
   - STARK.Verify(proof, public_inputs) = true
6. Check fee sufficiency:
   - tx.fee ‚â• gas_used √ó gas_price
7. Replay protection:
   - For UTXO: nullifiers not in N
   - For Account: nonce not reused
8. Merkle proofs (UTXO only):
   - All input commitments in U_h
```

### 9.4 State Update Rules

**UTXO Updates:**

$$
\begin{align}
\mathcal{U}_{h+1} &= (\mathcal{U}_h \cup \text{new-commitments}) \\
\mathcal{N}_{h+1} &= (\mathcal{N}_h \cup \text{new-nullifiers})
\end{align}
$$

**Account Updates:**

$$
\begin{align}
\text{Account}(\text{addr}).C_{\text{bal}} &\leftarrow C'_{\text{bal}} \\
\text{Account}(\text{addr}).n &\leftarrow n + 1
\end{align}
$$

**State Root:**

$$
\rho_{h+1} = \text{SHAKE-256}(\rho_{\mathcal{U}} \parallel \rho_{\mathcal{A}} \parallel \rho_{\mathcal{N}} \parallel \rho_{\mathcal{C}})
$$

---

## 10. Replay Protection

### 10.1 UTXO Layer

**Nullifier Set Membership:**
- Each spent note produces unique nullifier $\text{nf}$
- $\text{nf}$ added to $\mathcal{N}_h$ upon spending
- Any transaction attempting to spend same note will have same $\text{nf}$
- Validator rejects if $\text{nf} \in \mathcal{N}_h$

**Properties:**
- Unconditional replay protection
- No account state required
- Resistant to reorganizations (nullifiers never removed)

### 10.2 Account Layer

**Nonce Sequencing:**
- Each account maintains strictly increasing nonce
- Transaction must have $\text{nonce} = \text{current-nonce} + 1$
- After execution, account nonce incremented

**Reorganization Handling:**
- On chain reorg, revert nonce changes
- Transactions in reverted blocks return to mempool
- Re-validation with updated nonces

**Gap Prevention:**
- Mempool enforces nonce ordering
- Transactions with future nonces held until gap filled
- Timeout policy prevents indefinite holds

---

## 11. Cross-Layer Interoperability

### 11.1 UTXO ‚Üí Account Conversion

**Shield Operation:**

```
Convert UTXO note ‚Üí Account balance

1. Spend UTXO note (generates nullifier nf)
2. Prove knowledge of note value v
3. Credit Account(addr) with encrypted balance += v
4. Atomic: nullifier added AND account updated
```

**Transaction Structure:**

```
ShieldTransaction {
  utxo_input: Input,           // UTXO note to consume
  account_dest: Address,       // target account
  proof: STARKProof,           // proves v from UTXO = v to Account
  signature: [u8; 2420],       // authorizes conversion
}
```

### 11.2 Account ‚Üí UTXO Conversion

**Unshield Operation:**

```
Convert Account balance ‚Üí UTXO note

1. Debit Account(addr) by amount v
2. Create new UTXO note with value v
3. Atomic: account debited AND note created
```

---

## 12. Determinism Guarantees

### 12.1 Sources of Non-Determinism (Eliminated)

| Source                   | Mitigation                                    |
| ------------------------ | --------------------------------------------- |
| Floating point           | **Forbidden** in all state logic              |
| Random number generation | Use deterministic DRBG seeded from block hash |
| Time-based logic         | Use block height/timestamp (canonical)        |
| Hash function ordering   | Canonical serialization before hashing        |
| Parallel execution       | Sequential transaction ordering in block      |
| External calls           | Sandboxed; gas-metered; deterministic results |

### 12.2 Canonical Serialization Rules

**Byte Ordering:**
- All integers: **little-endian**
- Hashes: raw byte arrays (no hex encoding)

**Length Encoding:**
- Variable-length fields: prefix with `varint` length
- Fixed-length fields: no prefix

**Struct Serialization:**
- Fields in declaration order
- No padding or alignment

**Vector Serialization:**
- Length prefix (varint)
- Elements in index order

---

## 13. State Pruning & Archival

### 13.1 Pruning Policy

**UTXO Notes:**
- Spent notes (nullifiers in $\mathcal{N}$) can be pruned after $N_{\text{finality}}$ blocks
- Commitment remains in SMT (sparse, minimal overhead)
- Historical proofs available from archive nodes

**Accounts:**
- Zero-balance accounts with no activity for $N_{\text{prune}}$ epochs can be pruned
- Account hash remains in state root (for historical verification)

**State Snapshots:**
- Full state snapshot every $N_{\text{snapshot}}$ blocks (e.g., 10,000)
- Validators can bootstrap from snapshot + recent blocks

### 13.2 Archive Node Requirements

Full history retention:
- All UTXO notes (spent and unspent)
- All account states (historical)
- All transaction bodies
- All zk-STARK proofs

Storage estimate (5 years):
- ~50 TB for full archive (50k TPS, 1 KB avg tx size)

---

## 14. Security Properties

### 14.1 Invariants

The state machine maintains:

**I1 (Balance Conservation):**

$$
\sum_{\text{addr}} \text{Balance}(\text{addr}) + \sum_{\text{cm} \in \mathcal{U}} v(\text{cm}) = \text{TotalSupply}
$$

**I2 (Non-Negativity):**

$$
\forall \text{addr}: \text{Balance}(\text{addr}) \geq 0
$$

**I3 (Nullifier Uniqueness):**

$$
\forall \text{nf} \in \mathcal{N}: \text{Count}(\text{nf}) = 1
$$

**I4 (Nonce Monotonicity):**

$$
\forall \text{addr}, \forall h < h': \text{Account}(\text{addr}, h).n \leq \text{Account}(\text{addr}, h').n
$$

### 14.2 Attack Resistance

| Attack Vector     | Defense Mechanism                            |
| ----------------- | -------------------------------------------- |
| Double-spending   | Nullifier set + zk-STARK proofs              |
| Balance inflation | Range proofs + conservation proofs           |
| Replay attacks    | Nullifiers (UTXO) + Nonces (Account)         |
| Front-running     | Encrypted mempool (optional) + fair ordering |
| State bloat       | Pruning policy + storage rent (future)       |
| Quantum attacks   | ML-KEM, ML-DSA, SHAKE-256 (all PQ-secure)    |

---

## 15. Implementation Notes

### 15.1 Rust Type Definitions

```rust
// Core state types
pub struct GlobalState {
    pub utxo_set: SparseMerkleTree<Commitment, NoteMetadata>,
    pub accounts: AccountTrie,
    pub nullifiers: BloomFilter<Nullifier>,
    pub contracts: ContractStorage,
}

pub struct Account {
    pub balance_commitment: Ciphertext,  // ML-KEM encrypted
    pub nonce: u64,
    pub staking: Option<StakingState>,
    pub code_hash: Option<Hash>,
    pub storage_root: Hash,
}

pub struct UTXONote {
    pub commitment: Commitment,      // 32 bytes
    pub ephemeral_pk: PublicKey,     // 800 bytes (ML-KEM-512)
    pub ciphertext: Vec<u8>,         // variable
    pub randomness: [u8; 32],
}
```

### 15.2 Proof Generation Pipeline

```rust
// zk-STARK proof workflow
pub fn generate_tx_proof(
    witness: PrivateWitness,
    public_inputs: PublicInputs,
) -> Result<STARKProof> {
    // 1. Build constraint system
    let circuit = EclipticaCircuit::new();
    
    // 2. Generate execution trace
    let trace = circuit.execute(witness)?;
    
    // 3. Commit to trace (FRI protocol)
    let commitment = commit_trace(&trace);
    
    // 4. Generate proof
    let proof = prove_constraints(circuit, trace, public_inputs)?;
    
    // 5. Compress (optional recursion)
    let compressed = recursive_compress(proof)?;
    
    Ok(compressed)
}
```

---

## 16. Open Research Questions

1. **Homomorphic Balance Updates**: Can we avoid full re-encryption on every balance change? Lattice-based somewhat-homomorphic schemes?

2. **Mempool Privacy**: How to hide transaction amounts in mempool without enabling front-running?

3. **State Diff Compression**: Efficient delta encoding for state synchronization?

4. **Recursive STARK Aggregation**: Optimal recursion depth for beacon finality proofs?

5. **Privacy-Preserving Analytics**: Can we expose useful chain metrics without leaking user data?

---

## 17. Formal Verification Roadmap

**Phase 1 (v0.1):**
- Prove nonce monotonicity (TLA+)
- Prove nullifier uniqueness (Coq)
- Prove balance conservation (Lean)

**Phase 2 (v0.5):**
- Model full state transition in Isabelle/HOL
- Verify zk-STARK circuit correctness
- Prove replay attack resistance

**Phase 3 (v1.0):**
- End-to-end state machine verification
- Quantum security proofs (lattice hardness)
- Privacy leakage analysis (formal)

---

**Document ID:** `ECLIPT-STATE-001`  
**Maintainer:** Ecliptica Protocol Engineering  
**License:** CC-BY-SA-4.0  
**Status:** Draft for Review